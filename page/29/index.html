<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hang&#39;s Blog">
<meta property="og:url" content="https://example.com/page/29/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/page/29/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Understand-Kubernetes-API-Access-Control-Mechanisms-25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Understand-Kubernetes-API-Access-Control-Mechanisms-25/" class="post-title-link" itemprop="url">CKAD-Understand-Kubernetes-API-Access-Control-Mechanisms-25</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:32:00" itemprop="dateCreated datePublished" datetime="2022-11-19T00:32:00-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:29:12" itemprop="dateModified" datetime="2022-11-21T00:29:12-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Understand-Kubernetes-API-Access-Control-Mechanisms-25/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Understand-Kubernetes-API-Access-Control-Mechanisms-25/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Using-Kubernetes-Custom-Resource-Definitions-CRDs-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Using-Kubernetes-Custom-Resource-Definitions-CRDs-24/" class="post-title-link" itemprop="url">CKAD-Using-Kubernetes-Custom-Resource-Definitions-CRDs-24</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:58" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:58-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:29:38" itemprop="dateModified" datetime="2022-11-21T00:29:38-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Using-Kubernetes-Custom-Resource-Definitions-CRDs-24/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Using-Kubernetes-Custom-Resource-Definitions-CRDs-24/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Using-Kubernetes-Primitives-to-Implement-Common-Deployment-Strategies-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Using-Kubernetes-Primitives-to-Implement-Common-Deployment-Strategies-23/" class="post-title-link" itemprop="url">CKAD-Using-Kubernetes-Primitives-to-Implement-Common-Deployment-Strategies-23</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:56" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:56-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:26:18" itemprop="dateModified" datetime="2022-11-21T00:26:18-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Using-Kubernetes-Primitives-to-Implement-Common-Deployment-Strategies-23/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Using-Kubernetes-Primitives-to-Implement-Common-Deployment-Strategies-23/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Exposing-Applications-Using-Kubernetes-Ingress-Rules-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Exposing-Applications-Using-Kubernetes-Ingress-Rules-22/" class="post-title-link" itemprop="url">CKAD-Exposing-Applications-Using-Kubernetes-Ingress-Rules-22</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:55" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:55-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:28:58" itemprop="dateModified" datetime="2022-11-21T00:28:58-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Exposing-Applications-Using-Kubernetes-Ingress-Rules-22/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Exposing-Applications-Using-Kubernetes-Ingress-Rules-22/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Performing-a-Kubernetes-Deployment-using-ConfigMaps-and-Helm-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Performing-a-Kubernetes-Deployment-using-ConfigMaps-and-Helm-21/" class="post-title-link" itemprop="url">CKAD-Performing-a-Kubernetes-Deployment-using-ConfigMaps-and-Helm-21</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:54" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:54-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:27:18" itemprop="dateModified" datetime="2022-11-21T00:27:18-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Performing-a-Kubernetes-Deployment-using-ConfigMaps-and-Helm-21/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Performing-a-Kubernetes-Deployment-using-ConfigMaps-and-Helm-21/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Introduction-to-Helm-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Introduction-to-Helm-20/" class="post-title-link" itemprop="url">CKAD-Introduction-to-Helm-20</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:52" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:52-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:24:06" itemprop="dateModified" datetime="2022-11-21T00:24:06-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Introduction-to-Helm-20/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Introduction-to-Helm-20/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Hello, and welcome to the Introduction to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-introduction/">Helm</a> course. Presented to you by Cloud Academy. In this lesson, I will cover off the course agenda, intended audience, learning objectives and course prerequisites. Now, I’m really excited to be taking you through this course. Helm is a package manager, the package manager for Kubernetes, used to simplify and enhance the deployment experience for deploying resources into a Kubernetes cluster.</p>
<p>Before we continue, let me quickly introduce myself. I’m Jeremy Cook, one of the trainers here at Cloud Academy specializing in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/devops/">DevOps</a> and software engineering. Feel free to connect with either myself and&#x2F;or the wider team here at Cloud Academy. Regarding anything about this course, you can email us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This training course focuses on bringing you up to speed with Helm 3. Helm 3 is the latest version of Helm and builds upon the successes of Helm 2. I’ll take you through all of the fundamentals involved in working with Helm 3, and highlight the key differences when compared to the previous version. As already mentioned, Helm is a package manager for Kubernetes. Therefore, to get the most out of this course, you should have existing knowledge and or experience with Kubernetes. And in particular, deploying workloads into Kubernetes.</p>
<p>Now, if instead, you’re completely new to Kubernetes, then please consider first taking our dedicated <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/cloud-academy-introduction-to-kubernetes-92/">Introduction to Kubernetes</a> learning path. This course provides several hands-on demonstrations. I’ll show you not only how to install and setup Helm, but also how to use Helm to perform various chart cluster management related tasks. I’ll also demonstrate how to create and host your very own Helm chart.</p>
<p>All of the coding assets which are used and demonstrated throughout the course can be found within the following Cloud Academy GitHub repository. You’re strongly encouraged to clone this repository and perform the site home commands against your own Kubernetes cluster. The intended audience for this course includes; anyone interested in learning about Helm and its fundamentals. Software engineers interested in learning about how to configure and deploy Helm charts into a Kubernetes cluster. And DevOps and SRE practitioners interested in understanding how to install, manage, and maintain Helm deployed infrastructure.</p>
<p>By completing this course, you will learn about what Helm is and how to install it. Learn about Helm charts, templates, releases, revisions, and repositories. Learn how to deploy, upgrade and rollback Helm charts. And finally, you’ll learn how to create and host your very own Helm charts. The following prerequisites will be both useful and helpful for this course. A basic understanding of Kubernetes. Experience with deploying Kubernetes resources such as pods, deployments, services, etc. And a basic understanding of software development in the software development lifecycle.</p>
<p>All right, the course introduction has now been completed, go ahead and close this lesson and I’ll see you shortly in the next one.</p>
<h1 id="Helm-Introduction"><a href="#Helm-Introduction" class="headerlink" title="Helm Introduction"></a>Helm Introduction</h1><p>Welcome back. In this lesson, I’m going to introduce you to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> and review its background, what motivated its creation, the terminology associated with it, and when and where you should consider using it yourself. To begin with, Helm is an application package manager for Kubernetes. So what, and why do I need one, you may be asking yourself. I’m already familiar with kubectl and I know I can use that to create resources in the cluster and it works.</p>
<p>Therefore, why do I need to consider using Helm? Well, it turns out, for large and intricate deployments, Helm can be used to simplify and enhance the deployment experience. How so, you’re now probably wondering. Well, let’s first consider life before Helm came onto the scene. Kubernetes, as we know, is an open source cluster-based system used to schedule and orchestrate containerized applications. A containerized application is normally composed of multiple Kubernetes resources. For example, consider a simple three-tiered based application, consisting of a front end, application, and database tiers. Deploying this into Kubernetes could be accomplished by deploying several resources, such as a deployment, configmap, and service resource for each tier. Each required resource will be typically codified into its own manifest file. All manifest files are typically secured and version controlled to ensure that we have a verifiable and auditable record of change, knowing for sure what gets deployed into our cluster.</p>
<p>Now, when it comes to deployment time, we need to execute the <code>kubectl apply</code> command multiple times, one for each of our manifest files. Now, this becomes problematic since we need to run the <code>kubectl</code> command each time for each individual resource. This is not only labor intensive, but also error prone.</p>
<p>Dependencies can be forgotten or perhaps the installation sequence is incorrectly performed, all of which requires rework and effort to fix and remediate. We also need to consider the limitations of working directly with manifest files themselves. For example, manifests don’t facilitate parametrization. This often leads to manifest proliferation to accommodate small environmental changes. Manifests don’t provide any functionality to wire into the application deployment lifecycle hooks. Often, you will want to do some external activity either just before or just after a resource has created within the cluster. And there really isn’t a decent native way to manage and maintain a history of revisions for a related set of manifest files within Kubernetes. Enter Helm.</p>
<p>Helm was originally introduced to simply and enhance the Kubernetes cluster deployment experience. Helm uses the concept of a chart, which is in essence a package containing all of the related parts for a specific cluster deployment. Helm can be used to deploy applications that consist of many resources with a single command.</p>
<p>Helm takes care of deploying the chart and its individual resources, all in the correct sequenced order, and ensures that the final deployment outcome is a fully functioning application. There’s definitely a lot more to Helm and I’ll dive deeper as the course progresses, but this should give you a good idea of the space that Helm plays in. Okay, that completes this lesson. In this lesson, I introduced you to some of the pain points involved when working with Kubernetes manifest files and for which Helm fixes for us.</p>
<h1 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h1><p>Welcome back. In this lesson, I’m going to review some of the more important benefits that are provided by <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a>. By the end of this lesson, you should have a clear understanding why Helm is used to perform cluster deployments.</p>
<p>Starting with complexity, Helm manages and abstracts away complexity. When it comes to deploying a cloud-native application composed of multiple resources, Helm can literally deploy it with a single command. Not only that, but the same chart can be deployed multiple times in different environments with different input values that help you to customize the overall behavior of the application.</p>
<p>Helm provides you with the ability to upgrade existing releases. When you do so, the history of change is tracked for you, which if required, allows you to rollback to previous versions. Helm makes it super easy to package, distribute, and download charts. As a chart developer, once you’ve completed your chart build, you simply package it by running the command helm package, providing it with a chart name. This results in an archive file or chart package which you then typically host within a chart repository.</p>
<p>Other users can then add your repository to their own Helm setup and then, search for and install your chart into their own cluster. As mentioned earlier, Helm maintains a revision history for each chart release. This enables you to perform rollbacks to any previous version. When it comes to building your own charts, Helm also provides a simple to use chart scaffolding command, which when invoked, will generate a skeleton chart for you.</p>
<p>The skeleton chart comes complete with the required directory structure and examples of all required files. As a chart developer, you can use this as your starting point and begin customizing it to suit your needs, et cetera.</p>
<p>Okay, that completes this lesson. In this lesson, I dived deeper into the benefits that Helm provides you. Go ahead and close this lesson now, and I’ll see you shortly in the next one.</p>
<h1 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h1><p>Welcome back! In this lesson, I’m going to provide a quick review of the terminology associated when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a>. Understanding the Helm terminology will help you as you proceed through the remainder of this course.</p>
<p>Chart. A chart is the package format used by Helm. It consists of a specific folder structure containing various files, including templates, which, when rendered, make up the resources that you deploy into your cluster. Charts are compressed into a single archive file when packaged, which then are often hosted within a chart repository.</p>
<p>Repository. A chart repository is nothing more than an HTTP web server that hosts and serves an index.yaml file together with one or several packaged charts. Repositories are centralized locations where you store and host your charts, allowing them to be distributed and shared to other interested users. A chart repository is akin to, say, an APT or RPM repository, as used by Linux distros. You are free to use whatever technology suits for the HTTP web server, for example, Apache or NGINX.</p>
<p>Templates. Template files are used within a chart package to make a deployment more general and reusable. By taking a typical Kubernetes manifest file and abstracting it into a template, you can parametrize it, such that at chart installation time you can then pass in specific values that alter the behavior of the deployed resource. This is useful for deployments that need to take place in multiple environments, say dev, test, prod, et cetera. Templating your resources helps to reduce and minimize manifest proliferation.</p>
<p>Releases. When you deploy a chart into a cluster, Helm creates a release for it. A release represents an instance of a chart. The same chart can be used to deploy differently named releases. Releases can be upgraded, rolled back, and even deleted. A release maintains a history of change, with every change being its own revision. Consider now the overall explanation which highlights the relationships between the individual terms just reviewed.</p>
<p>Helm is used to deploy and install charts into a Kubernetes cluster. A chart consists of one or several templates. Charts are hosted within repositories. To locate a Helm chart, one would search within a repository. At install time, templates are then rendered into manifest files, which are then sent to the Kubernetes API server, resulting in a new chart release. Upgrading an existing release results in a new revision of that release being created. Releases maintain version history, et cetera, and can be rolled back or deleted.</p>
<p>Okay, that now completes this lesson in which I provided a quick review of several of the more important and commonly used terms that you’ll often hear when working with Helm. Go ahead and close this lesson, and I’ll see you shortly in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-architecture/">next one</a>.</p>
<h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>Welcome back. In this lesson, I’m going to give you a quick overview of the architecture as used within <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a>. This will be useful to you, as it helps you to understand the different moving parts and how they work collectively together. The good news is that the Helm 3 architecture has been simplified, yet made more secure at the same time. Often, more secure means more complexity. but this is certainly not the case for Helm 3.</p>
<p>Helm 3 uses the following displayed client-only architecture. This architecture, when compared to the previous Helm 2 client server architecture, is both simpler and more secure. Previously, Helm 2 depended on a cluster-hosted component named Tiller. Tiller, configured with a service account in role, needed sufficient permissions to install chart resources into the cluster, potentially across multiple namespaces. The Helm 2 client was designed to communicate through Tiller with Tiller actually performing the duties of resource creation, et cetera.</p>
<p>Now, with Helm 3, this is no longer the case. Instead, the Helm 3 client now communicates directly with the Kubernetes API server. The reason for this change stems mainly from the fact that Kubernetes, as of version 1.16, has RBAC, or role-based access control available and enabled by default. With RBAC, the Helm 3 client can now simply leverage the permissions managed and configured through the standard .kube&#x2F;config file. This is the same file that the kubectl utility uses to authenticate into the cluster.</p>
<p>So, to be clear, when using the Helm 3 client to deploy a chart into a Kubernetes cluster, the Helm 3 client will authenticate to the cluster using the same credentials stored and managed within the .kube&#x2F;config file, the same mechanism that kubectl uses. The permissions required to install the various chart resources will be governed by the RBAC permissions configured within the cluster.</p>
<p>Now, before an actual chart installation takes place within a cluster, the chart first needs to be rendered. In Helm 3, this is done client side. The rendering process involves taking each of the templates stored internally within the chart and converting them or rendering them into raw Kubernetes manifest files which the Kubernetes API server understands and can process.</p>
<p>Deploying a Helm chart results in a release being created. When it comes to release management within the cluster, Helm 3 stores release information using Kubernetes Secrets. Previously, Helm 2 used configmaps. Whenever a chart modification takes place, such as creating, upgrading, and&#x2F;or rollbacks, then this results in a new Kubernetes Secret resource being created within the same Kubernetes namespace in which the actual deployment took place.</p>
<p>Okay, that completes this lesson. In this lesson, I provided you with a brief overview of the underlying Helm 3 architecture and the key differences between Helm 3 and Helm 2. You learnt the Helm 3 uses a simpler architecture and no longer requires the Tiller component. Okay, go ahead and close this lesson, and I’ll see you shortly in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-commands/https://cloudacademy.com/course/introduction-to-helm-1034/helm-installation/">next one</a>.</p>
<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>Welcome back! In this lesson, I’m going to review just how easy and quick it is to get up and running with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a>. Installing Helm 3 is simple, easy, and quick. Helm 3 only requires the client component installed on the developer’s workstation. Helm 3 no longer requires anything to be installed into the cluster itself. Installation can be performed by simply downloading a pre-compiled binary release, and then either moving the binary into your configured path or by symlinking it.</p>
<p>Alternatively, you can install it by using one of the provided dedicated OS installers. Installers exist for MacOS, Windows, and Linux. And that’s it! Helm is now installed and ready to go. When it comes to using Helm on the command line, consider setting up autocompletion. Autocompletion will help you to navigate the various sub commands and parameters. Installing autocompletion can be accomplished by running the following command. Or you can make it more permanent by injecting the previous command into the user’s bash profile.</p>
<p>Okay, that completes this lesson. In this lesson, I showed you how simple it is to install Helm together with autocompletion. Go ahead and close this lesson and I’ll see you shortly in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-commands/">next one</a>.</p>
<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><p>Welcome back. In this lesson, I’m going to provide a quick review of the basic commands that you’ll often use when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a>. Before I drill into the specifics of each available individual command, it’s useful to know that auto completion exists, if enabled, and that help can be consulted by specifying the,-help argument on any command.</p>
<p>The following Helm commands as displayed here are used for basic Helm <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-charts/">chart</a> management, that is, those which are used to find, pull, install, upgrade, rollback, and uninstall a chart. Starting with Helm Search, the search sub command has two further sub commands, hub and repo. Helm search hub is used to evaluate fuzzy-based searching for publicly registered charts, meaning the search keyword can be partial. Running this command with a keyword will result in a list of matching charts.</p>
<p>The search is performed through the centralized online Helm Hub, located at <a target="_blank" rel="noopener" href="https://hub.helm.sh/">https://hub.helm.sh</a>. The helm search repo command also provides a keyword search mechanism, but this time against the registered repositories locally. Running the command helm repo list will display the registered repositories. You can add additional repositories to search against by running the command helm repo add, which I’ll review on the next slide.</p>
<p>The helm pull command is used to pull down a package from a package repository. When running this command, you provide it either with a chart URL or string composed of the repository name, chartname. As the documentation states, this is useful for fetching packages to inspect, modify, or repackage. It can also be used to perform cryptographic verification of a chart without actually installing the chart.</p>
<p>The helm install command is used to perform an installation of a chart. When installing a chart, you specify a name for it, together with the location of the chart itself. The location of the chart can be specified one of five different ways. A typical approach will be to specify the registered repository name, slash name of the chart. For example to install the wordpress chart with the name wordpress located in the locally-registered bitnami repository, use the command helm install wordpress bitnami&#x2F;wordpress.</p>
<p>The helm upgrade command is used to upgrade an existing chart release, and results in a new revision being created for the release once applied. When running this command, you must specify both the release name and the chart. The chart itself may contain updates that potentially changes the behavior of the deployed application. Or equally, the chart may be unchanged and instead new values are being passed in as part of the helm upgrade command, which again results in a new revision and change of behavior.</p>
<p>The helm rollback command is used to rollback a chart release to a specific revision number. The first argument of the rollback command is the name of a release, and the second is a revision, or version number. If the second argument is omitted, it will roll back to the previous release. Note, this command can be used to move the current release back and forward. The revision history for a release can be displayed by running the command helm history together with the release name.</p>
<p>The helm uninstall command takes a release name and uninstalls the release. It removes all of the resources associated with the last release of the chart, as well as the release history, freeing it up for future use. Moving on, the following group of commands are focused on managing and maintaining Helm repositories.</p>
<p>The helm repo add command takes both a name and URL as its arguments. The name is used to reference the repository later on, when using other helm commands such as helm install or helm upgrade. The URL refers to the location of the repository, which can be either public, hosted on the Internet, or private, hosted on an internal network.</p>
<p>The helm repo list command simply lists out the registered helm repository list, including both name and URL for each registered repository. This command can take a –output parameter which alters the format of the outputted list. This parameter can be set to any of the following values, table, JSON, or yaml, with table being the default when this parameter is absent.</p>
<p>The helm repo remove command takes a repository name and then removes that particular repository from the currently configured repository list. The helm repo update command updates the latest information about charts from the respective chart repositories. Chart information is cached locally, where it is then queried on by other helm commands, for example the helm search repo command.</p>
<p>When it comes to hosting your repositories, use the helm repo index command to scan the current file system directory and generate an index file based on all charts found within it. Moving on, the following group of commands are focused on managing and maintaining Helm releases. The helm status command takes a release name and then displays details about that particular release. Information such as the last deployment date, time of release, the namespace the release was made into, the current revision number, status, and any chart provided notes or instructions which may indicate how to access the running application.</p>
<p>The helm list command displays all of the currently deployed helm releases that exist within the current cluster. For each release, the release name, the namespace into which it was deployed, the current revision number, the date time of the last update, the status, the name of the chart, and the app version are given. When examining the history for a given release, use the helm history command together with the name of the release. Use the previous helm list command to get a list of all of the current release names, then take the one of interest and provide it as an argument to the helm history command. This command will then return a list of revisions for this particular release.</p>
<p>The helm get manifest command takes a release name and will display the entire manifest, end-to-end, required to recreate that particular current release. The helm get manifest command takes a release name and will display the entire manifest, end-to-end, required to recreate the current release. The displayed output contains source comments indicating which template contributed to the manifest segment in question.</p>
<p>Moving on to the final set of commands, those related to creating and packaging your own helm charts. Beginning with the helm create command, use this command to scaffold out a chart directory structure populated with common file examples used to demonstrate and guide you when it comes to building your own custom chart. Once you’ve run this command, you will typically open up the root chart folder within your IDE or editor of choice and then begin customizing the chart by editing the templates and&#x2F;or other files within it.</p>
<p>Running the helm template command together with a release name and chart directory will render out all enclosed chart templates locally. This will display the actual cluster resource manifest files that will be submitted to the Kubernetes API service when a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-installation/">helm install</a> command is invoked on the same chart. This command is extremely useful during the chart templating creation process, and allows you to test the helm rendering process locally before installing charts into the cluster.</p>
<p>Next, use the helm package command to package up a specified chart directory. This command packages a chart into a versioned chart tar gzipped archive file, which can then be published into a chart repository.</p>
<p>Finally, the helm lint command takes a path to a chart and then runs a series of tests to verify that the chart is well-formed. The same command without the chart path argument can be called with the root folder of a chart and by doing so will validate the current chart. Any and all encountered errors will be displayed as to the cause and location.</p>
<p>Okay, that completes this lesson. In this lesson, I highlighted the different sets of helm commands that are typically used to manage and maintain charts, releases, and repositories. Understanding which helm commands to use, when and how will help you to become productive with helm. Okay, close this lesson, and I’ll see you shortly in the next one.</p>
<h1 id="Charts"><a href="#Charts" class="headerlink" title="Charts"></a>Charts</h1><p>Welcome back! In this lesson I’m going to take you through the process of creating your own chart, hosting it, and then installing it. Along the way I’ll document the internals and structure of a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> chart, and highlight how a helm chart is really just a collection of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-templates/">templates</a> plus a couple of extra metadata and default config value files which collectively represent an application to be deployed.</p>
<p>Charts can and do range in terms of complexity. Some charts are simply designed to deploy nothing more than a single application or service, whereas others can be much more complex, designed to deploy a full application stack consisting of multiple microservices, web servers, databases, and so on. Ultimately, deploying a chart will result in one or several Kubernetes resources such as pods, deployments, services etcetera being created.</p>
<p>Now, when it comes to building your own chart, you need to understand the required folder and file structure. The helm command line client helpfully provides the “helm create” <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-commands/">command</a> which when invoked scaffolds out this directory structure for you. Let’s take a closer look at that now. A chart, as mentioned earlier is nothing more than a specific directory structure containing a set of specific files.</p>
<p>Consider the following default chart directory structure, which gets generated for you when you invoke the “helm create” command. In the parent directory you have the Chart.yaml and values.yaml files, together with the charts and templates directories. Let’s now begin to review each of these individually. The Chart.yaml file contains top-level metadata which really explains the purpose of the chart. Every chart must have a name which is expressed in the mandatory name field. The optionally required description field indicates the purpose of the chart. The optionally required type field can be set to either ‘application’ or ‘library’.</p>
<p>When set to application, the chart becomes deployable meaning resources will be created within the cluster. A ‘library’ typed chart indicates that the chart contains reusable functions that can be imported and used with application typed charts. The mandatory version field indicates the version of the Chart itself and follows the semantic versioning scheme. The optionally required appVersion on the other hand tracks the version of the application being deployed, and also uses the semantic versioning scheme.</p>
<p>There are several other optional fields that can be specified for various other purposes. Consult the online home documentation to understand their purposes.</p>
<p>The charts folder is used to host other dependent charts for which the current chart depends on. During deployment, charts contained within the charts directory are deployed into the cluster. The values.yaml file contains a structured list of default values, which at template rendering time get injected into the various chart templates which reference them.</p>
<p>Values are declared in yaml format allowing you to specify them in an organized structure. What goes into this file and how it is organized is entirely up to the chart designer. The following values.yaml file specifies a number of default values that will be referenced upon by other templates within the same chart. Templates that wish to reference a default value declared within the values.yaml file can do so by referencing the term “.Values” with a capital V, followed by a dotted notation path to the required value. For example, the service.yaml template is defined like so. Here you can see that the service type references the value stored in the values file at the position of service.type.</p>
<p>It’s important to keep in mind that the values stored in the values.yaml file are defaults. All of these values can be overridden when invoking the “helm install” or “helm upgrade” commands, by specifying the –set argument. For example, you could update an existing release with the following command, which would override the default service port value specified in the values.yaml file, instead replacing it with the value 9090. The templates folder is used to store all template files together.</p>
<p>Typically, a chart is composed of multiple template files, where each template file contains the definition of a single cluster resource. For example, the deployment.yaml template will contain the definition for a deployment resource, whereas the service.yaml template will contain the definition for creating a service resource. Template files are developed according to the Golang template file syntax.</p>
<p>All files that are placed in the templates folder, regardless of filename and extension are subject to the template rendering process. Picking out the service.yaml template as an example we can see the basic templating format and structure. The template syntax again is based on Go templates. Double curly brackets are used to delimit the areas that are evaluated and replaced at template rendering time. A NOTES.txt file can be placed alongside the templates in the templates folder. This file contains end-user instructions as to how the deployed application should be accessed etcetera, once deployed and running within the cluster. The instructions are printed out at the end of invoking the “helm install” or “helm upgrade” commands.</p>
<p>Keep in mind, that the NOTES.text file, as is every other file in the templates directory, still a template file and therefore undergoes the template rendering process. This, allows you to dynamically generate portions of the instructions that are eventually printed out to the console. When you’re building out your own templates, you’ll often come across template partials that are repeated either within the same template and&#x2F;or across different templates.</p>
<p>These template partials can be refactored out and placed within a file whose name begins with an underscore to indicate that this file does not directly result in a Kubernetes manifest file during the rendering process. For example, the underscore helpers.tpl file which gets generated by the “helm create” command contains a number of reusable template partials that are included within the other template files. The following template snippet extracted from the underscore helpers.tpl file is used to dynamically generate the service account name.</p>
<p>Looking at the serviceaccount.yaml template we can see how the previous template partial is then included. The tests folder is used to host one or several tests that you write to exercise and validate the chart once deployed. Tests are implemented typically using a Kubernetes Job or Pod resource. The resource once created within the cluster should be designed to return a zero exit code. This is interpreted by Helm as a successful test with a non-zero exit code representing a test failure.</p>
<p>It’s important to understand that tests within Helm are determined by the Job or Pod resource being annotated with the helm.sh hook annotation and it being set to the value test. Tests can be placed anywhere within the templates folder but for convenience are often grouped together and placed in the tests sub-folder. Tests are launched by running the command “helm test” with the name of a release which is to be tested.</p>
<p>The following example uses a Pod resource to launch a wget command to send an HTTP GET request to the service name. If the service in question replies with an HTTP 200 response code then the Helm test as a whole will succeed. Helm tests can be designed to test many different things. For example, they can be designed to test traffic paths, network connections, credentials and&#x2F;or other application specific tasks.</p>
<p>Having finished the development of your chart the next thing to do is package it. The packaging process is simple and straightforward. Simply, run the “helm package” command. This command simply takes in the path to the chart directory and then archives the chart directory producing a file named according to the chart metadata stored within the Chart.yaml file located in the parent chart directory. For example, if a Chart.yaml contained the following metadata, and the Chart.yaml file was located in a directory named “ca-app”, then executing the command “helm package ca-app” would produce a new archive file named cloudacademyapp-0.1.3.tgz. Anyone with access to the previously created Helm chart archive file, could simply install it by running the following command.</p>
<p>Now, if there were settable values, they could also be passed in by using the set parameter. These install time provided values would override any equivalent values stored in the chart’s values.yaml file. If needed you can perform a dry-run of a chart installation. This will perform a template render over the enclosed chart templates, outputting actual Kubernetes manifests so that you can view exactly what will be installed in the cluster.</p>
<p>To host the newly created chart within a chart repository, you would simply need to create an index chart file, using the following command. And then store both the generated index.yaml file together with the chart archive in a directory that was then served up via a standard web server. The “helm repo index” command will actually perform a recursive directory scan within the provided directory to search for and find all Chart archive files. Any discovered chart archive file will then be written into the resulting index.yaml file which is used at repository search time.</p>
<p>If your chart is hosted and being served, then you could run the following commands to install the chart. If again there are settable values, they can be passed in by using the set parameter, overriding any equivalent values stored in the chart’s values.yaml file. Okay, that completes this lesson. In this lesson, I reviewed the process involved in building your own custom Helm Charts. I reviewed the internal chart directory structure and highlighted what each directory and file was responsible for.</p>
<p>Finally, I documented how to package, host, and install a custom chart. Understanding how to create package, and host your own charts will not only aid you with rolling out your own applications into a Kubernetes cluster but will also allow you to share them within your own organization or the wider online community. Okay, close this lesson, and I’ll see you shortly in the next one.</p>
<h1 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h1><p>Welcome back, in this lesson, I’m going to review <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> template syntax, at least the more common parts that are often used. A <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-charts/">Helm chart</a>, at its core, is composed of one or several templates.</p>
<p>Now, if you’re interested in building your own charts, then, knowing the basics of how to author a template from scratch or converting a standard Kubernetes manifest into a template is a required skill. To help you understand the various basic template syntax features and related templating techniques, I’ll use a sample project, which deploys a pair of Nginx-based web servers into a cluster. A ConfigMap is used to store the Nginx configuration. A cluster IP-based service is deployed to load balanced traffic across the two Nginx web servers.</p>
<p>Again, the focus of this lesson is on the Golang-based template syntax and the various related templating techniques. To help with the explanation of how the templating syntax works, I’ll first show the desired output for each Kubernetes resource, then, followed by the template that when rendered, results in that output.</p>
<p>Okay, let’s begin. For starters, let’s look at the ConfigMap resource. The ConfigMap displayed here is used to store the Nginx web server configuration. This configuration is mounted into the Nginx web server at deployment time. And as you’ll later see, is referenced within the deployment resource used to spin up the two Nginx web server pods.</p>
<p>Now, when it comes to converting this into a template, we’ll refactor it, so that the Cloud Academy DevOps 2020 v1 message is extracted out and placed within the chart’s values.yaml file. Additionally, both the hard-coded release name and release version values will be substituted out in favor of using Heml’s built-in release object.</p>
<p>Let’s now take a look at the resulting config template conversion in the next slide. Observing now, the updated ConfigMap template, we can see there are several templating syntax edits that have been made. Let’s go through each of these now. The ConfigMap’s resource name is now provided dynamically using the webserver.fullname template partial, which is stored externally in a helpers template.</p>
<p>Template directives begin and end with double curly braces. The template engine evaluates the template instructions inside the double curly braces. Everything else that falls outside of the double curly braces is rendered as is, without any transformation involved. The Cloud Academy DevOps 2020 v1 message has now been replaced with a template directive that references the message, which is now being stored and moved into the values.yaml file.</p>
<p>The .Values object used within the template directive refers to the values.yaml file. Therefore, the following dot notation in this case, .nginx.conf.message will inject the value stored at that location within the values.yaml file, into the current position within the template at rendering time. Note this value can also be supplied on the command line using the set argument, whenever the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/demo-installing-helm-with-autocompletion-enabled/">Helm install</a> or Helm upgrade commands are invoked, and when done so, will override the default value stored in the values.yaml file.</p>
<p>The same template injection also happens for both the release name and release revision. However, these values are computed and supplied via the inbuilt release object, provided by Helm. It’s also worth noting that Helm provides several other inbuilt objects, those being release, values, which you’ve just seen, chart, files, capabilities, and template. To understand what each inbuilt object is capable of, consult the online Helm documentation.</p>
<p>Let’s now consider the deployment resource. Our deployment spins up a pair of Nginx web servers. The deployment references and mounts the previous ConfigMap, thereby providing Nginx with its runtime configuration. The deployment references a particular container image for the Nginx web server, that being the nginx.1.13.7 tagged image.</p>
<p>A checksum&#x2F;config based annotation is used to help roll and replace the Nginx web server pods, whenever a Helm update is performed. The checksum is performed over the ConfigMap file with the idea being that if the ConfigMap changes between revisions, then, the deployment should understand this, and roll and replace the existing Nginx web server pods. So that the new Nginx web server pods are launched with the updated ConfigMap.</p>
<p>Okay, let’s now see how this is configured into a corresponding template. The resulting deployment template is a bit more intricate when compared to the ConfigMap template, containing a number of different and new templating features.</p>
<p>Let’s walk through each of these now. Again, various template directives are scattered throughout the template. It’s important to remember to add a single whitespace after the opening double curly brace, in a single whitespace before the closing double curly brace. We can see in various places throughout the template the use of the include template keyword. The include keyword is used to reference a template partial, which has been refactored out and stored in a template partials file. In this case, the _helpers.tpl file.</p>
<p>This templating technique is equivalent to refactoring repeatedly used code into a function or method, which can then be called multiple times elsewhere. The single dot, which comes immediately after the named template partial, and just before the pipe symbol, represents the passed-in scope, in this case, the top level scope. The passed-in scope can be altered by navigating it using dot notation. Template double curly brace syntax can be modified with a dash special character to tell the template engine to chomp whitespace. The dash character can be used at either end, or both, depending on where you want to have whitespace removed.</p>
<p>Remember, that new lines are also considered whitespace. The pipe symbol takes the output of the left-hand side and passes it through the right-hand side template function. You will quite often see this used with the indent and nindent string functions, used to ensure the correct indentation is used in the template rendering. The nindent differs from the indent string function by prepending a starting newline character to the imported string.</p>
<p>The pipe symbol can be used multiple times within one template directive, allowing you to compose complex pipelines, if required. Template directives can make use of various control structures. For example, the if action has been used to check if auto scaling has been enabled or not, and then, render accordingly. The end template directive is used to close off the current control structure.</p>
<p>A checksum is computed on the ConfigMap, and the resulting checksum’s stored as an annotation within the rendered deployment. This is done as previously mentioned, to allow the deployment to roll the pods if the checksum changes between revisions for the same release. For example, when we’re performing a Helm upgrade, the implementation of this checksum uses the print function to compose a file system path to the ConfigMap. The include function then pulls in the content of the ConfigMap and pipes it into the sha256sum function, all of which results in a checksum value.</p>
<p>The dollar sign as used and seen within the checksum line is a global variable, which always points to the root context. The inbuilt template object hangs off the root context, as referenced here. The remaining template syntax within the deployment template is self-explanatory. Moving on to the final service resource, this is used to expose and load-balance internal cluster traffic across the two Nginx web server pods. There is nothing special about this resource, other than the fact that the service is configured as a cluster IP service, indicating that it’s an internal load balancer to the cluster, and that the specified selector must match the labels set on the two Nginx web server pods within the previous deployment.</p>
<p>Let’s now see how this translates into a template. Again, various template directives are scattered throughout the template. We’ve encountered all these types in the previous two templates, so nothing new here. One thing that I would point out is that the selector uses the same template directive as used within the deployment template, ignoring the required indentation. This emphasizes how refactoring out commonly used template areas, helps with increasing reusability, thereby, reducing template clutter. This approach also reduces unintentional errors, in this case, avoiding the potential for mismatching labels.</p>
<p>Now, with all three templates in place, we can both lint and test the template rendering without actually creating resources within our cluster. This is achieved by running the following commands, where webserver is the chart directory containing the templates. If you’re happy with the rendering outputs, you can now perform the actual cluster installation by rerunning the previous command. Okay, that completes this lesson.</p>
<p>In this lesson, I reviewed many of the basic and common templating syntax features. I used a simple Nginx load-balanced deployment to provide template examples of the various templating features. Understanding how to author your own templates is an essential skill and requirement for building your own charts. Okay, close this lesson. I’ll see you shortly in the next one.</p>
<h1 id="DEMO-Installing-Helm-with-Autocompletion-Enabled"><a href="#DEMO-Installing-Helm-with-Autocompletion-Enabled" class="headerlink" title="DEMO: Installing Helm with Autocompletion Enabled"></a>DEMO: Installing Helm with Autocompletion Enabled</h1><p>Welcome back. In this demonstration, I’m going to quickly show you how to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-installation/">install</a> and set up the Helm 3 client. This demonstration will be performed on MacOS, however, similar instructions can be used on other operating systems. Right, let’s begin. For starters, I’ll need to locate and download the latest version of the Helm 3 client binary. To do so, I’ll navigate to the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> website located at helm.sh. I’ll then click on the Get Started link in the top right-hand corner.</p>
<p>I’ll then click on the Installing Helm link found here in the left-hand side menu. I’ll install the client using a binary release, therefore, under the Binary Releases heading, I’ll click on the desired version link. This bounces us over to GitHub and into the Helm Releases page. Now, I want to download the latest 3.x version, therefore, I’ll scroll down until I find the latest version 3 release. Here we can see that the latest 3.x version is 3.2.4. From here, I’ll simply copy the download link for MacOS, and then jump over into my terminal.</p>
<p>Here we can see that I’m in the demo-helm directory. I’ll perform a quick directory listing to confirm that this directory is empty, which it is.</p>
<p>Next, I’ll use the curl command to download the Helm 3 client binary, providing it with the download URL I previously copied. Performing another directory listing, we can see that our downloaded release archive is available.</p>
<p>Let’s now uncompress it by running the command tar -xvf and the name of the archive. I’ll use the tree command to display the resulting directory structure, and here we can see our helm 3.2.4 client binary.</p>
<p>Finally, I’ll copy this into a directory that is configured on my systems PATH. In this case, I’ll copy it into the &#x2F;usr&#x2F;local&#x2F;bin&#x2F;directory. I’ll need to use sudo to elevate the permissions since this directory is protected.</p>
<p>Okay, if I now run the command, which helm, we can see that the helm executable has been found in the directory I stored it in, and that we are now ready to use it.</p>
<p>Next, I’ll invoke the command from the current directory and query its version information, and indeed we can see that it is the expected 3.2.4 release, a perfect result.</p>
<p>Now, before I finish, let’s set up auto-completion for the helm executable. This will make life far easier when it comes to learning and using the helm client. To do so, I’ll run the following command, to persist the helm auto completion to my systems bash profile. This will ensure that anytime I restart or relaunch a terminal, the helm completion command is automatically rerun, thereby always enabling auto completion for the helm command.</p>
<p>If I now cat out the contents of my systems bash profile, I should see a new entry for helm completion at the bottom which I can confirm, perfect. Finally, if I now reload my updated bash profile within the current terminal shell using the source command, I should have helm auto completion available. </p>
<p>Let’s try it out now. Clearing the current terminal first, I’ll now type in helm and then perform a double tab key press to call up the auto completion, and perfect, here we can see all of the helm sub commands, confirming that auto completion is indeed enabled and working.</p>
<p>Okay, that completes this demonstration. We now have our local Helm 3 client installed with auto completion enabled. When it comes to working with Helm 3, this is the only installable requirement. There are no installable actions required within the cluster, it’s just super easy and fast to get up and running with Helm 3.</p>
<h1 id="DEMO-Installing-Bitnami-WordPress-Helm-Chart"><a href="#DEMO-Installing-Bitnami-WordPress-Helm-Chart" class="headerlink" title="DEMO: Installing Bitnami WordPress Helm Chart"></a>DEMO: Installing Bitnami WordPress Helm Chart</h1><p>Welcome back. In this demonstration, I’m going to quickly show you how to find and install a WordPress Helm chart, using the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> 3 client that we <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/demo-installing-helm-with-autocompletion-enabled/">previously installed</a>. For this demonstration, I’m going to use Minikube, which has already been installed locally, to create and run a local Kubernetes cluster on my MacOS laptop.</p>
<p>Okay, let’s proceed! For starters, I’m going to use the <code>minikube</code> command to examine the status of an existing Kubernetes cluster that I’ve previously provisioned on this workstation. I’ll run the <code>minikube status</code> command, and here we can see that it’s in a stopped state.</p>
<p>Let’s start up this cluster by running the command <code>minikube start</code>. Here we can see that minikube is now awakening the cluster for us. This is a fairly quick process, and it’s just completed. So our Kubernetes cluster is now active.</p>
<p>Next, I’ll use the <code>helm list</code> command to list out any Helm releases I may have previously deployed into this cluster. In this case, you can see that it has returned empty, indicating that the cluster doesn’t have any existing Helm releases within it.</p>
<p>Let’s now use the <code>helm search</code> command. Double-tapping the tab key shows that we have two search sub commands, <code>hub</code> and <code>repo</code>. I’ll use the <code>hub</code> sub command, since I want to search the online Helm hub for a WordPress chart. Therefore, the full command that I’ll execute is <code>helm search hub wordpress</code>. Here we can see the following search results. We can expand the truncated URLs by running the command Helm search hub WordPress - o, for output, and yaml, for the format.</p>
<p>I’m now going to proceed by installing the WordPress chart provided from the Bitnami repo. To do so, I’ll first need to discover the Bitnami repo URL. I’ll copy this URL, and then navigate to it within my browser. Here, we can see detailed instructions as to how the Bitnami Helm repo can be added locally, and then how to install the actual Bitnami Helm chart.</p>
<p>Let’s copy this Helm command and execute it back within our terminal. Okay, that has successfully added the Bitnami repo to my local Helm repo list. If I perform a Helm repo list, I can see all of the configured repos I currently have locally. Let’s now run the command Helm repo update to update my local repo cache.</p>
<p>Okay, we are now all up-to-date. This time, if I run Helm search repo WordPress, I’m searching for a WordPress chart within my local Helm repo cache. Here I can see one result, that being the Bitnami provided WordPress chart. Let’s proceed by now installing the Bitnami WordPress chart. To do so, I’ll simply run the command <code>helm install wordpress</code>.</p>
<p>I’ll set the WordPress username to admin, and likewise the WordPress password to be password. I’ll set the MariaDB database password to secretpassword. And then finally, I’ll provide the chart name. Here we can see that this has completed successfully, and fairly quickly too. We can see some summary information outputted at the top, indicating the Helm chart release name, WordPress, the namespace that it was deployed into, default, the release revision number, one. And, additionally, we have detailed instructions as to how to navigate to the WordPress application.</p>
<p>Before we attempt to access WordPress, let’s take a quick look at both Helm’s view of the world and the cluster’s updated state. Running the command <code>helm list</code> allows us to view all of the Helm releases we have currently performed. As you can see, we’ve just the one, which represents the WordPress release we just performed.</p>
<p>Next, let’s use the kubectl get all command to display all of the cluster resources that now exist in the current namespace. Here we can see each of the WordPress chart installed cluster resources and their current states, and everything looks good. I’ll now use the <code>helm status</code> command with the WordPress release name to regenerate the instructions, which tell us how to access the WordPress frontend.</p>
<p>These instructions work in proper clusters, but since I’m running this cluster in minikube, I can use the minikube provided command <code>minikube service wordpress</code> instead to output the WordPress frontend URLs. Here, we can see minikube maps two URLs, one against WordPress’s HTTP port 80, and another against WordPress’s HTTPS port 443. I’ll copy the port 80 mapped URL. Finally, using my browser, I’ll browse to this URL and pull up the WordPress frontend like so.</p>
<p>Perfect, we are served up with the public frontend view of WordPress. Let’s now try logging into the backend WordPress administration area by navigating to the path wp-admin and using the credentials that we set during the WordPress chart install earlier, those being admin and password. Excellent. We’re in. Once we have finished with a particular Helm release, we can remove it.</p>
<p>To do so, I’ll simply run the <code>helm uninstall wordpress</code> command. We can also check the cluster by executing the command <code>kubectl get all</code> to display resources within the current namespace, of which we see none as expected. Okay, that concludes this demonstration in which I showed you how to search for, find, set up a repo, and then install Bitnami’s publicly available WordPress chart.</p>
<h1 id="DEMO-Creating-a-Custom-Helm-Chart-Load-Balanced-2x-Nginx-Web-Server-Setup"><a href="#DEMO-Creating-a-Custom-Helm-Chart-Load-Balanced-2x-Nginx-Web-Server-Setup" class="headerlink" title="DEMO: Creating a Custom Helm Chart (Load Balanced 2x Nginx Web Server Setup)"></a>DEMO: Creating a Custom Helm Chart (Load Balanced 2x Nginx Web Server Setup)</h1><p>Welcome back. In this demonstration, I’m going to quickly show you how to create your own <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-charts/">Helm chart</a>. In this example, I’m simply going to create an Nginx web server deployment consisting of two replicas that sit behind a service which will provide load balancing. I’ll also establish a ConfigMap to store the Nginx configuration which will be injected into the Nginx web server pods when they get launched. Okay, let’s begin.</p>
<p>For starters, I’ll run the command <code>rm -fr *</code> to clear out the current demo-helm directory, just to keep things nice and tidy. Next, I’ll run the command <code>helm create cloudacademy-webapp</code> to generate a basic chart directory structure for us. This takes care of all of the tedious chart folder and file structure setup.</p>
<p>If I now run the tree command, we can observe the generated sample chart directory structure. Again to keep things simple, I’ll drop all of the files within the templates directory by running the following command <code>rm -rf cloudacademy-webapp/templates/*</code>. Running the tree command again, we can see that the templates directory is now empty.</p>
<p>Next, I’ll navigate into the cloudacademy-webapp directory, and then launch Visual Studio Code from within it by running the command. Now to follow along, consider git cloning the sample code located within the Cloud Academy GitHub Helm repository.</p>
<p>Next within the templates directory, I’ll create a new configmap.yaml template and then populate it with the following ConfigMap resource template configuration. This ConfigMap represents the Nginx configuration that will be mounted into the Nginx web server containers when they are launched within the cluster. On line four, the webserver.fullname template partial is referenced, this will be used to generate the name for this resource. This template partial, along with a few others, will be set up later on.</p>
<p>On lines 13, 18, and 23, we have other template directives, those within the double curly brackets. During template rendering, line 13 injects a simple string message that we’ll store within the chart’s values.yaml file. Let’s set this up now. Clicking on the values.yaml file, I’ll simply overwrite the default content with the following content.</p>
<p>Notice at the bottom, we have the Nginx conf message value set to Cloud Academy DevOps 2020 V one, this is the string that gets injected into the ConfigMap template at template rendering time. Before I move on, also note that on lines 18 and 23, Helm’s in-built release object is referenced for both the name and revision values of the current chart release, determined and computed at install time.</p>
<p>Next, I’ll create the deployment.yaml template and populate it with the following template code. Without going into too much detail, the deployment.yaml template simply spins up two Nginx web server pods, mounting each of them with the ConfigMap previously created. This supplies them with their Nginx configuration, used and required by the Nginx web service. The ConfigMap configuration is set up as a volume on lines 33 to 36, and then mounted within the Nginx container on line 27. The only other interesting piece of configuration is the use of the checksum config annotation on line 17. This is used to calculate a checksum over the ConfigMap file. If the deployment detects a change, as indicated by differing checksums, then the deployment will know to bounce and replace any existing Nginx pods with newer versions of themselves, which as they launch, will then pull in the newer and updated ConfigMap.</p>
<p>Okay, the final template we need to create is the service.yaml template. This will be used to expose and load balance cluster traffic across the two Nginx web server pods. I’ll populate this template with the following template code. The only real point of interest with this template, is the fact that this service will be configured as a ClusterIP based service, as per the setting established on line eight, which references the service.type value stored in the values.yaml file, as seen here.</p>
<p>Finally, I’ll add back in a _helpers.tpl file which contains several reusable template partials which are referenced and used within the other templates. Template partials are similar to functions or methods as found within other languages. They are reusable template blocks that can be called upon from other templates.</p>
<p>Okay, now that we have our chart templates configured and saved, lets now validate it for syntax correctness, et cetera. Here, I’ll run the command <code>helm lint</code> over the current chart directory. Perfect, linting has succeeded, reporting no errors, and with one recommendation provided. We’ll ignore this recommendation for now as it will not affect deployment.</p>
<p>Next, let’s invoke the template rendering process over our templates to see what the rendered templates look like. Within the generated output, we can now see each of the manifests which are actually used to create the respective Kubernetes resources at deployment time. Note that each resource has a source comment at the top indicating which template file was responsible for its generation.</p>
<p>Okay, moving on. Let’s now package our chart. To do so, I’ll step back out of the current cloud academy dash web app directory. And then run the command <code>helm package cloudacademy-webapp</code>. As we can see, the chart packaging has now completed successfully. If I list out the contents of the current directory, you can see the chart archive file. In this case, it’s named cloud academy dash web app dash 0.1.0.tgz. Finally, let’s try installing it.</p>
<p>To do so, I’ll first ensure that the cluster namespace that I’m operating in is the cloud academy namespace. Therefore, I’ll run the following kubectl command. Okay, I’m now ready to perform the chart install. I’ll do so by running the following command, which installs the chart into the current namespace, giving it the release name CA dash demo one. Perfect, our custom <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-charts/">Helm</a> chart has been installed successfully.</p>
<p>Let’s take a look at the resources that were launched within the cluster and within the cloud academy namespace. I’ll run the command <code>kubectl get all</code>. Here, we can see the cluster resources created by our Helm chart installation. Let’s now perform a quick test by firing an HTTP GET request to the services internal cluster IP. To do so, I’ll run the following command which will spin up a temporary pod and use the <code>wget</code> command within it to handcraft an HTTP GET request.</p>
<p>Okay, we have a successful result. As observed by the returned Cloud Academy DevOps 2020 V one message. This is a great result showing that the end-to-end Helm chart development, packaging, and installation has worked. Now, let’s do one final thing here. Let’s perform a Helm upgrade on our CA dash demo one chart release. When I do so, I’ll explicitly set the nginx.conf.message to have a different message, this time setting it to be “Helm rocks!!”</p>
<p>Okay, that has worked. As we can see, a new revision, revision two has been created for the CA dash demo one chart release. Sending a new HTTP GET request to the same service, I should now get back the updated message in its response. And indeed I do. What this implies is that the Helm upgrade resulted in two Nginx pods being bounced, i.e. terminated and replaced with newer pods. We can confirm this by looking at first the pods view within the cloud academy namespace. And then also checking the rollout history for the deployment.</p>
<p>We can also use the <code>helm history</code> command together with the chart’s release name to view the release history. Okay, that concludes this demonstration in which I showed you how to create, package, and deploy, and upgrade a custom Helm chart. Knowing how to perform these basic chart building tasks will help you to start creating your own Helm charts.</p>
<h1 id="DEMO-Creating-a-Custom-Helm-Repository-Using-GitHub-Pages"><a href="#DEMO-Creating-a-Custom-Helm-Repository-Using-GitHub-Pages" class="headerlink" title="DEMO: Creating a Custom Helm Repository Using GitHub Pages"></a>DEMO: Creating a Custom Helm Repository Using GitHub Pages</h1><p>Welcome back. In this demonstration, I’m going to walk you through the process of hosting your own charts within your own chart repository. For this demonstration, I’ll reuse the demo chart created in the previous demonstration. For chart repository web serving, I’m actually going to use GitHub’s ability to act as a static serving web server. GitHub provides this capability through its Pages feature.</p>
<p>Okay, let’s begin. So, the first thing we need to do is configure a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> chart repository index.yaml file, a requirement for a Helm repository. Doing so is easy, simply run the command <code>helm repo index</code>, and here we’ll go at the current directory. Now, if I perform a directory listing in the current directory, you’ll see the presence of the new index.yaml file, which was just created. Catting out its contents, we can see that it has found our custom cloudacademy-webapp chart, and has captured and stored related metadata.</p>
<p>When you run the <code>helm repo index</code> command with a directory path, it will actually perform a recursive directory scan for all charts. Okay, now that we have our index file, let’s jump over into GitHub and create a new GitHub repository, which we’ll then enable the pages feature on, and then upload our Helm chart repo assets, those being the index.yaml, and the cloudacademy-webapp chart file.</p>
<p>Within GitHub, I’ll create a new repo and give it the name helm-repo, and make it public. I’ll copy and paste the commands here into the current demo-helm directory back within my terminal, configuring this directory for source control within GitHub. Next, I’ll run the following command to create a new branch named gh-pages. I’ll then stage both the index.yaml and chart files like so.</p>
<p>Next, I’ll commit and push the gh-pages branch up into GitHub. Jumping back into the GitHub helm-repo, I’ll refresh the home page. I’ll now check that the new gh-pages branch was successfully pushed up into GitHub, and this is confirmed here. Next, I need to set up GitHub pages for the current repo. To do so, I’ll click on Settings, and then scroll down to the GitHub Pages section, located here.</p>
<p>Within this section, you can specify the branch that is to be used and served as static content by GitHub. GitHub has automatically selected the gh-pages branch for us, so we are good to go. Copy this URL located here. This is the base URL which when called will return content directly, as if it were served by a static web HTTP server. To confirm this, I’ll take a copy and jump back into my terminal, and use the <code>curl</code> command to test access to the hosted index.yaml file. And excellent. We indeed get an HTTP 200 response code together with the index.yaml content. From here it’s just a simple case of updating our local helm repo cache by adding the GitHub pages URL.</p>
<p>To do so, I’ll run the command <code>helm repo add cloudacademy-gh-repo</code>, and then providing it with the GitHub pages base URL. Okay, that looks great.</p>
<p>Now I’ll run the command <code>helm repo update</code> to update my local helm repo cache. I can now search within the local helm repo by running the command helm search repo cloudacademy. Here we can see a single result which is the custom chart we earlier built, and now host within our GitHub repo, and for which we hosted within our CloudAcademy GitHub-based chart repository. Let’s now install it.</p>
<p>To do so, I’ll run the command <code>helm install ca-demo2</code>. Okay, that looks good. We can now call up the clusters services view, and then use the new service’s assigned IP address to again send a test HTTP GET request. Let’s do so now. And as expected we get the correct response. Okay, that concludes this demonstration in which I showed you how to create and host your own Helm repository.</p>
<p>In this demonstration, we leveraged GitHub Pages to provide us with a static web server. You can, however, use any other web server capable of serving HTTP static content.</p>
<h1 id="Course-Review"><a href="#Course-Review" class="headerlink" title="Course Review"></a>Course Review</h1><p>Welcome back! Now, before we finish let’s do a quick review of what you have learned and what you’ve observed within the demonstrations. You learned about what <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/course-introduction/">Helm</a> is and how to install it. You learned about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-charts/">Helm Charts</a>, <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-helm-1034/helm-templates/">Templates</a>, Releases, Revisions, and Repositories. You learned how to deploy, upgrade, and rollback Helm Charts. And finally, you’ve learned how to create and host your own Helm Charts.</p>
<p>Now before we conclude, I’d like to thank you for the time and effort you’ve invested into taking this course. Please feel free to contact us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>. If you have any remaining questions, and or comments. And once again, thank you and good luck with your Helm adventures ahead.</p>
<h1 id="1Course-Introduction"><a href="#1Course-Introduction" class="headerlink" title="1Course Introduction"></a>1<strong>Course Introduction</strong></h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/cloud-academy-introduction-to-kubernetes-92/">Introduction to Kubernetes learning path</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Deploy-a-Stateful-Application-in-a-Kubernetes-Cluster-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Deploy-a-Stateful-Application-in-a-Kubernetes-Cluster-19/" class="post-title-link" itemprop="url">CKAD-Deploy-a-Stateful-Application-in-a-Kubernetes-Cluster-19</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:50" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:50-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:28:48" itemprop="dateModified" datetime="2022-11-21T00:28:48-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Deploy-a-Stateful-Application-in-a-Kubernetes-Cluster-19/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Deploy-a-Stateful-Application-in-a-Kubernetes-Cluster-19/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Control-Kubernetes-Network-Traffic-With-Network-Policies-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Control-Kubernetes-Network-Traffic-With-Network-Policies-18/" class="post-title-link" itemprop="url">CKAD-Control-Kubernetes-Network-Traffic-With-Network-Policies-18</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:49" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:49-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:28:02" itemprop="dateModified" datetime="2022-11-21T00:28:02-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Control-Kubernetes-Network-Traffic-With-Network-Policies-18/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Control-Kubernetes-Network-Traffic-With-Network-Policies-18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Utilizing-Ephemeral-Volume-Types-in-Kubernetes-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Utilizing-Ephemeral-Volume-Types-in-Kubernetes-17/" class="post-title-link" itemprop="url">CKAD-Utilizing-Ephemeral-Volume-Types-in-Kubernetes-17</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:47" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:47-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:29:54" itemprop="dateModified" datetime="2022-11-21T00:29:54-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Utilizing-Ephemeral-Volume-Types-in-Kubernetes-17/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Utilizing-Ephemeral-Volume-Types-in-Kubernetes-17/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Mastering-Kubernetes-Pod-Configuration-Service-Accounts-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/CKAD-Mastering-Kubernetes-Pod-Configuration-Service-Accounts-16/" class="post-title-link" itemprop="url">CKAD-Mastering-Kubernetes-Pod-Configuration-Service-Accounts-16</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:46" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:46-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:28:26" itemprop="dateModified" datetime="2022-11-21T00:28:26-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Mastering-Kubernetes-Pod-Configuration-Service-Accounts-16/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Mastering-Kubernetes-Pod-Configuration-Service-Accounts-16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/28/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/274/">274</a><a class="extend next" rel="next" href="/page/30/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
