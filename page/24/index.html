<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hang&#39;s Blog">
<meta property="og:url" content="https://example.com/page/24/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Creating-Variables-in-Terraform-Configurations-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Creating-Variables-in-Terraform-Configurations-8/" class="post-title-link" itemprop="url">Terraform-Associate-Creating-Variables-in-Terraform-Configurations-8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:51" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:51-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:35:08" itemprop="dateModified" datetime="2022-11-20T21:35:08-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Creating-Variables-in-Terraform-Configurations-8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Creating-Variables-in-Terraform-Configurations-8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Creating-Terraform-Configurations-with-Implicit-Dependencies-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Creating-Terraform-Configurations-with-Implicit-Dependencies-7/" class="post-title-link" itemprop="url">Terraform-Associate-Creating-Terraform-Configurations-with-Implicit-Dependencies-7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:50" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:50-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:33:32" itemprop="dateModified" datetime="2022-11-20T21:33:32-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Creating-Terraform-Configurations-with-Implicit-Dependencies-7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Creating-Terraform-Configurations-with-Implicit-Dependencies-7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Installing-Terraform-on-Windows-and-Linux-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Installing-Terraform-on-Windows-and-Linux-6/" class="post-title-link" itemprop="url">Terraform-Associate-Installing-Terraform-on-Windows-and-Linux-6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:48" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:48-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:35:28" itemprop="dateModified" datetime="2022-11-20T21:35:28-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Installing-Terraform-on-Windows-and-Linux-6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Installing-Terraform-on-Windows-and-Linux-6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Deploying-Infrastructure-with-Terraform-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Deploying-Infrastructure-with-Terraform-5/" class="post-title-link" itemprop="url">Terraform-Associate-Deploying-Infrastructure-with-Terraform-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:47" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:47-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:35:38" itemprop="dateModified" datetime="2022-11-20T21:35:38-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Deploying-Infrastructure-with-Terraform-5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Deploying-Infrastructure-with-Terraform-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Deploy-a-Highly-Available-Website-with-Terraform-on-AWS-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Deploy-a-Highly-Available-Website-with-Terraform-on-AWS-4/" class="post-title-link" itemprop="url">Terraform-Associate-Deploy-a-Highly-Available-Website-with-Terraform-on-AWS-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:45" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:45-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:34:14" itemprop="dateModified" datetime="2022-11-20T21:34:14-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Deploy-a-Highly-Available-Website-with-Terraform-on-AWS-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Deploy-a-Highly-Available-Website-with-Terraform-on-AWS-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Manage-AWS-Resources-with-Terraform-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Manage-AWS-Resources-with-Terraform-3/" class="post-title-link" itemprop="url">Terraform-Associate-Manage-AWS-Resources-with-Terraform-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:44" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:44-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:35:56" itemprop="dateModified" datetime="2022-11-20T21:35:56-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Manage-AWS-Resources-with-Terraform-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Manage-AWS-Resources-with-Terraform-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Creating-AWS-Resources-with-Terraform-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Creating-AWS-Resources-with-Terraform-2/" class="post-title-link" itemprop="url">Terraform-Associate-Creating-AWS-Resources-with-Terraform-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:42" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:42-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:35:48" itemprop="dateModified" datetime="2022-11-20T21:35:48-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Creating-AWS-Resources-with-Terraform-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Creating-AWS-Resources-with-Terraform-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Terraform-Associate-Terraform-v1-Provisioning-AWS-Infrastructure-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Terraform-Associate-Terraform-v1-Provisioning-AWS-Infrastructure-1/" class="post-title-link" itemprop="url">Terraform-Associate-Terraform-v1---Provisioning-AWS-Infrastructure-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:48:41" itemprop="dateCreated datePublished" datetime="2022-11-19T00:48:41-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:32:58" itemprop="dateModified" datetime="2022-11-20T21:32:58-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Terraform-Associate/" itemprop="url" rel="index"><span itemprop="name">Terraform-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Terraform-Associate-Terraform-v1-Provisioning-AWS-Infrastructure-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Terraform-Associate-Terraform-v1-Provisioning-AWS-Infrastructure-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Hello, and welcome to the Terraform Provisioning AWS Infrastructure course presented to you by Cloud Academy. In this lesson, I’ll cover off the course agenda, intended audience, learning objectives, and course prerequisites. I’m really excited to be taking you through this course.</p>
<p>Terraform has taken the infrastructure in DevOps community by storm. In this cloud-first era, Terraform has revolutionized the way we perform infrastructure provisioning. By way of a quick introduction, I’m Jeremy Cook, a Content Lead Architect here at Cloud Academy. My background is in Software Engineering and DevOps, and in more recent times, Kubernetes and containers.</p>
<p>So, who should be taking this course? Well, this course is suitable for anyone who has an interest in learning Terraform. Taking this course, you’ll learn how Terraform can be used to launch and provision AWS infrastructure. This course will take you through the Terraform fundamentals, making sure that you understand the basics.</p>
<p>During the course, you’ll also get to observe several hands-on demonstrations, where I’ll show you exactly how to codify your AWS infrastructure. I’ll also demonstrate a complete into in deployment of a cloud native application into AWS using Terraform.</p>
<p>The learning objectives for this Terraform course are: learn about Terraform and how it can be used to provision AWS infrastructure, learn how to build and create Terraform configurations and modules, and learn how to use the Terraform CLI to launch and manage infrastructure on AWS.</p>
<p>The prerequisites, which I consider are useful for this course, are: knowledge of the AWS Cloud Platform and its various services, particularly the VPC, EC2 and IRON services, basic system administration experience, basic infrastructure and networking knowledge, and basic SysOps and&#x2F;or DevOps knowledge.</p>
<p>In terms of feedback, any and all feedback that you may have is welcomed. If you have any unanswered questions about this course or would like to see and hear of other related Terraform features, then please reach out.</p>
<h1 id="Terraform-Introduction"><a href="#Terraform-Introduction" class="headerlink" title="Terraform Introduction"></a>Terraform Introduction</h1><p>Welcome back. In this lesson, I’ll provide a high-level overview of Terraform, highlighting some of the more important features that you’ll benefit from once adopted. After this lesson, you’ll be able to answer questions like: What is Terraform? Why would you use it? And a simplified version of how does it work? Let’s begin.</p>
<p>To begin with, Terraform is an open source infrastructure as code tool originally started by HashiCorp and contributed to by the open source community. HashiCorp is a company that specializes in producing tools and applications for DevOps, security and cloud computing infrastructure management. Terraform itself is a cloud agnostic infrastructure provisioning tool that helps to ease the burden of infrastructure builds and maintenance. Beyond the open source version of Terraform, which is installed locally, Terraform is also available in a cloud and enterprise edition.</p>
<p>Terraform Cloud is Hashicorp’s managed service offering and Terraform Enterprise is similar to Terraform Cloud, but is focused on being a self-hosted solution addressing the needs of data localization and operational security policies. Again, the intention of this course is to focus on the open source version of Terraform using it to provision AWS infrastructure. Having said that, it is worthwhile acknowledging that Terraform can be used to provision multi-cloud deployments.</p>
<p>The infrastructure Terraform managers can be hosted on public clouds such as Amazon Web Services, Azure and Google Cloud platform. It can even be used for on-prem or private clouds such as OpenStack, VMware vSphere or CloudStack. Terraform Infrastructure integrations also allow you to manage software and services including databases like MySQL, source control systems like GitHub, configuration management tools like Chef and Puppet and much more.</p>
<p>Currently, there are well over 100 publicly available infrastructure integrations. Before we dive deeper into Terraform itself, I’d like to step back and quickly review the concept of infrastructure as code, why it is important and why it has become so popular in recent times. Infrastructure as code allows us to codify our infrastructure requirements into machine readable definition files. In doing so, we are effectively creating executable documentation.</p>
<p>Anyone new to a project can examine the projects infrastructure as code templates and immediately understand the infrastructure configuration, et cetera. By using code to generate infrastructure, the same environment can not only be recreated multiple times, it can be done so consistently without era or unintentional divergence. Additionally, infrastructure as code can address environmental drift, situations where the initial infrastructure is drifted away from the initial day zero configuration.</p>
<p>Over time, the day one, day two et cetera, infrastructure, may encounter unintentional or intentional, but unapproved changed. By comparing the current site of an infrastructure and baselining it back against your existing infrastructure as code templates, you can deduce any drift and receipt it back to the recorded baseline. With infrastructure as code, your templates can be stored in a vision control system such as Git allowing teams to collaborate on infrastructure. Team members can get specific visions of code and create their own development or test environments. In the past, a pain point that often existed for developers before moving to cloud infrastructure, were the delays encountered with operations, having to budget, plan, create and deliver physical infrastructure.</p>
<p>Now with the elasticity of the cloud allowing resources to be created on demand, developers can instead provision the infrastructure they need when they need it. All combined, these benefits make infrastructure as code not only useful, but a must-have tool, particularly so being a SysOps and DevOps enabler.</p>
<p>So now that we know what infrastructure as code is, let’s return to Terraform itself and begin to understand how it can be used to codify our infrastructure requirements. Terraform, the open source version is packaged into a single executable file lightweight and easy to install regardless of operating system. Once installed, you access its features via the terminal.</p>
<p>A typical infrastructure provisioning workflow involving Terraform goes like this. Iteratively, codify your infrastructure requirements into one or several Terraform configurations. Within your local terminal, use the Terraform tool to first validate and plan the infrastructure an then later apply it. Later on in the project lifecycle, you can always use the Terraform destroy command to destroy your infrastructure if and when required.</p>
<p>Now, I’ll go a lot deeper into each of these steps in the coming slides. As an infrastructure engineer, you write or modify Terraform template files for your infrastructure. These configuration files declare the desired state of your infrastructure. Later on, you can modify existing configuration files to declare how you want to change your existing infrastructure.</p>
<p>To keep you productive and from having to code every requirement from the ground up, Terraform provides for your convenience, a public module registry, from which you can import and leverage any number of modules. A module encapsulates related resources together, which when combined, are use to achieve a particular requirement. During the demonstrations that I provide later on, I’ll demonstrate how to both build your own modules and how to work with the modules available within the public Terraform module registry.</p>
<p>When it comes to provisioning time, Terraform integrates with different cloud providers and or other infrastructure vendors through the use of providers. A provider encapsulates all of the mechanics to connect, authenticate and communicate with the infrastructure provider. This is one of the true benefits of using Terraform, that is, the potential for it to provision multi-cloud infrastructure.</p>
<p>Once you’re happy with your declared configuration, you can ask Terraform to generate an execution plan for it. The execution plan tells you what changes Terraform would need to make to bring your current infrastructure to the declared state in your configuration.</p>
<p>Now, if you were to accept the plan, you can then instruct Terraform to apply the changes. To do so, you proceed by using the apply command. The apply command can use the plan that you previously generated, or, if you don’t provide a plan, apply can generate one for you and ask for you to accept the plan before applying the changes. Terraform will then orchestrate the infrastructure API calls required to implement the infrastructure changes.</p>
<p>The Terraform Root Module is the entry point for all Terraform configuration. By convention, the Root Module gets populated with the following three Terraform conflict files that you produce, main.tf, variables.tf, and outputs.tf. However, as the complexity of your infrastructure requirements grow, you may refactor this initial arrangement in a number of ways. As already mentioned, it is only conventional to have the three previously named files. The actual Terraform configuration spread across these three files could in fact, actually be collapsed and contained within a single file named anything you like, as long as it has the extension .tf.</p>
<p>Going in the opposite direction, the Terraform configuration within the Root Module could also be refactored by storing parts of it across and within additional subdirectories. Such subdirectories within the Root Module become nested modules.</p>
<p>Finally, depending on how you have configured your Terraform state setup, Terraform state files may also co-exists in the Root Module. This however, is not the case when remote Terraform state has been configured, more on this later.</p>
<p>Another important concept to consider when setting up your initial Terraform environment is the concept of a Workspace. Terraform uses the concept of Workspaces to manage and separate multiple but different infrastructure environments using the same state of Terraform configuration files. This is particularly useful when you want to provision and mirror infrastructure for dev, test or prod environments. With Workspaces, we can establish a Workspace peer environment and then provision infrastructure specifically for that environment using the same Terraform configuration files. And I technical level, Workspaces isolate and manage multiple versions of Terraform state.</p>
<p>Workspaces are managed using the Workspace command. You can create additional Workspaces with its new subcommand and switch between Workspaces using the select subcommand. If you select a new Workspace, there is no state until you apply the configuration. Any resources created in other Workspaces still exist. As and when required, you can simply swap between Workspaces to manage resources assigned and provisioned within that Workspace.</p>
<p>I’ll now do a basic review of the three core files that are typically added to the Root Module, starting with the main.tf your file. The main.tf contains your core Terraform configuration, mostly resources that you had declaring, which when working with the AWS provider, at provisioning time, will get converted into actual AWS Cloud hosted infrastructure resources, such as EC2 Instances. Over time, larger and more complex infrastructure setups might require you to go back and refactor and split up the contents of the main.tf file across multiple.tf files.</p>
<p>Next up is the variables.tf file. This is another file that again, will often be edited into the Root Module. The variables file contains all possible variables that are then referenced and used within the main.tf and or other.tf files within the Root Module. When performing a Terraform plan or Terraform apply, the values assigned to each variable will be injected into any place the referenced variable name is used. Variables can be both typed and have default values as seen here, although, this is not mandatory.</p>
<p>As you’ll see later on, there are multiple ways in which the defaults can be overwritten. Rounding out the last of the three conventional default files which are added to the Root Module to compose a simple Terraform configuration is the Outputs file. The Outputs file is where you configure any messages or data that you want to render out to the end user within the terminal at the end of an execution of the Terraform apply command.</p>
<p>Additionally, when using end and beading modules in a parent Terraform template, module outputs can be referenced within the parent Terraform template by using the module.<MODULE name>.OUTPUT NAME&gt; notation. This will be demonstrated later on within the demonstrations. Terraform State.</MODULE></p>
<p>As earlier mentioned, Terraform is a stateful application. It has been purposely designed to keep track of all infrastructure provisioned through it. All state tracked is stored inside of a Terraform State file. Having performed a Terraform apply, Terraform will capture and record the infrastructure state in two files, terraform.tfstate and terraform.tfstate.backup located in your working directory when working with local state.</p>
<p>The state is written in JSON format, meaning you can parse these files if required. These files represent Terraform’s source of record, recording the last known state. The great thing about having Terraform track and maintain the last name at state of your infrastructure is that it enables you to detect any drift or divergence. If you’d like to check and see if the state files still matches what you last built, you can use the Terraform refresh command. Running this command will alert you to any detected change.</p>
<p>Terraform by default will store state on the local file system. However, you can update this configuration to store the state remotely, perhaps within a dedicated AWS S3 buckets. When using the local file system for state, this can become problematic when working in teams since the state file is a frequent source of merge conflicts. When this occurs, consider using remote state instead.</p>
<p>Using remote state is also considered more secure since the data can be encrypted at risk, and Terraform only ever stores remote state and memory, never on disk. Requests formal state are also encrypted during transit using transport layer security or TLS. Security is important because configurations can store secrets and sensitive information. You can also access remote state using data sources. This allows different projects to access a project state in a read only version.</p>
<p>Now, regardless of what you have at backend, you end up using four configuring Terraform state. If it supports locking, Terraform will lock the state while an operation that could potentially write state changes is happening, this has done so to prevent state corruption.</p>
<p>Now when it comes to connecting Terraform against a particular infrastructure provider, it’s good to know that Terraform provides a public registry located at registry.terraform.io, which contains a bunch of providers and modules. We’ll talk about modules later on. But for now, it is providers which are used to integrate against an infrastructure providers API.</p>
<p>When it comes to provisioning AWS infrastructure, you’ll want to work with the latest version of the AWS provider. Providers are visioned to maintain compatibility with the infrastructure providers API as it evolves over time. Once you have selected the AWS provider, the use provider link top right, provides an example of how to configure the AWS provider with a new Terraform code.</p>
<p>For the record, each available provider held within the registry provides a comprehensive documentation, including examples of how to work with it. To exit the documentation associated with the AWS provider, click on the documentation link, top right. All provider documentation is searchable allowing you to quickly navigate to the required documentation. This example shows documentation specific to launching an AWS EC2 Instance. You can easily copy and paste the provided examples, thereby quickening the pace of development.</p>
<h1 id="Terraform-CLI"><a href="#Terraform-CLI" class="headerlink" title="Terraform CLI"></a>Terraform CLI</h1><p>Welcome back. In this lesson, I’ll review the installation process for installing the open-source version of Terraform locally. Now the good news is since Terraform is packaged as a single binary, installation is very simple and quick, as you’ll soon see. Let’s begin.</p>
<p>Terraform provides operating system specific downloads for all of the most popular desktop or workstation operating systems, including macOS, Linux, and Windows. Clicking on any of the provided download links will download a ZIP archive. Once downloaded, it is just a case of unzipping the archive and then moving the single Terraform executable binary within to a location configured on your operating system’s system PATH. It’s literally that easy.</p>
<p>Now if you’re looking for a more automated or scripted approach for a macOS-based system, then the following script displayed here can be used to download and install the latest version of the Terraform CLI, hands-off. The script provided on the screen is specific to macOS. This script will also set up autocompletion for the Terraform subcommands. Likewise, for Linux, this script can, again, be used to install the latest version of Terraform CLI automatically. And for Windows, the process provided here is a bit more manual, but in a sense, just requires you to move the Terraform binary to a location, as previously mentioned, configured in the current system PATH environment variable.</p>
<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><p>Welcome back. In this lesson, I’ll review the development tooling setup as will be used later on in the provided Terraform demonstrations. When creating your own infrastructure as code templates, it pays to use a productive editor, which for the purposes of this course will be Visual Studio Code.</p>
<p>Visual Studio Code is a freely available, open source IDA, which can be installed and run on most desktop workstation operating systems. It provides a lot of extremely useful editing features such as intellisense, which can guide you through the process of creating your Terraform code.</p>
<p>After installing Visual Studio Code on your workstation, it’s highly recommended to install HashiCorp’s own Terraform extension. This extension compliments existing editing features by making available Terraform syntax highlighting.</p>
<p>Additionally, another useful extension which helps to boost Terraform configuration development productivity is the Terraform doc snippets extension. This extension can be used to call up numerous snippets of Terraform code for all of the most popular AWS resource types. In fact, this extension can be used to call up snippets of code for other cloud infrastructure providers, such as Azure and GCP, making it more than useful for multi-cloud infrastructure projects.</p>
<h1 id="Terraform-CLI-AWS-Authentication"><a href="#Terraform-CLI-AWS-Authentication" class="headerlink" title="Terraform CLI AWS Authentication"></a>Terraform CLI AWS Authentication</h1><p>Welcome back. In this lesson, I’ll review the credential configuration options that you can use to allow Terraform to correctly and successfully authenticate into your own AWS accounts. If your authentication set up is broke, Terraform is not going to be able to authenticate, and this will mean no infrastructure gets provisioned. So, understanding how to do this successfully is essential to moving on. Let’s begin.</p>
<p>There are basically three different approaches to configuring your AWS account credentials to allow Terraform to connect and authenticate successfully. The first approach is to wire the credentials directly into the Terraform template file. In the example given here, the AWS provider is configured with both an access key and a secret key.</p>
<p>Now, although this approach is probably the quickest and easiest approach, it should be done so with care since it is considered bad practise or, at least, not good practice if you were to version control this file containing the credentials. The last thing you want is AWS account credentials floating around in your version control system, particularly ones that can perform infrastructure changes.</p>
<p>As you will see in the following two slides there are better alternatives that allow you to extract out the credentials and store them elsewhere. Pausing briefly here, regardless of the AWS credential management approach you end up using, within the AWS account you should create a dedicated IM user with programmatic access enabled.</p>
<p>For this user account, make sure to grant at least privileged based permissions, as this limits the potential blast radius that Terraform will have within the AWS account. Granting the Terraform AWS IM user full admin access within the AWS account might be convenient at first but it will likely be overkill, not to mention dangerous as Terraform effectively has granted permissions to do any and everything within the AWS account.</p>
<p>If, for example, you need it to only build a VPC, Subnets, Route Tables, and deploy EC2 instances of, say, a particular instance type, then create a custom IM policy and assign it to the IM Terraform user that allows just that and nothing else. The second approach is to leverage environment variables. The Terraform CLI Executable is designed to scan for and detect the presence of these environment variables. If detected, they will be used.</p>
<p>Clearly, this approach is better from the perspective of version control. With this approach, the main.tf file, as previously configured, could now safely be committed into version control, since, the AWS credentials have been extracted out and away from it. The third approach is to store them, as you may have already done so if you’re a user of the AWS CLI, on the local file system, in a credentials file.</p>
<p>The AWS Terraform provider, for example, can be configured via the shared credentials file attribute having it pointed at an existing credentials file, such as the one used in this example. For those who may be unfamiliar with the AWS CLI, the file path used within this example is actually a pointer to the same creds file as used by the AWS CLI. Note; the AWS CLI is not a prerequisite for the Terraform CLI. Regardless, the Terraform CLI can be configured, as seen here, to reuse and share the same creds file created and managed and used by the AWS CLI.</p>
<p>Note; if all three types of credentials are used, then the 3.X version of the AWS provider preferences static credentials first followed by environment variables and then, lastly, shared credentials. The same order is just given in the three explanations. The next example is really just a derivative of the previous example. Here, when we use and set the profile, together with the absence of the shared credentials file attribute, implies that the files will be sourced from the current users home&#x2F;.aws&#x2F;credentials file. Again, the same one that is used and managed by the AWS CLI.</p>
<h1 id="Terraform-CLI-Subcommands"><a href="#Terraform-CLI-Subcommands" class="headerlink" title="Terraform CLI Subcommands"></a>Terraform CLI Subcommands</h1><p>Welcome back. In this lesson, I’m going to now review the Terraform CLI and its available subcommands. Particular focus will be placed on the main commands: init, validate, plan, apply, and destroy. Let’s begin. When starting out with the Terraform CLI tool, check out the embedded help documentation. To do so, fire up your local terminal and type in terraform -help. This will display Terraform help regarding all of the available subcommands, which are grouped into those considered the main commands followed by all remaining commands, which are least commonly used and&#x2F;or for more advanced requirements.</p>
<p>As seen on the slide, the main commands are considered to be init, validate, plan, apply, and destroy. These commands, which I’ll go deeper into in the following slides are the ones that you will often cycle through when you are iteratively developing and building out your Terraform infrastructure. The remaining subcommands, as seen here, are as mentioned less commonly used and more so for advanced scenarios. Having said that, I’ll call out a couple that I tend to use frequently.</p>
<p>Console. The console subcommand fires up a REPL, read-evaluate-print-loop, interactive console. This allows you to test out and evaluate Terraform expressions. More than useful when experimenting or troubleshooting. The interactive console will actually use the available Terraform state during evaluations.</p>
<p>Format. The format subcommand is useful to reformat and standardize the layout of your Terraform code.</p>
<p>Output. The output subcommand can quickly re-render the output values for your root module.</p>
<p>Workspace. The workspace subcommand we covered earlier on in the course, but to reiterate, it is used to create and manage multiple workspace environments, which in turn can be used to build multiple versions of infrastructure of the same set of Terraform configurations. I’ll now move on and do a deeper dive on the main commands since they will be the ones that you will often use and will need to be confident with, to build AWS infrastructure.</p>
<p>Starting with the Terraform init command. This is a mandatory command required to initialize your Terraform workspace in the current directory. Before running the Terraform init subcommand, your root module directory will look something like the following. The key point here is the absence of the .terraform directory.</p>
<p>Now, if we were to examine a typical main.tf file that gets populated into the root module directory, it would look something like this. Here we can see that it has been configured with the AWS 3.55 provider and has been specified that we are configuring it to authenticate by using a profile name. In this case, the default profile. This tells Terraform to collect the AWS credentials from the currentusers.aws&#x2F;credentials file. The same one that the AWS CLI uses and manages.</p>
<p>Now, to initialize our current working directory, we enter the command terraform init. The initialization process will do a number of things for us. Firstly, Terraform reads our configuration files in the working directory to determine which plugins are necessary, searches for the installed plugins in several known locations, and then downloads the correct one. In this case, the AWS 3.55 provider. It will also create a log file to log down the version of the plugins that we have initialized our waking directory with. And finally, it will also pull down any external modules as used and referenced within our remaining Terraform templates.</p>
<p>If we were to rescan the current working directory after having performed a terraform init command, we would now see the updates made within it. Namely the presence of the .terraform directory, which holds a copy of the configured provider and any referenced external modules. The current working directory also now contains a .terraform.log.hcl file, which, as previously mentioned, is used to log down the version of the plugins that we have initialized our working directory with.</p>
<p>If we were to use the tree command on the .terraform directory, we would be able to see and examine its internal structure, which in this case, we have configured a single provider, that being the AWS version 3.55 provider. Note here that the AWS provider file is an executable file itself. Terraform plugins, and in our case, the AWS provider, are written in Go and are executable binaries invoked from the Terraform Core over RPC.</p>
<p>In this example, you can also see the presence of the AWS VPC module, which is being truncated for brevity purposes. As an FYI, the AWS VPC module is available in the Terraform public registry, and it’s super useful for building out VPC configurations and related networking components very quickly.</p>
<p>Next up is the Terraform validate command. The Terraform validate command does just that. It validates all of your local Terraform configuration, making sure that it is syntactically correct, et cetera. It is often used immediately after any save operation on the configuration. In the example provided here, the current Terraform configuration has successfully passed and is therefore considered valid.</p>
<p>In the next example, the cidr_block attribute in the VPC resource has been intentionally commented out to cause an error. Rerunning the terraform validate command will cause it to flag the problem. In this case, it is flagged expectedly with the “Error: Missing required argument” message and importantly highlights the offending Terraform configuration file and the problematic line number within it.</p>
<p>Next up is the Terraform plan command. The terraform plan command is a dry-run command, which is typically run just before the apply command. When executing this command, Terraform is just telling us what it would do if we perform the apply command. Running this command acts as a safety check. Sometimes our assumptions of what an apply would do might be slightly or considerably wrong. Fingers crossed here this is not the case. Regardless, the plan command will highlight exactly what would happen and provides us an execution plan that we can do when we’re doing the real thing.</p>
<p>Whenever you run a plan or apply, Terraform reconciles three different data sources. One, what you wrote in your Terraform templates. Two, the current Terraform state file. And three, what infrastructure actually exists within the infrastructure provider. In the plan example shown here, the plan results are indicating that nine new resources would be added, zero would be changed, and zero would be destroyed.</p>
<p>Because Terraform is convergent, it will play in the fewest required actions to bring the infrastructure to the desired configuration. Terraform also considers dependencies to determine the order that changes must be applied in. The plan stage is relatively inexpensive compared to actually applying changes. So you can often use the plan command while developing your configuration to see what changes would need to take place. </p>
<p>Moving on to the Terraform apply command. The terraform apply command reruns the plan or execution plan, and assuming you approve it, will then provision the changes within the provider as per the plan. Now, if anything goes wrong, Terraform will not attempt to automatically roll back the infrastructure to the state it was in before running apply. This is because apply adheres to the plan. It won’t delete your resource if the plan doesn’t call for it.</p>
<p>To address the need for a rollback position, if you version control your infrastructure configuration code, and we strongly encourage you to do so, you can use a previous version of your configuration to roll back to. Alternatively, you can use the destroy or taint command to target components that need to be deleted or recreated respectively. By default, the apply command will always prompt you first for confirmation before applying the plan changes.</p>
<p>Order confirmation can be set by attaching the order approve parameter. This is useful as a workflow optimization when doing frequent small incremental changes, perhaps within ADF test environment. Obviously, take care when considering doing this in production. When the apply command completes, it will report back the applied changes as those added, those changed, and those deleted. It will also render out any outputs that you have coded into your Terraform templates.</p>
<p>In the example shown here, the output section shows the subnet IDs for subnets one and two, the VPC ID, and the public IP address for the web EC2 instance. Finally, we have the Terraform destroy command, which is used to tear down all Terraform managed infrastructure that you have codified. The terraform destroy command is clearly a destructive command, so care must be taken using it, particularly so in production.</p>
<p>When it comes to production environments, authorizing destructive operations via Terraform within your AWS account can be and should be controlled by an appropriately designed IAM policy. This policy would then be attached to an IAM user whose credentials are securely managed and available to only a select few. When the terraform destroy command runs, it will again plan for and report out the required deletion operations to remove all Terraform managed resources within your AWS account.</p>
<p>By default, the destroy command will always prompt you first for confirmation before applying the deletions. Order confirmation can again be set by attaching the auto-approve parameter, but this should only be done if you’re a hundred percent certain of what the end result is, more so than ever for production environments. Similar to the plan and apply commands, the destroy command once executed and completed will report on the final number of resources that have been destroyed.</p>
<h1 id="Terraform-Language"><a href="#Terraform-Language" class="headerlink" title="Terraform Language"></a>Terraform Language</h1><p>Welcome back. In this lesson, I’ll review the more commonly used parts of the Terraform HCL language, which you’ll require a good understanding of to codify your own Terraform infrastructure as code templates. Let’s begin.</p>
<p>Formally, Terraform configuration is running using HCL, HashiCorp Configuration Language, a human-friendly, readable, and writeable syntax, perfect for codifying infrastructure requirements. HCL’s configuration was created to have a more clearly visible and defined structure when compared to other well-known configuration languages, such as JSON and YAML.</p>
<p>Now, at the top level, the HCL syntax comprises stanzas or blocks that define a variety of configurations available to Terraform. Stanzas or blocks are comprised of key value pairs. Terraform accepts values of type string, number, Boolean, list, and map. Single line comments start with hash, while multi-line comments use an opening slash, asterisk and a closing asterisk, slash.</p>
<p>An interpolated variable reference is constructed with the dollar sign, clearly brackets syntax. For example, the type tag in the provided example interpolates the variable named project. Single line strings are written in double quotes, whereas multi-line strings are specified using the heredoc format. In this case, an opening EOF, end of file, character sequence is paired with a closing EOF character sequence. In-between each line is considered part of the multi-line string. This multi-line string approach is often used to capture scripts as used within the user data attribute when bootstrapping EC2 instances.</p>
<p>Maps are defined using curly braces and are a collection of key value pairs. They are often used for creating variables that act as look up tables. In the example provided here, an AMI look up table has been created. The Terraform Core program requires at least one provider to build anything. You can manually configure which versions of a provider you would like to use. If you leave this option out, Terraform will default to the latest available version of the provider.</p>
<p>Remember to initialize the current working directory using the Terraform init command, which is required before attempting to perform a plan or apply. At the end of the day, it’s all about provisioning resources within your infrastructure provider. The resource keyword is used to declare the type of resource you want to provision.</p>
<p>In the example given here, we are declaring two AWS resources, a VPC and a subnet. Each resource is then configured with its required and optional attributes. Note in this given example, the subnet resource utilizes and sets the count attribute, which is considered a meta argument within Terraform. It allows you to create multiple versions of the resource it is declared within.</p>
<p>In the example provided here, Terraform will create one subnet per availability zone. The outcome of applying this Terraform configuration will be an AWS VPC, which has public subnets deployed into each of the AZs for which the VPC spans across. This type of syntax, although more abstract, is far more concise and compact when compared with hand-writing each subnet individually.</p>
<p>When declaring resources, the following layout is required. Resource is the top level keyword followed immediately by type and the name of the resource, both in double quotes. Although the more recent versions of Terraform do not mandate double quoting either the type nor name, it is still considered idiomatic to do so. In fact, if you were to run the Terraform format command to reformat your code, all unquoted resource types and names will become double quoted. The type represents the type of the resource to be provisioned.</p>
<p>In the two resource examples shown here, we are declaring types of aws_vpc and aws_subnet for an AWS VPC and an AWS subnet, respectively. The resource name is an arbitrary name that you come up with that you can then later use to refer to this instance of the resource. Every Terraform resource, regardless of type, is structured exactly the same way. This resource example demonstrates how to launch a single EC2 C5 instance type for the purposes of performing number-crunching, et cetera. Here the type is set to be an aws_instance, which represents an EC2 instance. The resource is then named NumberCruncher for lack of imagination.</p>
<p>Data sources are a way of querying an infrastructure provider for data about existing resources. Data sources, when declared, can leverage one or several filters to narrow down the return data, to be more specific about the requirement at hand. In the example provided here, a data source is declared to return AMI IDs for all available Ubuntu 20.04 images for the current AWS region. If more than one image is discovered, the most recent one will be returned based on the fact that the most recent attribute has been declared to be true.</p>
<p>The Ubuntu data source, as seen here, is then later used within the number cruncher AWS instance resource to specify its AMI. Using this type of approach instead of hard-coding the actual AMI ID directly within the AWS instance resource future-proofs your Terraform templates.</p>
<p>For example, consider the scenario of the Ubuntu 20.04 operating system being overhauled or patched by chronicle, perhaps due to a recently discovered security vulnerability. Having done this, they will likely also publish a new set of updated AMIs.</p>
<p>Now, the next time you perform a Terraform plan or apply command, Terraform will detect that your existing instance or instances, running the old AMI are now out of date and can be relaunched with the newer equivalent updated AMI. Or when launching a brand-new environment, you’ll always be safeguarded by the fact that the instance launched within it will be using the latest patched and up-to-date AMI.</p>
<p>In the second example of a data source, information about all available AZs for the current AWS region is queried for. The AZ data source is then referenced within the subnet resource being declared. Here, the availability zone attribute takes on the first value contained within the AZ’s data source. Taking this approach helps to keep our Terraform templates generalized such that they can be reused easily across different AWS regions.</p>
<p>Variables are another technique to assist in keeping your Terraform configurations generalized and reusable for multiple requirements. The idiomatic practice is to store variables in a file named variables.tf. Variables can have default settings. If the default is omitted, the user will be prompted to enter a value. In the example provided here, we are declaring the variables that we intend to use, but haven’t declared any default values. The declared variables can then be referenced from within the main.tf file and for the same meta elsewhere in all other .tf files in the current directory.</p>
<p>It’s important to understand that Terraform provides several ways in which you can see it and override the default value for any and all declared variables. If multiple approaches are used together, then Terraform follows a defined precedence in terms of which ones get used first. I’ll now review them in order from highest priority to lowest priority, as also displayed here currently.</p>
<p>Option one. Leverages command line variable flags. If they are defined on the command line, then these will have the highest priority. Option two allows you to define your variable values within a terraform.tfvars file. If this is detected unavailable, it will be automatically used. If required, you can have multiple distinctly named versions of the tfvars file. When you do so, you must declare which one is being used via the VAR file parameter. This approach is perhaps useful to alter the infrastructure provisioning process for say, different environments, et cetera.</p>
<p>Option three. Within the shell or terminal session from which the Terraform CLI is being used, you can see environment variables named with the following naming strategy. Capitals TF_VAR_ followed by the actual name of the variable itself, and then assign it with a value.</p>
<p>Option four uses the default values stored against the declared variables within the variables.tf file. And lastly, option five, the lowest priority option, manual entry. You will be prompted to supply a value at runtime within the terminal during the Terraform execution. Output values are like the return values of a Terraform module. The idiomatic practice is to store outputs in a file named outputs.tf.</p>
<p>Primarily outputs are used for the following two purposes. One, the root module uses outputs to print out values in the terminal for your convenience. In the example shown here, the public IP output would print out the AWS EC2 assigned public IP address to the terminal once the provisioning has completed. And two, a child module can use outputs to export a set of values which are required and used elsewhere within its parent module. From here, the parent module can then later pass these values as inputs to other child modules.</p>
<p>Modules are an abstraction that can be used to combine related resources together for reusability purposes. At implementation time, modules are containers of multiple related resources that are used together. A module consists of a collection of terraform.tf files, all kept together in the same directory. Modules are the main way to package and reuse resource configurations within Terraform. Every Terraform configuration has at least one module known as its root module, which consists of the resources defined in the .tf files in the main working directory.</p>
<p>A Terraform module, usually the root module of a configuration, can call other modules to include the resources into the configuration. A module that has been called by another module is often referred to as a child module. Child modules can be called multiple times within the same configuration, and multiple configurations can use the same child module.</p>
<p>Finally, as previously mentioned earlier in the course, Terraform has a public registry containing modules built by the Terraform community, all of which are available for use to cherry pick from as and when required. Expressions are used to refer to all compute values within a configuration. The simplest expressions are just literal values like the string hello, or the number five. But the Terraform language also allows for more complex forms, such as references to data exported by resources, arithmetic, conditional evaluation, and all those that utilize built-in functions.</p>
<p>In the provided example shown here, expressions are used to test whether the AWS security group variable is ND or not and react accordingly. To round out the Terraform language introduction, Terraform includes a number of built-in functions that you can call from within your expressions, as just previously explained, to transform and combine values.</p>
<p>The general syntax for function calls is a function name followed by parentheses containing a comma separated list of input arguments. The available built-in Terraform functions, and there are many of them, allow you to perform infrastructure provisioning operations more dynamically. In the provided example here, three different built-in functions are used: length, cidr subnet, and element, working together to codify the creation of multiple subnets for the scenario. The length function returns the length of a list.</p>
<p>In this example, returning the availability zone count. The cidr subnet function will create a cidr block string based on the inputs given, returning something like 10.0.0.0&#x2F;24, 10.0.1.0&#x2F;24, 10.0.2.0&#x2F;24, et cetera, et cetera. Keep in mind here that this function gets called multiple times since this resource sets and uses the count meta argument. The element function retrieves a single element from a list at the given position. If the given index is greater than the length of the list, then the index is simply wrapped around.</p>
<h1 id="AWS-Simple-VPC-EC2-Instance"><a href="#AWS-Simple-VPC-EC2-Instance" class="headerlink" title="AWS Simple VPC + EC2 Instance"></a>AWS Simple VPC + EC2 Instance</h1><p>Welcome back. In this demonstration, I’ll show you how to create a simple AWS VPC spanning two availability zones. Two public subnets will be created together with an internet gateway and a single route table. A T3.micro instance will be deployed and installed with Nginx for web serving. Security groups will be created and deployed to secure all network traffic between the various components. Lets begin.</p>
<p>Okay, so starting out in the following, CloudAcademy Github repo. If you want to follow along, then I highly recommend you clone this repo yourself locally. This repo contains four Terraform AWS infrastructure based exercises.</p>
<p>In this demonstration, we’ll perform exercise one. The AWS VPC architecture that we’ll build in this exercise is shown here. Nice and simple for our first example. The Terraform route module will consist of the following. Jumping into Visual Studio Code, you can see that have already git cloned the repo. As mentioned, the repo contains four exercises, and in this demo, we’ll focus on the Terraform templates and the exercise one folder. I’ll now proceed and open up the main.tf, outputs.tf, terraform.tf files and variables.tf files. Starting off with the main.tf file, I’ll highlight the AWS provider configuration.</p>
<p>Now, when it comes to building your own configurations, remember that you can always copy and paste this block from the terraform AWS online provider documentation. Most of the time, you will want to go with the latest version. With the AWS provider now configured, it’s time to jump into the terminal and initialize the Terraform working directory. To accomplish this, I’ll simply execute the Terraform init command. This would download the required plugins, in this case, the AWS is provider plugin.</p>
<p>Here you can see that this has now completed successfully. This is a one time operation that is required before you perform any Terraform plan or apply commands. Next I’ll do a directory listing to highlight the new .terraform directory and the .terraform.lock.hcl file that have been created as a result of executing the last command. I’ll now use the tree command to highlight the internal structure of the .terraform directory. Here we can see the AWS3.55 provider plugin binary that has been downloaded.</p>
<p>Okay, moving on, let’s examine the Terraform configuration within the main.tf file. The first resource block that we declare is that for the VPC. Here, we’re initializing it with the cidr block 10.0.0.0&#x2F;16. The largest VPC EDU space we can create with an AWS. I’ll also tag it with the following tags for identification purposes.</p>
<p>Next up, I’m creating two public subnets, which will be provisioned within the previously declared VPC. Subnet one will be created with the first &#x2F;24 block and subnet two will be created with the next second &#x2F;24 block. Subnet one will be deployed into the first AZ and subnet two will be deployed into the second AZ. Both AZs as used in this example, are stored in a list based variable named availability zones.</p>
<p>Taking a look at the variables.tf file, we can say each of the declared variables that the route module takes as imputs. Highlighting the availability zones variable, we can see that it is indeed typed as a list of string, but has no default value. Instead, the default value is passed in via the Terraform.tfrs file. Here we can see the two string values assigned to the availability zones or list, US West to A and US West to B.</p>
<p>Okay, jumping back into the main.tf file, the next resource I’ll highlight is the internet gateway. The internet gateway is required to facilitate internet traffic. Next, we declare a public route table containing a default route which will route outbound traffic through the internet gateway. This route table is then associated with both public subnets.</p>
<p>Next, we declare a security group to restrict inbound and outbound traffic to the EC2 instance that is to be later declared. This security group has two ingress rules and one egress rule. The first ingress rule allows inbound SSH traffic from my week stations parameter IP address. This IP address is stored in a Terraform variable named workstation IP.</p>
<p>Now, the default value for the workstation IP variable is set using an environment variable in the terminal. Within the terminal, I’ll run the command set pipe grip to search for, in capitals, TF_VAR. And here, we can see the value assigned to it. When the Terraform plan or reply command is executed, that will detect the presence of the environment variable and then use it within Terraform. The second ingress rule is used to allow inbound port 80 web traffic to the Xginx web server that we’ll install on the EC2 instance.</p>
<p>The single egress rule is required to allow the EC2 instance to connect out to the internet to pull down the Nginx package which’ll be installed. The final resource is the EC2 instance itself which will be bootstrapped, as mentioned, with the Nginx web service. That EC2 instance is configured using various settings stored within Terraform variables, such as it’s AMI, instance type, SSH key, subnet ID and security groups. Additionally, the EC2 instance is being configured to have a public IP address automatically assigned to it.</p>
<p>The Nginx web server is installed by virtue of configuring the user data attribute, which in turn, is configured with a multi line string containing the bash install screen. Note, the multi line sting uses heredoc format encapsulated within a pr of EOF strings.</p>
<p>Okay, at this stage, we’re ready to jump back into the terminal and perform a plan and apply. Before I do, I just want to highlight how the AWS user credentials are managed. For this example, I’m setting the credentials using environment variables set within the terminal, as seen here.</p>
<p>Right, we are ready to run a Terraform plan. In doing so, Terraform will generate an execution plan for us highlighting what will be created and or changed. Having reviewed this, we can proceed by running the Terraform apply command, and in this case, I will auto approve it by adding on the auto approve parameter. So here we can see that we have begun the AWS infrastructure provisioning process. The time it takes to complete is entirely dependent on the number and type of AWS resources being launched.</p>
<p>While this is happening, let me show you the Terraform extensions that I have set up within Visual Studio Code. The first extension that I have installed in the HashiCorp Terraform extension. Now, one of the customizations that I’ve applied on this extension is the format on save option, setting it to true. When doing so, this will have the extension automatically run the Terraform format command on your Terraform code within the file just saved. This is super useful as it keeps your code following best practices in terms of formatting and layout. For example, if I modify the main.tf file to have non standard formatting, when I save it, the Terraform extension will automatically apply best practice formatting, string quoting and indentation, et cetera.</p>
<p>Another thing to highlight is the snippet generation and intellisense options provided by the HashiCorp Terraform extension. Additionally, I can also pull up any number of snippets provided by the Terraform doc snippets extension, which I have also installed. In the example shown here, I’m entering the character sequence tf-AWS-resource to trigger the AWS snippets available. Each snippet has a preview of what to expect. In this example, if I go with the AMI snippet, I get the following AMI block pre configured with the commonly used attributes, et cetera. As mentioned, these snippets are provided by the Terraform doc snippets extension.</p>
<p>Okay, let’s do a little bit of clean-up and then head back over into the terminal as our Terraform apply command has now completed successfully. Here we can see that nine resources have been added and that we have several outputs indicating the subnet IDs, VPC ID and the public IP address assigned to the Nginx web server instance. These particular outputs have been declared within the outputs.tf file. Let’s now copy the public IP address and then perform a curl request to it. Excellent, our Nginx server is now up and running and has been able to respond to our HTTP git request. This is a great result.</p>
<p>Considering that all of the AWS VPC set up and networking configuration was performed automatically for us by Terraform. We can now confidently jump into our browser and test out the same address like so. And perfect, we get the default Nginx web page displayed. Heading over into the AWS console, we can examine the VPC section and view the newly provisioned VPC.</p>
<p>Likewise, the same for the EC2 instance. Here we can see the EC2 instance that is up and running. We can also navigate to the user data that was passed to it at launch time and indeed, that has the best script that has installed the Nginx web server, very cool. Back within the terminal, let’s run a Terraform refresh command. This will reconcile the local Terraform state with the actual infrastructure state, and again, print out the configured outputs. As expected, nothing has changed.</p>
<p>The next thing I will demonstrate is the concept of Terraform workspaces. Let’s first consult the workspace command help, but running the command Terraform workspace –help. Here we can see each of the workspace sub commands. Let’s examine the current list of workspaces. Here, we can see that we’ve just the default workspace.</p>
<p>Let’s now create a new workspace named test. When we create a new workspace, we are swapped into it automatically. We can confirm this by using the show command to display the currently active workspace and indeed, it is the test workspace. I’ll now run Terraform apply, auto approve to provision a new identical AWS infrastructure, albeit, managed within the local Terraform test workspace.</p>
<p>Again, the AWS provisioning has completed successfully, copying the latest public IP address for the new Nginx web server. We can test it out to see if it’s alive. Here, the HTTP request has failed. This is likely due to the fact that the Nginx web server is still in the process of warming up. That is completing its boot and installation processes. Repeating the curl command should eventually result in a successful HTTP response. Which it now does.</p>
<p>We can double check this by returning to our browser, and again, we are able to successfully pull up the Nginx web page. Jumping back into the AWS console, let’s check that we have additional AWS infrastructure. Here in the EC2 console, we can see the presence of another EC2 instance. And likewise, back in the VPC console, we have a second identically configured VPC, very cool.</p>
<p>Okay, at this stage, we are now finished with this exercise. To minimize our ongoing AWS costs, we can tear down the test workspace infrastructure by running the command, Terraform destroy. Returning to the AWS console, I’ll confirm that indeed, the test infrastructure has now been removed. We can also repeat the same Terraform destroy command in the default workspace. Let’s do this now. And again, confirming that our AWS resources for the default workspace have been successfully removed, which they have. Okay, that now completed this Terraform exercise.</p>
<h1 id="AWS-Advanced-VPC-ALB-EC2-Instances-v1"><a href="#AWS-Advanced-VPC-ALB-EC2-Instances-v1" class="headerlink" title="AWS Advanced VPC + ALB + EC2 Instances (v1)"></a>AWS Advanced VPC + ALB + EC2 Instances (v1)</h1><p>Welcome back. In this demonstration, I’ll show you how to create an advanced AWS VPC spanning two Availability Zones, which will have both public and private subnets, an internet gateway and net gateway will be deployed into it, public and private route tables will be established. An Application Load Balancer will be installed within it, which will load balance incoming traffic across an auto scaling group of NGINX web servers. Again, security groups will be created and deployed to secure all network traffic between the various components. Let’s begin.</p>
<p>As per the previous demonstration, all of the Terraform configuration, which will be demonstrated here, is available online, this time in the exercise two folder within the repo. The AWS VPC architecture that we’ll build in this exercise is shown here and is more advanced than the previous one by virtue of the VPC having public and private zones, combined with the introduction of an Application Load Balancer and an auto scaling group. Regardless, the Terraform configuration is still contained within a single route module.</p>
<p>Jumping into Visual Studio Code, I’ll open up each of the Terraform config files. Starting off in the main.tf file, again, we have the AWS provider, which will allow us to provision our AWS infrastructure. As with all Terraform projects, before we can provision actual infrastructure, we first need to run the Terraform init command to initialize our working directory, which I’ll do now.</p>
<p>Okay, that’s kicked off and initializing. While that is happening, let me explain the key configuration changes introduced into the main.tf file. Here, we have a data source which captures information about the available Ubuntu AMIs. We’ll leverage this later on in a launch template resource further down in this file. Next, is our VPC resource for establishing the VPC. The only difference here is that it now receives the CIDR block from a variable. If we look at the variables.tf file, we can see the variable that is used to store the CIDR block. The terraform.tfvars file actually holds the default value as seen here.</p>
<p>Now, within the VPC, we’ll establish public and private zones. Subnets one and two will be for the public zone and will have an attached route table that routes default traffic via an internet gateway. Subnets three and four, on the other hand, will be allocated to the private zone and will have an attached route table that routes default traffic through a managed net gateway. The subnet resource configuration demonstrates the use of calling an in-built Terraform function, in this case, the CIDR subnet function, to calculate the CIDR block for the subnet itself. By doing so, we can again, make our main.tf file more flexible for future requirements.</p>
<p>Now, to understand how the CIDR subnet function works, I will jump over into the terminal and fire up the Terraform console. Next, I can simply copy across the expression that uses the function and evaluate it. Here we can see that it has returned the CIDR block 10.0.1.0&#x2F;24. We can repeat this again for the second subnet. This time it returns 10.0.2.0&#x2F;24 and we can keep repeating this to understand how the CIDR blocks are being generated. This also demonstrates the usefulness of the Terraform console command.</p>
<p>Okay, moving down the main.tf file, next up is an elastic IP resource. This will be used by the following net gateway resource, which collectively allows privately zoned instances to route traffic out to the internet, which we will require since our auto scaling group of instances will reside in the private zone and they will need to call out to the internet to download the NGINX packages for web serving.</p>
<p>Next up is our route table configuration. Separate route tables are established, one for each of our zones. The public route table routes traffic via the internet gateway and the private route table routes traffic via the net gateway. The security group configuration has also been modified. Here we have separate security groups for both the web fleet and the Application Load Balancer. The web service security group, as seen here, should actually have it’s second ingress port 80 rule more restrictive to allow only inbound port 80 from the Application Load Balancer nodes.</p>
<p>For the record, I’ll now make this change and commit it back to the repo for your benefit. The Application Load Balancer security group allows all inbound port 80 traffic from the internet. Additionally, it is required to have an egress rule to allow it to forward downstream traffic to the web fleet.</p>
<p>Next up, we have configured an AWS launch template resource. This represents the launch configuration requirements for the web fleet that are managed within an auto scaling group and sit behind the Application Load Balancer in the private zone. The AMI ID is pulled from the Ubuntu data source that we earlier reviewed towards the top of this file. The network interface is block declared here, is used to attach the security group into explicitly disabled public IP address assignment.</p>
<p>Now, since recording this demo, I have replaced the network interfaces block in favor of using the VPC security group IDs attribute to attach to the security groups. This is more stable for the overall infrastructure when you reapply any updates through Terraform. The launch template finally configures user data to bootstrap the instances with the NGINX web server. In this example, the actual bootstrapping script is stored externally in its own file and is pulled in using the inbuilt filebase64 function, which in turn uses string interpellation to inject the current module path. Here we can see the actual contents of the referenced ec2.userdata file.</p>
<p>Next up, we have the Load Balancer. It’s configured to be an external facing Application Load Balancer. It’s configured with the ALB security group and is deployed across the two public subnets spanning both Available Zones for availability purposes. We then establish a web server target group with the target group port being set to port 80, the NGINX default listening port. Equally, on the Application Load Balancer itself, it’s configured to also listen on port 80, such that it simply forwards traffic from port 80 down to port 80. This is configured via both a default action configured directly on the Application Load Balancer’s listener itself and via a single listener rule, whose only condition is to forward the route path to the same target group.</p>
<p>Finally, an auto scaling group resource is configured to span the two privately zoned subnets, subnet three and subnet four. The desired min and max settings are all set to two, which will result in two instances always at runtime. Done so for demonstration purposes only. The auto scaling group references the earlier reviewed launch template and is configured to register its instances as targets within the target group. </p>
<p>Okay, with the route module review now complete, let’s head over to the terminal and launch the infrastructure by executing Terraform apply. Okay, that has now completed successfully and we have several outputs printed out for our viewing. They include the Application Load Balancer DNS, the subnet IDs for each of the four subnets and the VPC ID. I’ll copy the Application Load Balancer DNS value and then call for an HTTP response, using the -Y to indicate that I’m only interested in the HTTP headers for now. And excellent, it retains a HTTP 200 response code, indicating success and that the response appears to have originated from an NGINX web server, which is what we would expect.</p>
<p>From here, I’ll jump over into my browser and browse to the Application Load Balancer, like so. And what would you know, we have a valid response back from our auto scaled group of NGINX web servers via the Application Load Balancer. A top result. To round out this exercise, I’ll now examine the AWS infrastructure as just provisioned. In the EC2 console, we can see that we indeed have two web server instances. </p>
<p>Navigating to the Load Balancer section, we can see our newly provisioned Application Load Balancer with the same DNS address, which we just used to browse to. We can also see that it has a single HTTP port 80 listener and if we click on the view rules link, we can observe the listener rules we have configured. In this case, our custom rule and the default rule both forward traffic downstream to the same target group, which in our case, is the web server auto scaling group.</p>
<p>Drilling into the target group, we can see that the target group has successfully registered both EC2 instances and they importantly, both are registered as healthy. Okay, that now concludes this demo. If you’ve been following along, please don’t forget to perform a Terraform, destroy to tear down your AWS resources.</p>
<h1 id="AWS-Advanced-VPC-ALB-EC2-Instances-v2"><a href="#AWS-Advanced-VPC-ALB-EC2-Instances-v2" class="headerlink" title="AWS Advanced VPC + ALB + EC2 Instances (v2)"></a>AWS Advanced VPC + ALB + EC2 Instances (v2)</h1><p>Welcome back. In this demonstration, I’ll show you how to create the same AWS architecture as used in the previous demonstration. But in this demonstration, I’ll refactor the Terraform templates to use the count meta argument for configuring the public and private subnets, as well as their respective route tables, thereby simplifying the overall Terraform configuration. Let’s begin.</p>
<p>As per the previous demonstrations, all of the Terraform configuration, which will be demonstrated here, is available online, this time in the exercise three folder within the repo. The AWS VBC architecture that we’ll build in exercise three, is identical in structure to the AWS VPC architecture as used within exercise two, the previous exercise. The purpose of this demonstration is to show you an alternative approach to provisioning multiple similar resources. In this case, our subnets and route titles, et cetera. The key technique as used here is based on using Terraform’s resource count meta argument to dynamically create multiple similar resources for us, as will be used to create our subnets and route tables, for example. Jumping into Visual Studio Code, I’ll open up just the main.tf file since. This file is the only one that has modifications within it, compared to exercise two. Again, I need to perform an initialization of the current working directory, which I’ll do now. And then, while that is initializing, I’ll explain the modifications.</p>
<p>Jumping down to where the subnets are declared, you can see that we now only have two subnet resource blocks. Whereas previously we had four. The first subnet block declares a subnet per AZ for the public zone. The second subnet block declares a subnet per AZ for the private zone. Now the key attribute that makes this possible is what’s referred to is the count meta argument declared within both subnet resource blocks. The count value here is being derived by using the inbuilt length function to determine how many AZ’s have been declared within the availability zones variable. To make this clearer, let’s fire up the Terraform consult and examine the related expressions.</p>
<p>Firstly, I’ll examine the contents of the availability zones variable. Here we can see that it contains two values, US West two A and US West to B. Now, if we use the link functional in this variable, we expectedly get the value to returned. Next, the inbuilt cidr of subnet function is used to dynamically calculate the cidr block for the current subnet. And it does so by making use of the count.index, which is zero based and X as an index for the current resource.</p>
<p>In the scenario, Terraform creates two public subnet resources for us, even though we’ve only declared a single public subnet block. This is a language feature of Terraform and one that helps us to write less configuration, less is better, but for which is also more dynamic. To help with this explanation, let’s copy of the cidr sub-net function into the Terraform console, and then evaluate it for various values of count on index, starting with zero, then one and then two.</p>
<p>Here, we can see that the first public subnet will have the cidr 10.0.0.0&#x2F;24 and the second one will have 10.0.1.0&#x2F;24. I’ll also do the same for the element and built function, just for the sake of clarity. Note that the element function, which is being used to return a single AZ actually wraps around when the index is greater than the number of elements which exist in the list being indexed. The same element based expression is then also used here to interpolate the evaluation into the meta tag configured on the sub-net resource.</p>
<p>So, this should now make it clear how a single resource blog can be provisioned multiple times. The same configuration is used to configure the private subnets. The only difference is that the cidr sub-net function starts two&#x2F;24 blocks along, caused by the addition of the length of the AZ list. Therefore, as you can see, our two private subnets will be 10.0.2.0&#x2F;24 and 10.0.3.0&#x2F;24.</p>
<p>Okay, moving on, scrolling down to the net elastic IP resource, we can observe that it has been updated to use the count meta argument as well, which in this case will cause it to provision two EIPs, one per AZ. Each of which will be referenced within the immediately following net gateway resource, which as you might expect, also makes use of the count meta argument to create a net gateway in each AZ.</p>
<p>In the net gateway resource, the subnet ID key is set to take on one of the public subnet IDs. Here, the public subnet IDs are returned by making use of the split notation. That is the asterix character. This basically returns all matching public subnet IDs. The same syntax is used to wire up the elastic IPs from the previous resource block, assigning one to each of the net gateways.</p>
<p>Moving on down, a public route table as established, which contains a single default route entry for internet traffic to be sent out through the internet gateway. This public route table is then attached to all public subnets, again, by leveraging this split notation. Likewise, private route tables are created, two of them, one for each AZ. Each private route table has a default route entry, which routes outbound internet traffic out through a net gateway, which is co located in the same AZ. Since in this architecture, we now have AZ independent net gateways configured. Most of the remaining Terraform configuration from here down to the application load balancer remains the same as per the previous demonstration. The application load balancer resource is updated such that its nodes are deployed into the public subnets, which again are identified and using the previously explained split notation. And again, likewise for the auto scaling group. Here we can observe the VPC zone identifier has been updated. With the private subnets being identified, again, using split notation.</p>
<p>Okay, with all of these updates in place, let’s now build the AWS infrastructure. To do so, I’ll run the Terraform apply command to launch the infrastructure. Okay, I’ll speed it up to the point where it completes. Again, we get confirmation that our resources have been successfully created. And for our convenience, we have the various outputs available. This time, I’ve updated the outputs to print out the subnet IDs and cidr blocks for both the public and private subnets. We can see how this is accomplished by viewing the outputs.tf file Here we can see the use of the split notation to grab the subnet IDs and the cidr blocks for the two public subnets. The same goes for the private subnets.</p>
<p>Let’s finally confirm that again, we get a valid HTTP response back from our application load balancer. I’ll copy the updated DNS address and browse to it. And perfect, everything works again as per the last example. Okay, that concludes this demo. Again, if you’ve been following along, don’t forget to perform a Terraform destroy to tear down your AWS resources.</p>
<h1 id="AWS-Advanced-VPC-ALB-Cloud-Native-Application"><a href="#AWS-Advanced-VPC-ALB-Cloud-Native-Application" class="headerlink" title="AWS Advanced VPC + ALB + Cloud Native Application"></a>AWS Advanced VPC + ALB + Cloud Native Application</h1><p>Welcome back. In this demonstration I’ll now show you how to create an advanced AWS VPC to host and support a fully functioning cloud native application. The VPC in question will span two availability zones and have public and private subnets and internet gateway and managed net gateway will be deployed into it. Public and private route tables will be established. An application load balancer will be installed, which will load balance incoming traffic across an auto scaling group of nginix web service installed with the cloud native application front-end and API. A database instance running Mongo DB will be installed in the private side. Security groups will be created and deployed to secure all network traffic between the various components. For demonstration purposes only the cloud native application that we will deploy, which consists of the front-end API components will be deployed such that both components are on the same set of easy two instances. This is done so to reduce running costs only.</p>
<p>Okay, let’s begin. As per the previous demonstrations, all of the Terraform configuration, which will be demonstrated here is available online this time in the exercise four folder within the repo, those particular demonstration will show you how to deploy a fully working end-to-end deployment of a cloud native application. This wave app allows you to vote for your favorite programming language, with the votes being collected and stored in a MongoDB database. The voting data is seen from the front-end to an API using Ajax calls. The API will in turn read and write to the MongoDB database, an auto scaling group of app servers will be provisioned. Each app server will have both the front-end and API components deployed onto it. During provisioning time, each app server will pull down the latest release of the front-end and API components from git hub. Jumping across and to the front-end git hub repay, you can see the source code that makes up the react based front-end, the lightest fronting release that gets pulled down and installed onto the instances will be this one.</p>
<p>Next I’ll pull up the API, git hub repo. This contains the API as used by the vote app. The API is written and go, and as earlier mentioned, provides an interface to read and write the voting data into and out of the MongoDB database. Again, app provisioning time, the app instances, they get launched. We’ll pull down and install the latest release of the API found here. For your benefit, the actual bootstrapping user data script, as used to bootstrap the app instances is documented directly here. It’s encoded within a Terraform team plight cloud and at conflict block, it is used to first install nginix for web serving, then it pulls down the latest front-end release from git hub installing it into nginix default seeming directory, Next, it pulls down the lightest API release from GitHub and starts it up, pointing it at the MongoDB instances assigned private IP address connecting on port 27017.</p>
<p>The next diagram is seen here highlights the application load balances, target groups set up. Here we are seating up two target groups, one for the front-end and one for the API. The front-end target group will listen on port 80 whereas the API target group will listen on port 8080. The application load balancer itself will be configured to listen on port 80 and will forward traffic downstream to either of the target groups based on some forwarding roles that will be configured. More on this later.</p>
<p>The end result is that incoming requests will be layed balanced across the auto scaling group, which spans across two availability zones for high availability purposes. Now from a VPC point of view, the architecture that will build and leverage within this demonstration will again be the same as used in the previous three demonstrations, the VPC will span two AZs and have public and private zones. But this time the VPC and underlying networking components will be declared using AWS’s VPC Terraform module available within the public Terraform registry.</p>
<p>Within this exercise, the key Terraform objective that I want to demonstrate is to show you how to modularize your Terraform configurations. As seen here, the project structure for this demonstration will be the following. When your Terraform configurations become large and complex modularizing them helps to make them more maintainable and readable.</p>
<p>Okay, jumping into visual studio code within the terminal pain are on the tree command to again, highlight the project structure. Here we can see the route modules main.tf file, and then beneath it, we have a modules directory. Within this directory, we have several child modules. We have an application module, a bastion module, a network module, a security module, and a storage module. Back within the root module directory, we also have a variables.tf file, a terraform.tfvars file for default variable values and an output.tf file.</p>
<p>Let’s now take a look at the root modules main.tf file. This is our terraform entry point. Within it, we can see how references to the child modules are made starting with the network module, which has been reflected out to contain all the VPC networking conflict. Next is the security module, this has also been reflected out to contain all of the security grid configuration. Note, that the security module has a dependency configured on the networking module since it needs and references the VPC ID, which is configured as an output on the networking module.</p>
<p>It’s important to note that referencing values from other modules can only be done so if that other module creates an output for it. We can see that this is the case for the network module, by opening up its output.tf file and observing the fact that it has an output named VPC_ID. While in the network module, let’s look at its main.tf file, here we can see that the enclosed configuration is very concise. In fact, it is contained all within a single VPC module block. This is one of the very cool things when working with custom modules. It is your ability to abstract away, a lot of the underlying configuration. In this case, we simply configure the public subnet cider blocks, the private subnet cider blocks. We enable the net gateway seating, and then that’s enough for Terraform to be able to go away and create LVC subnets, routing tables, routing associations, internet gateway, net gateways, et cetera. Using this approach is very clean and super productive.</p>
<p>Okay, let’s return back to the root modules main.tf file. Next stop is the bastion module. This module is designed to launch a jump box, to allow us to connect to the privately zoned instances. Our ASG at fleet and MongoDB database, the bastion will be deployed into the first public subnet and will be secured with the best UN security grape created within the security module. Opening the bastion modules main.tf file, the key configure items to call out are, it explicitly declares the ami ID to be this value, which in this case is an Ubuntu 20.04 image. And that it also requires the instance to have a public IP address automatically associated with it hitting back to the route modules, main.tf file.</p>
<p>Next up is the storage module. This encapsulates the conflict for the MongoDB database, jumping into the storage module and looking inside its main.tf file. We can see a similar conflict to that used for the best year. However, in this case, we obviously don’t need a public IP address assigned to it. The Mongo instance leverages user data to install and configure the MongoDB service onto itself. The user data is pulled in by calling the inbuilt function filebase64, which reads in the contents of the install.sh file.</p>
<p>Opening the install.sh file we can see the commands required to download and install the MongoDB package. We then passed out some configuration to the file system and start up the MongoDB service. We then generate a db.setup.js file containing sample data, which when called upon will used to populate the MongoDB database. Now the setup for our database will be sufficient for demonstration purposes, but in a production environment, you’d likely want to configure a MongoDB and a replica CIT and perhaps have its data volumes stored on EBS provisioned with high ops for better performance, scalability, availability, and redundancy purposes.</p>
<p>Moving back to our root modules main.tf file one last time we have the application module, which contains all resources related to the application itself. In this case, it contains the application load balancer, the auto scaling group, the launch template, et cetera, et cetera. This module clearly has dependencies on the network, security and storage modules. And therefore has these dependencies explicitly declared in the depends on list at the bottom.</p>
<p>Let’s now jump over into the application modules main.tf file. Here we can see that it starts off with a data source of the Ubuntu 20.04 images. This is later reference within the launch template block for the day down in the file. Next up is the template cloud in a conflict resource. This contains the same script documented in the rebate within the exercise for folder. Again, I’ll highlight a couple of the more important parts of this template resource which once rendered is used as user data for the app instances.</p>
<p>On lines 33 and 34 string interpolation is used to embed two environment variables within the script. The first is the application load balances, fully qualified domain name. This is required by the front-end being used to tell the browser where to aim the voting API Ajax requests to. The second is used to configure the API service with the MongoDB databases private IP address, allowing it to know where to read and write data to.</p>
<p>Lines 39 to 51 are used to pull down the latest release of their react based front-end and unpack it unto the default engineer assuming directory. Lines 53 to 62 are used to pull down the latest release of the compiled API. Note how it references the MongoDB private IP address environment variable previously configured on line 34.</p>
<p>Finally, with the fronting and API components installed and ready, the nginix web server is started up. Next up is the app launch team plate. Nothing too special going on here other than the fact that the user data is configured by calling the inbuilt by 64 and code function, which types the rendered output of the previous cloud and a template and retains the base 64 encoded version of it.</p>
<p>Next up is the application load balancer resource. Again, nothing special here to call out other than the fact that it is an application load balancer. Behind the application load balancer are two target groups, one for the front-end nginx web server configured on port 80 with the following health cheat configuration. The second target group is for the API, which has configured to listen on port 8080. The API target groups health check is configured to send its health checks to the &#x2F;ok endpoint specific to the API, the application load balancer is configured with a single HTTP port 80 listener. This is useful both the fronting and API requests on the outside.</p>
<p>On the inside two listener rules are created, one for the front-end HTTP requests, and one for the API Ajax requests, the front-end HTTP listener role forwards to the front-end target group and the API HTTP listener role forwards to the API target group and has a lower priority value of 10, meaning it gets precedence. This has done site that we can detect any incoming API calls as per the condition configuration, and then forward these directly to the API target group.</p>
<p>Moving onto the auto scaling group resource, this is configured in much the same way as it was in the previous demos. The only difference here is that it is configured to register its instances into both fronting and API target groups. Additionally, the auto scaling group references the earlier launch template that was configured and purposely grabs the latest version of it. Finally, a new data sources configured to scan for any easy two instances that are tagged with the following tags, which map exactly to the tags specified in the app servers launch template. We filter all instances, which are either an IP ending or running site. This data source is set up with a dependency on the auto scaling group resource.</p>
<p>Now, the reason for this last data resource is to be able to report back to the terminal, the auto scaling group instances, private IP addresses. Looking backwards, if we first look at the application modules output.tf file we can see that it contains a private_ipsoutput, which references the instance data source mixed going up and out to the root modules, output.tf file we can see that it has an output named application private IPS, which references the application modules, private IPS output.</p>
<p>Okay, let’s now proceed and launch the setup. To do so, I need to first initialize our working directory using Terraform in it, once initialization is complete, I’ll proceed with the Terraform apply command. Okay, fast forwarding to the point where the apply command has now completed successfully. Here, we can say the outputs, including the application load balancer FQDN the application private IPS, the bastion public IP and the MongoDB private IP, I’ll take a copy of the application load balancer FQDN and cool for it to see if we get back a valid response, and so far so good.</p>
<p>Here we are receiving an HTTP 200 response code indicating success. However, the acid test is to call it up within our browser like so, and excellent, how good is this? The Vote App has successfully loaded within the browser. I can vote on various languages, which when I do results in Ajax calls going back to the application load balancer on port 80 and with the application load balancer forwarding them downstream to the API target group listening on port 8080, we can view this traffic by bringing up the browser’s developer tops and capturing the network traffic generated when clicking on any of the Vote buttons. Clicking on the vote network requests, we can then view the HTTP request and response heaters associated with it.</p>
<p>Moving on, let’s take a look at the IWCC two console and view the instances running. Here, we can see four instances, the Mongo database instance, the bastion instance and the two auto scaling group, front-end at managed instances. Peering into the light balances section, we can see our application load balancer. Drilling into the listeners, we have the one port 80 listener configured. Clicking on it’s rule set, we can see the three rules that have been established. The highest priority role is used to capture and re-iterate browser initiated Ajax requests directly to the API target group. The remaining lower priority roles are used to capture all other traffic and route it to the front end target group.</p>
<p>Navigating back to target groups, we can observe both the API target group and the front-end target group. The API target group has configured on port 8080 and the front-end target group is configured on port 80. Drawing into the API target group. We can see that it has successfully registered the two ASG managed app instances, and they’re both of them are in a healthy state, which we require. Then drawing into the front-end target group, again, we can observe the same two instance IDs have been registered successfully.</p>
<p>Next let’s take a quick look at the VPC set up that has been provisioned by Terraform for us. Within the VPC console, we can see the cloud academy nine VPC. If we jump over into the subnets, we see the four subnets, two public and two private. This slide of blocks match those as explicitly configured and widened to the network modules, main.tf file on lines eight and nine. Within the NAT gateways view, if we filter on those that are in an available state, we can see that they are two, one per AZ.</p>
<p>Let’s now jump back into the terminal and we’ll bounce over into the MongoDB instance to review the data that’s been captured within it. To do this easily, I’ll load the cloud academy demo ssh private key into my local ssh agent, and then use ssh- A parameter, enabling at the indication forwarding, and then at the indicate into the bastion host from here, I’ll bounce over to the MongoDB instance like so.</p>
<p>Now that I’m on the MongoDB instance, all far up the Mongo client using the Mongo command or swap into the Lang DB database and then execute the db.languages.fine.pretty command to display the data currently hold in the languages table. And here indeed, we can see that the MongoDB database has captured our voting data that we seem to it. Let’s now generate a few more votes within the browser. And then again check for the capture data back within the database, and excellent the data has been successfully transacted within MongoDB.</p>
<p>Okay, that concludes this demo. As per the other exercises, if you’ve been following along, please don’t forget to perform a final Terraform destroy to tear down your AWS resources.</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>Okay, congratulations. That now completes this course. I’d like to personally thank you for putting time aside to take this course. I trust that you found it, not only informative, but helpful for your AWS Infrastructure provisioning job role.</p>
<p>Finally, I’d like to reiterate any and all feedback that you may have is welcomed. If you have any unanswered questions about this course, or simply would like to see and hear of other related Terraform features, then please reach out, either by our <a href="mailto:support@cloudacdemy.com">support email</a>, as seen here, or simply hit me up on LinkedIn. All right, that’s all for now. Best of luck with your Terraform adventures ahead.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Docker-Certified-Associate-Preview-Exam-Docker-Certified-Associate-DCA-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Docker-Certified-Associate-Preview-Exam-Docker-Certified-Associate-DCA-13/" class="post-title-link" itemprop="url">Docker-Certified-Associate-Preview-Exam-Docker-Certified-Associate-DCA-13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:44:45" itemprop="dateCreated datePublished" datetime="2022-11-19T00:44:45-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 22:24:26" itemprop="dateModified" datetime="2022-11-20T22:24:26-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker-Certified-Associate/" itemprop="url" rel="index"><span itemprop="name">Docker-Certified-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Docker-Certified-Associate-Preview-Exam-Docker-Certified-Associate-DCA-13/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Docker-Certified-Associate-Preview-Exam-Docker-Certified-Associate-DCA-13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<p><object data="Preview-Exam-Docker-Certified-Associate-DCA.pdf" type="application/pdf" width="100%" height="600"></object></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Docker-Certified-Associate-Installing-and-Running-Applications-with-Docker-Enterprise-Universal-Control-Plane-UCP-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/19/Docker-Certified-Associate-Installing-and-Running-Applications-with-Docker-Enterprise-Universal-Control-Plane-UCP-12/" class="post-title-link" itemprop="url">Docker-Certified-Associate-Installing-and-Running-Applications-with-Docker-Enterprise-Universal-Control-Plane-UCP-12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:44:43" itemprop="dateCreated datePublished" datetime="2022-11-19T00:44:43-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 22:24:38" itemprop="dateModified" datetime="2022-11-20T22:24:38-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker-Certified-Associate/" itemprop="url" rel="index"><span itemprop="name">Docker-Certified-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Docker-Certified-Associate-Installing-and-Running-Applications-with-Docker-Enterprise-Universal-Control-Plane-UCP-12/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Docker-Certified-Associate-Installing-and-Running-Applications-with-Docker-Enterprise-Universal-Control-Plane-UCP-12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/274/">274</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
