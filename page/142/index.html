<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hang&#39;s Blog">
<meta property="og:url" content="https://example.com/page/142/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/page/142/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Designing-Azure-Solutions-Using-Platform-Services-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Designing-Azure-Solutions-Using-Platform-Services-13/" class="post-title-link" itemprop="url">AZ-204-Designing-Azure-Solutions-Using-Platform-Services-13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:09:43" itemprop="dateCreated datePublished" datetime="2022-11-14T11:09:43-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:25:42" itemprop="dateModified" datetime="2022-11-20T19:25:42-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Designing-Azure-Solutions-Using-Platform-Services-13/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Designing-Azure-Solutions-Using-Platform-Services-13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Greetings! Welcome to the Cloud Academy Microsoft Azure Design Solutions using Platform Services course! I am delighted to have you join me on what is bound to be yet another educational and delightful adventure into the world of Microsoft Azure. </p>
<p>First I will let you know a bit about myself before I get into the course outline. My name is Jonathan. I am one of the course developers with Cloud Academy. I work professionally as a technical consultant specializing in DevOps, data engineering, and security. I am also a former high school teacher, so it is a treat to get back into teaching all you lovely people about technology.</p>
<p>So enough about me, let’s get into this course. Who is this course for exactly? This course is also for anyone looking to improve their knowledge of Azure platform solutions in the fields mentioned above. If you happen to be a software engineer, a product manager, a CTO, or just someone who happens to be trying to build a product using Microsoft Azure, then this course could save you a lot of time and money as you discover Azure’s powerful product toolset.</p>
<p>So what exactly are the prerequisites for this course then - what do I expect you to know in order to understand the material? Well, not too much actually. You don’t need to be a programmer or have a deep knowledge of computer science. The course will focus mostly on explaining Microsoft Azure systems and how to use the Azure user interface. You should have a general understanding of the domains related to each product category. You will need a basic understanding of terms like “Internet of Things,” “Machine Learning,” “Messaging Queue,” and, “File Encoder.” If you have no idea what any of these things are, this course may be premature for you.</p>
<p>The course will cover a lot of information given its short length. We are going into detail on a number of Azure services and practices. Our goal is to explain in depth each Azure service and ensure that you have a stronger understanding of which service to choose to solve a particular problem. After going through all of the content, you should have a thorough grasp of several Azure products. You should be ready to start creating products in any of the four domains described above. </p>
<p>So as you may have gathered, there are four core learning objectives - takeaways, if you will: 1. The student will have an in-depth knowledge of Azure artificial intelligence services and know when to opt for specific offerings. 2. The student will have an in-depth knowledge of Azure IoT services and know when to opt for specific offerings. 3. The student will be able to design a scalable messaging architecture using Azure services. 4. The student will have a deep understanding of Azure media services.</p>
<p>Lastly, I want to encourage everyone to leave feedback. Email <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a> if you have any questions, comments, suggestions, or concerns. We always appreciate people taking the time. Now without further ado, let’s get started.</p>
<h1 id="Section-1-Introduction"><a href="#Section-1-Introduction" class="headerlink" title="Section 1 Introduction"></a>Section 1 Introduction</h1><p>We have divided section one, focusing on AI and machine learning, into two parts. The first part will give a thorough survey of Microsoft Azure’s machine learning solutions. We’ll explain what problems each solution solves and explain in-depth how to actually use them. The second part of this section will focus on specific use-cases. We will offer several examples of problems and show how a specific Azure machine learning solution can help.</p>
<p>So without further ado, let’s get right into it with an overview of Azure artificial intelligence products.</p>
<h1 id="Azure-Artificial-Intelligence-Services"><a href="#Azure-Artificial-Intelligence-Services" class="headerlink" title="Azure Artificial Intelligence Services"></a>Azure Artificial Intelligence Services</h1><p>‘Artificial Intelligence’ and ‘Machine Learning’ are related terms that until now I have used somewhat interchangeably. It is worth explaining the exact difference before we start talking about Azure products. Artificial Intelligence, or AI for short, refers to intelligent decision making performed by non-living agents such as computers. Machine Learning, also called ML, is the science of teaching computers to improve at specific tasks by using algorithms that cause the computer to ‘learn’. With some reflection, it should become clear how AI and ML are related. Machine learning is one of the core disciplines that powers AI.</p>
<p>AI and ML power a number of software applications. Apple’s Siri personal assistant is an example of AI. She has to intelligently respond to user questions and provide useful answers. Machine learning is what powers Siri’s understanding. Siri’s understanding of language comes from training against thousands of hours of audio of human conversations. This training fuels her intelligence - her ability to understand what a human is asking for and how to properly respond.</p>
<p>With Microsoft Azure, you get a number of services that can help you to build similar systems that employ machine learning and AI. They are all listed under the Azure Artificial Intelligence category. As you can see there are several products as well as a number of command-line tools, frameworks, SDKs, and extensions. We will not go in-depth into every single offering this course. Instead, we will cover some of the most important products and then in the next lesson talk about which services solve specific problems.</p>
<p>Just to further emphasize the scope it is worth mentioning that Azure also has a large set of Analytics services (<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/#analytics">https://docs.microsoft.com/en-us/azure/#analytics</a>). These include tools like Data Catalog and Azure Stream Analytics. You can see the entire catalog using the link below. This course will only very briefly mention Azure Analytical tools where they may help differentiate use cases. In general, however, they are out of scope for this course, as data analytics is a distinct domain from AI. The science of analytics is about deriving useful information from your data. By contrast, AI is about putting that data to work in some intelligent way.</p>
<p>So for our purposes, the best place to start is with Azure Machine Learning. This is Azure’s flagship product for anything related to ML. As you can see from the diagram the Azure Machine Learning studio does A LOT. Once you import your data, you have a lot of tools for processing, cleanup, visualization, and model training. You can easily shuffle and split your data into training sets and test different learning algorithms. You also get great third party support for things like Jupyter notebooks and Hadoop.</p>
<p>Making use of Azure Machine Learning requires a solid knowledge of data science and programming. It integrates with a number of systems and APIs such as Spark, Docker, Jupyter, Kubernetes, TensorFlow, and many others. The platform itself is actually built on top of many of these systems. See the slides here for a more exhaustive list.</p>
<p>Azure also has a separate related product called Machine Learning Studio. Unlike the core Azure Machine Learning platform, Studio is a drag and drop service with a narrower focus. It is designed to simplify creating predictive tools on top of an existing data set.</p>
<p>Cloud Academy has an in-depth course focused solely on Azure Machine Learning Studio. I recommend going and checking that out if you want to get really thorough walkthroughs and explanations. For our purposes, the high level overview and diagrams should be enough to get you started.</p>
<p>Now Azure has another powerful offering in the algorithm training space called Azure Batch AI. There is a lot of overlap in Batch AI with Azure Machine Learning so to simplify we are going to focus on the differences. Batch AI, somewhat like Machine Learning Studio, is a more comprehensive ML solution. It offers ML job scheduling and resource coordination. To this end when you create a Batch AI job, it will take as an input a description of your cluster, which are the resources, and your job, which is the task. The cluster input is really just the hardware, so basically you will tell Azure how many VMs you need, what type, what disk image to use, what region, and what remote storage to access for the data. The ML job description will reference the cluster you just defined and also take other inputs such as a particular AI framework, command-line arguments, VMs, and input or output directory locations.</p>
<p>Batch AI, as the name implies, is better suited to one-off jobs of a larger scale. While it can be incorporated into a long-lived application stack, you may be better off with something more configurable such as Azure Machine Learning.</p>
<p>Azure also has a service that covers both analytics and ML for people with a background in Apache Spark. It is called Azure Databricks. Databricks is an “Apache Spark-based analytics platform optimized for the Microsoft Azure cloud services platform.” It incorporates the entire set of Spark open-source APIs and services including Spark streaming, Spark ML, SparkSQL, and GraphX. So if you have some expertise with Spark or an existing Spark codebase, Databricks may be the way to go. Setup is similar to Batch AI. You go into the portal and create a Databricks workspace. You define your cluster resources and your Spark job. Clusters can be configured to live only for a set amount of time to reduce costs as well. Thus in short, Databricks is basically just “easy mode Spark” for Azure.</p>
<p>The last big offering Microsoft Azure Cognitive Services are, “a set of APIs, SDKs, and services available to developers to make their applications more intelligent.” In short, Cognitive Services refers to a set of ready to use AI tools that you can add to an existing application. They include things like image classifiers for faces and text analysis tools for automatic phrase completion and search. To make use of these tools you need to create a Cognitive Services API account in the Azure portal. This is easy to do with a few clicks. You can even get a free account if your transactions are below a certain threshold per month.</p>
<p>In the final part of this section, I’ll just briefly mention some AI products with a narrower focus. There is Microsoft Genomics, a tool for people working with gene sequencing. I know precious little about genetics so I won’t even try to explain the use case. Suffice to say if you are working in that field you should check out the Microsoft Genomics documentation linked below. There is also the Azure Bot Service. This is basically a toolkit for creating interactive agents such as chatbots. You can create a wide variety of bots by training them to respond in specific ways to different inputs. The Bot Service is also serverless, so you don’t need to worry about administration, which is nice. And finally, there is also Azure Search. As the name implies this is Search as a Service.</p>
<p>So that about wraps up our discussion of Azure AI services. You should have a good broad understanding of each offering. In our next lesson, we will start talking about how to pick the right AI tool for your specific needs. See you there.</p>
<h1 id="Choosing-the-Right-A-I-Service"><a href="#Choosing-the-Right-A-I-Service" class="headerlink" title="Choosing the Right A.I. Service"></a>Choosing the Right A.I. Service</h1><p>Knowing which Azure AI service will fit your needs first requires understanding the problem you are trying to solve. While there is considerable overlap in what the different solutions can do, you can save yourself a lot of stress by picking the optimal product from the start.</p>
<p>Fortunately, some Azure AI services are quite narrow in focus. They should stand out if your needs are in that particular domain. The three I am referring to here are Azure Bot Service, Microsoft Genomics, and Azure Search. If you are looking to create a bot that interacts with users, work on sequencing genomes, or create a tool for searching heterogeneous data, then you should know where to turn.</p>
<p>The challenge comes when you have a more open-ended or nuanced problem. For example, let’s say your company has accumulated a lot of data over time and wants to see if there may be some value in analyzing it. This is a broad question that requires a deep understanding of both your business and the data itself. Which Azure data-related solution will offer the most value? Perhaps you could create some sort of facilities or office automation system using Azure Cognitive Services. Or perhaps you could make predictions about visitors to your site by using Machine Learning Studio. Or perhaps you really want to run large scale ETL operations on your data for some brand new business case or software service.</p>
<p>There is a more general point I am trying to make here with all of these hypothetical examples. Big data and machine learning are popular terms today. Often they can become solutions looking for a problem. In many cases, companies really have no practical need for investing the time and resources needed to make use of machine learning technologies, even in cases where you have relatively easy to use solutions in Microsoft Azure. So really, the first question to ask when trying to figure out which Azure AI solution to use is, “Do I actually even need to get into ML and big data analysis at all?” Smaller companies in particular can often get more value with less effort out of a few smart employees working with Excel.</p>
<p>But let’s say you have crossed that threshold and have a strong business case for digging into Azure’s more comprehensive solutions. The way to determine which tool is relevant is to first clarify your understanding of the problem you are trying to solve.</p>
<p>If you are in a very early stage where the work is exploratory meaning there is no clear desired outcome or deliverable, then what you want is something that can just give you insight into your data. This is not what Azure Machine Learning services or studio are really designed for - rather ML is more about using data to predict something. In this scenario, you do not even know what you want to predict. You would be better off using one of Azure’s many analytics services such as Data Catalog, Data Lake Analytics, Stream Analytics, or Azure Analysis Services.</p>
<p>Once you have narrowed down the problem to being of a specific type, now you can start thinking about Azure AI solutions. For example, if you know you want to make some kind of prediction by training an algorithm against data, then Azure Machine Learning is the way to go. The specific choice of whether or not to use Machine Learning Studio or not really depends on the state of your data and data science team. As Studio is a “drag and drop” system it is not going to be as flexible as Azure Machine Learning Services which gives you more control over how you prepare your data. If you are doing more resource-intensive training work on a more complex or long-range data science task, you should consider Azure Batch AI.</p>
<p>As implied early Azure Data Bricks is the best solution for ETL, especially if you have some familiarity with Spark. Lastly, Azure Cognitive services is for when you are ready to take the results of your analytical work and incorporate it into an application.</p>
<p>So to summarize, ask yourself what you are trying to do with your data. Do you want to make a prediction? Look at Machine Learning services. Do you want to transform data into some more usable form? Check out Data Bricks. Do you want to incorporate some understanding of your data into an app to make it more intelligent? Try Cognitive Services. And finally, if you are unsure of exactly what you want to do, first ask whether or not you need any AI service at all and consider using Azure Analytics Services to get a better understanding of your data.</p>
<p>So that about wraps it up for section 1. Congrats on making it this far. We’re going to continue on now with a few lessons on Azure and the Internet of Things. It should be a blast. See you there.</p>
<h1 id="Section-2-Introduction"><a href="#Section-2-Introduction" class="headerlink" title="Section 2 Introduction"></a>Section 2 Introduction</h1><p>The “Internet of Things.” A curious name for a curious phenomena. It may seem like a silly meme but believe it or not, IoT, or Internet of Things, is a big deal. We’re going to talk about why it is a big deal in this section and we’re going to talk about how Azure can help you make use of it.</p>
<p>The first lesson will talk about exactly what IoT is. It is a short concept lesson. Feel free to skip if you feel like you already know it well. The second lesson will be long and dense. We’re going to go cover several different Azure technologies all related to IoT. There will be a lot of documentation links and useful diagrams. Plan accordingly. The third and final lesson in this section will be all about ensuring you understand WHEN to use which IoT service over another. Should not be too tricky.</p>
<p>So without further ado, let’s dive into that wonderful world of the Internet of Things.</p>
<h1 id="IoT-Concept-Explanation"><a href="#IoT-Concept-Explanation" class="headerlink" title="IoT Concept Explanation"></a>IoT Concept Explanation</h1><p>Get ready for a super short lesson that is completely skippable if you already know the subject. All we’re going to do is briefly define exactly what we mean by, “Internet of Things,” or “IoT.”</p>
<p>Now, a lot of people, when they hear the term “Internet of Things,” immediately get a very superficial image. They imagine cheesy home automation gadgets, like an internet-connected talking toaster. Due to the dubious value of many trendy items billed as “IoT,” there is an unfortunate tendency to be dismissive of the term.</p>
<p>In reality, “Internet of Things,” refers to a much more consequential and larger trend. The Internet of Things refers to a historically recent growth of internet access and network-connected devices in all manner of fields. So when we talk IoT, we’re not just talking toasters. We’re also talking about agriculture, solar power, elderly care, transportation, and manufacture. We’re talking about internet-connected cameras and audio sensors deployed by municipal police to combat crime. We’re talking about internet-connected crop watering systems that let farmers automate much of their work and generate larger crop yields. We’re talking about a massive new economic opportunity creating jobs and new fields of technological inquiry. We are talking about all of the ways cheaply adding internet access to everyday devices creates new opportunities to make our communities safer, our lives easier, and our work more intelligent and efficient.</p>
<p>IoT is not just a meme. It is one of the few truly futuristic technological developments that will push us toward living the George Jetson &#x2F; Back to the Future lifestyle we’ve all dreamed of since we were kids. IoT is a natural consequence of computers getting smaller and high-speed internet access getting cheaper. Thousands of startups are exploiting new business opportunities as a result. With the right vision, it could be a great opportunity for you as well.</p>
<p>So that is all you really need to know at the conceptual level. So now the natural question is, “Where does Azure factor into all of this?” Well, to make IoT work, you need the right software infrastructure. Azure has many tools in place to simplify setup of IoT systems. In the next lesson, we will take a thorough survey of these technologies. So if you’re ready, let’s dive in. Good luck.</p>
<h1 id="IoT-Azure-Technology-Review"><a href="#IoT-Azure-Technology-Review" class="headerlink" title="IoT Azure Technology Review"></a>IoT Azure Technology Review</h1><p>Internet of Things software infrastructure is all about messaging and events. In the next major section, we will do a deep dive on messaging infrastructure in Azure. For this section all you need to understand is that messages between IoT devices and the cloud backend are used to transmit events. These events could be temperature measurements from an IoT thermostat, humidity readings from an IoT greenhouse monitor, a configuration change for an IoT home light switch, or any other sort of data transmission.</p>
<p>So how do we handle these events efficiently? Well, you could build our own event handling system using something like Apache Kafka. If you have the expertise in-house, this could work well, but it will take time and effort.</p>
<p>Here is where Azure comes in. Azure has a number of different solutions for managing IoT events. We’re going to talk about event handling in two parts. First we’ll talk about initial event ingestion and processing. That will entail an explanation of three core Azure technologies - Azure Event Hubs, IoT Hub, and Azure Service Bus. Next, we’ll talk about actually using the ingested event data both by end users and our backend services. Relevant technologies here are Azure Notification Hub, Azure Stream Analytics, and Azure Event Grid.</p>
<p>So let’s start with event ingestion. Azure Service Bus, Event Grid, and IoT Hub are all capable of ingesting events - they just go about it in different ways. Service Bus is the more generalized solution. It is not strictly speaking an event ingestion system. Rather it is a managed message broker. Like Kafka or RabbitMQ, Service Bus is designed to decouple applications and services from each other with a reliable system for asynchronous state transfer.</p>
<p>Not all messages are events but all events are messages. Again, we’ll dig into the concept of messages in section three. Service Bus can do much of what IoT Hub and Event Hub can do, only it is not specialized around events or IoT. It doesn’t integrate with all of the same Azure services as well. As you can see from the documentation link, whatever your needs, Service Bus can likely accommodate you. The enterprise level support and security make it great for sensitive data like financial transactions. What’s more it has strong library support for .NET as well as Java and JMS.</p>
<p>Service Bus really shines when you need to support a variety of state transfer paradigms. Perhaps you need transactions that let you group operations together. Perhaps you need batching, or scheduled delivery of messages.</p>
<p>However this whole section is on IoT, and as we discussed IoT is focused on events. While Service Bus can serve as our main event ingestion system, it would require more development knowledge to get it to do everything we want. To make it easier for us to focus on events and in particular IoT, Azure offers IoT Hub and Event Hubs.</p>
<p>You can think of IoT Hub as a specialized version of Event Hub. Event Hubs act as the “front door” for your data. As you can see from the diagram, event data can come from a range of sources. End user devices, laptops, phones, tablets, software applications, devices, clients - all kinds of things can transmit event data. They need a place to send that data to - an endpoint essentially that speaks their language and understands the event data it is receiving.</p>
<p>So as an event ingestor Event Hub will have a few responsibilities. It has to validate that event data is properly formatted. It will use SAS tokens to identify and authenticate the event publisher. It will capture data and store it in an Azure storage service if needed. Even nicer: Event Hub can scale with your app. You control traffic using throughput units that can handle a certain number of MB per second. You can manually scale through the portal or enable auto-inflate to let Azure scale for you.</p>
<p>So what about IoT Hub? Why pick it over Event Hub? To add to your initial skepticism, know that IoT Hub is more expensive than Event Hub. So why go to the trouble and cost of using it instead of Event Hub or Service Bus? Simple: It provides functionality for IoT workloads that you won’t find anywhere else.</p>
<p>With IoT Hub you get the ability to not only ingest data from clients but also to easily push data back to those same endpoints. This can be hugely valuable for managing IoT devices. You get access to the Azure IoT Edge system that enable on-device data processing for analytics, app changes, configuration, and security. IoT Edge in particular is very powerful from some use-cases as we’ll see in a bit. Key takeaway is that IoT Hub is like Event Hub on steroids…Magic steroids that grant powers for IoT…Anyway, see the chart for a proper feature comparison.</p>
<p>(link comparing IoT Hub and event Hubs: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs">https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs</a>)</p>
<p>So now that the event data has been ingested either using Service Bus, Event Hubs, or IoT Hubs, we want to do stuff with those events. Most likely we want to do one of two things. We either want to pass those events on to some other service to power our application or business logic, or, we want to immediately start analyzing that data directly and start deriving insights.</p>
<p>So let’s start with the former case. How can we easy mobilize all of this ingested data? Azure Event Grid is the answer. Event Grid is basically a managed intelligent routing service that consumes events in a publish-subscribe model. So take a look at the diagram here. As you can see Event Grid is basically a middle layer between your event ingestion systems and your downstream services.</p>
<p>You can see it supports Service Bus, Event hubs, and IoT Hubs as topics for ingestion. However it can also take in data from other Azure components such as Media Services and Blob Storage. The services that will then subscribe to your Event Grid will depend on your infrastructure. So for example you may have an Azure Function or an Azure Logic App that is powered by event data pulled from an Event Grid subscription. Your app then takes that event data, which may have originated from some user activity, and then return some output or value to the end user.</p>
<p>Event Grid is easy to set up using the Azure portal. All you need to do is define a topic and give it some input - perhaps your IoT Hub or Service Bus. Then on the other end you create a subscription. For something like an Azure Function this is as easy as clicking “Add Event Grid Subscription” in the top right of the UI. Event Grid can also be managed using Azure CLI tools or PowerShell.</p>
<p>Now let’s say that instead of piping our events to some other system we would rather process them directly to derive useful insights. Here is where Azure Stream Analytics comes in to save the day. If you look at the diagram you can see that, much like Event Grid, Stream Analytics act as as a kind of middleware. It takes streams of event data from Event Hubs or IoT Hub as an input, performs some processing, and then outputs to some downstream consumer.</p>
<p>Exactly what Stream Analytics will do for output will vary based on your business. You might want to save Stream Analytics outputs to a DB for storage or batch jobs. You might push the results to Service Bus, an Azure Function, or even to another Event Hub. It all depends on the type of job you are doing. The key thing that distinguishes Stream Analytics from Event Grid is the ability to visualize and utilize data immediately from the source pipeline. This is helpful when you want to make sense of telemetry data, send alerts based on sensor readings, or trigger some other backend functionality based on a real-time understanding of the data.</p>
<p>So with Event Grid and Stream Analytics we have covered how we can use event data for our purposes by either coupling events with other services or doing real time analytics. But what about if we want to use event data on the client side? How can we do useful work away from the cloud or even just interact with clients and users?</p>
<p>This is where Azure Notification Hubs and IoT Edge come in. The former is ready made smart device notification solution. Need to send push notifications to iPhones, Android phones, or tablets? Notification Hubs is your answer. The great thing about it is that it takes away a lot of the pain involved in supporting a variety of mobile devices. If you have experience as a mobile developer then you’ll really know what I am talking about. Unlike other forms of messaging, push notifications often have tricky platform-dependent logic. Scaling, managing tokens, and routing messages to different segments of users on different hardware and different versions of Android is non-trivial work for even an experienced tech team.</p>
<p>Notification Hub takes away most of that pain. It lets you broadcast to all platforms with a single interface. It can work both in the cloud or on-premises and includes security features like SAS, shared access secrets, and federated authentication. See the “How To” guide link for more details. (<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-cross-platform-notification">https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-cross-platform-notification</a>)</p>
<p>Lastly we need to talk about IoT Edge. IoT Edge is a tool for empowering IoT devices. It lets you run code directly on client devices instead of in the cloud. So you can do things like change device configuration, get real-time analytical data, or detect anomalous conditions. The chief value of doing such work directly on the device is that it saves the effort of having to send event data back and forth over the internet. So for example, we might want an IoT home sensor to alert us to some unusual condition without having to phone home to the cloud to run analysis. You can imagine how valuable this could be for something like an IoT smoke detector or security system. IoT Edge can also empower devices where network connectivity is not always reliable.</p>
<p>So how exactly does IoT Edge let you run code on the device itself? It’s pretty ingenious actually. What you do is install an IoT Edge runtime on your client device. This runtime executes IoT Edge modules. These modules are just lightweight Docker containers that run whatever business logic you want. Modules can call other Azure services, run 3rd party software, or execute your own custom code. Whatever it is you need your device to do. The IoT Edge runtime will manage your modules, track module health, facilitate communication with downstream itself and other endpoints, and manage security. Best of all: You can track all of this activity in the Azure web portal. With a few clicks you can monitor device health and push updates or configuration changes. IoT Edge gives you ultimate control over your entire fleet of IoT devices.</p>
<p>IoT Edge does not integrate with Azure Event Hub. To properly make use of IoT Edge you need an IoT Hub account. Note that with the IoT Hub basic tier account, you can only use IoT Edge for testing and evaluation. You need a paid IoT Hub Standard tier account to get proper support for IoT Edge production use cases. As mentioned above this is what enables the cloud-to-device messaging that powers IoT Edge.</p>
<p>So that about wraps it up. We have gone over all of Azure’s offerings in the IoT space. You should know enough now to be dangerous. To really solidify your understanding, play around with some of these tools in the Azure portal or at least read some of the quickstart and how-to guides in the Azure documentation. So for our next section we’re going to offer some additional insight about selecting the right IoT Azure service for your particular use-case. See you there.</p>
<h1 id="IoT-Azure-Technology-Selection-Insight"><a href="#IoT-Azure-Technology-Selection-Insight" class="headerlink" title="IoT Azure Technology Selection Insight"></a>IoT Azure Technology Selection Insight</h1><p>The third and last part of our section on Azure IoT services is really meant for reinforcement. We’re not really presenting anything new about the services we discussed in the last section. Rather we’re just going to briefly talk about what differentiates the services to help you understand when to favor one solution over another.</p>
<p>We’ll start with the more specialized technologies with narrower use-cases. This covers Azure Stream Analytics, Azure IoT Edge, and Azure Notification Hubs. Let’s begin with the last one. Notification Hubs, as the name implies, is for sending notifications to mobile devices. That’s basically it. Notification Hubs is a Push Engine and API for notifications. Azure Stream Analytics is your toolkit for real-time analytics on event streams. So if you are looking to gain some business insight on streams of data, that’s where to look. Finally, IoT Edge is for implementing data analysis and processing directly on your IoT devices. Basically it is a method for taking workloads off of your backend allowing you to send fewer messages back and forth.</p>
<p>So now we’re left with four key IoT services: Event Grid, Service Bus, Event Hubs, and IoT Hub. Now of these four, one of these things is not like the other. For the folks playing at home, that would be Azure Event Grid.</p>
<p>Event Grid is NOT an event ingestion or processing system. Rather it is middleware meant to help you create applications with an event-based architecture. It is designed to help connect sources of event data to different endpoints or event handlers. So for example it can take event data from Service Bus or IoT Hub and connect it to your Azure Functions to create a serverless application stack. So think of Event Grid as the glue that connects your event data and downstream applications.</p>
<p>So finally, the remaining three services, Azure IoT Hub, Azure Event Hubs, and Azure Service Bus. All three can be used for event ingestion and processing, so how do we know which one to use?</p>
<p>I think the easiest approach is to think of them in terms of decreasing levels of specialization. So, Azure Service Bus is the most general purpose of the three. It is a cloud messaging service that can be used not only for events but any sort of asynchronous FIFO messaging system. If you are not even thinking in terms of events Service Bus may be the place to start. It also is great when you need ACID guarantees, meaning you need real transactions that are durable and won’t get dropped. This is especially important when dealing with temporal transactions with things like finance or manufacturing.</p>
<p>From there we go to Azure Event Hubs, a more specialized service than Service Bus. This is really your event “on ramp” for your entire infrastructure. It is definitely Azure’s most cost-effective and performant event handling system at scale. IoT Hub, by contrast, is more expensive and specialized even more. IoT Hub is designed specifically for IoT workflows. It allows for greater control of bidirectional events between devices and your backend system.</p>
<p>So in short, if you need something specialized for IoT and don’t have to be super tight on budget, IoT Hub is the way to go. If you need a more generalized event handling system that is extremely robust and competitively priced, go with Event Hubs. If what you really need is messaging with transactions and durability, go with Service Bus.</p>
<p>So that should about cover it all. Hopefully, now you have a clear sense of which service is best for a variety of situations. This will help for technology professionals trying to design a solution using Azure. From here we will move on to section 3 and get into the magical world of messaging. See you there.</p>
<h1 id="Section-3-Introduction"><a href="#Section-3-Introduction" class="headerlink" title="Section 3 Introduction"></a>Section 3 Introduction</h1><p>We talked all about event handling in the last section and I explained that events are a type of message. Messages are the more general concept. Messages are data - encapsulations of system state transmitted electronically. They may be text, binary, or some other format.</p>
<p>Messaging infrastructure is a big field in the world of cloud-based applications. It is an integral part of most SaaS (software as a service) systems. At some point, data about the state of the system at one point will need to be transmitted to some other system. Your user signup service will need to take new account data, transmit it to some storage, and then perhaps some other service will need to use that data. How do we efficiently move data around in systems with potentially many services? How do we coordinate between services that push data somewhere and services looking to subscribe and receive data from somewhere?</p>
<p>This is the essence of messaging systems. There are numerous technologies that have come about to try to solve this issue. On the one hand you have message queues like RabbitMQ. There are also more robust systems like Apache Kafka and Ignite.</p>
<p>We’re going to cover Microsoft Azure’s messaging solutions in this section and talk about the specific use-case of push notifications on smart devices. Now, some of this will be review, as we talked about some of these solutions while covering events in the context of IoT. I will try my best to not repeat myself too much, but if you decide to watch the video at 2x speed when I am covering Azure Service Bus for a second time, I won’t be offended.</p>
<p>So before we do our technology review and go about creating a push notification system, we are going to talk a little bit about messaging more generally. If you’re ready, let’s dive in.</p>
<h1 id="Messaging-and-Push-Notifications"><a href="#Messaging-and-Push-Notifications" class="headerlink" title="Messaging and Push Notifications"></a>Messaging and Push Notifications</h1><p>Messages are one of the fundamental building blocks of software systems. So what exactly is a ‘message’? At a basic level, messages represent system state. Messages have a sender and a receiver. A typical message will be formatted with a body, representing its content, and additional metadata for things like origin, destination, authentication, authorization, timestamp, and encryption. Messages can come in the form of sensor data from an IoT device. They can come from user input on a website or game. They can be generated by an analytics pipeline outputting the results of some workflow to a downstream system. The key thing to understand is that messages represent real world information. For that reason we have to treat them carefully. We have to care about order and we can’t afford to drop them.</p>
<p>This is why software teams are so wary of making changes to servers that deal with ingesting or storing messages. If you have ever worked for a startup, you may have had this experience. Your deployment system, say Amazon Cloud Formation or something like it, is really great for stateless services that can be torn down and relaunched without losing data. But once something stateful needs an upgrade, something like a database, or Redis, or Kafka, things get sticky.</p>
<p>To reduce the pain, good messaging systems should have a few features. They should be resilient. They should be scalable. They should be capable of carefully tracking message order. They should have good security. And finally, they should be easy to integrate with various clients - both consumers and producers of messages. Now, just for clarification, by “resilient,” I mean that you need a messaging system that can survive minor failures. You want something that can be deployed on multiple servers and possibly across multiple regions. By “scalable” I mean that you need something that can process messages quickly and can be easily expanded by adding more hardware if necessary.</p>
<p>Apache Kafka meets all of these requirements. An internally developed proprietary system in theory could do. Now, happily, you can also save yourself some time by using Azure’s messaging solutions and get all of the above features right with your Azure account.</p>
<p>So now that we have some context around messaging and messaging systems, I want to briefly go over push notifications. Push notifications are messages that pop up on mobile devices, usually in the upper area. They look like SMS text messages but are transmitted via the internet only to users of the relevant app. So when you send a message to someone via Google Hangout or Facebook Messenger, the little notification that person receives is a push notification.</p>
<p>Push notifications are an integral part of any cloud based software application. They are one of the key ways we can alert users to important changes and solicit critical user feedback. Being able to create a stable, performant push notification system is an extremely useful skill if you are on a development team. And that, my friends, is precisely what we’re going to do in the coming lessons.</p>
<p>So, now that we’re all up to speed on messaging and push notifications, it’s time to take a deep dive into the world of Azure messaging solutions. Good luck and see you there.</p>
<h1 id="Azure-Messaging-Technology-Review"><a href="#Azure-Messaging-Technology-Review" class="headerlink" title="Azure Messaging Technology Review"></a>Azure Messaging Technology Review</h1><p>Now that you have some context around messaging systems and push notifications we’re going to do a thorough survey of the relevant Azure solutions. Some of them you likely already know. We covered several in the previous section. Others we have covered in other Cloud Academy courses. For this lesson, we will do a short review of those technologies covered in the section on IoT. The other technologies that have not yet been introduced in this course will be covered after that.</p>
<p>So let’s start with a brief review of Azure Event Grid, Azure Event Hubs, Azure Service Bus, and Azure Notification Hubs. Azure Event Grid, as you may recall, is an intelligent event routing system. It takes, as an input, some event source, such as IoT Hubs or blob storage, and connects it to a downstream service such as Azure Functions or Logic Apps. It is not meant for message processing or ingestion but rather relaying. Azure Event Hubs, like IoT Hub, IS an event ingestion system. It can be used to ingest generic messages since events are a type of message, however, it is optimized for an event-based use case. It is designed to be extremely scalable and performant. With the right configuration, you can ingest literally millions of messages per second.</p>
<p>Now as for Azure Notification Hubs, which we talked about for IoT, we’re actually going to give it its own lesson.</p>
<p>So that leaves Service Bus for review. Azure Service Bus is probably most directly relevant to this section as it is indeed designed for generic message handling. Service Bus is more than just a queuing system that supports publish&#x2F;subscribe based approaches. As you can see in the comparison below it is a “high-value enterprise messaging” system. Similar to Kafka, it can use topics for sending and receiving messages. Topics can have multiple subscriptions making it easy to scale horizontally.</p>
<p>Now as we discussed previously Service Bus has a number of additional features that make it more robust than just a typical message queue. You get durable transactions, scheduled delivery, dead-lettering for messages that cannot be delivered - you can store and process them later - you also get client-side batching options, filtering for subscription rules to ensure downstream consumers only get specific messages, message duplicate detection, and some handy security features including role-based access control and SAS aka shared access signatures.</p>
<p>So, whew! That’s a lot that it can do. It may seem like Service Bus should then be your go-to solution for messaging with Azure. Mmm…not quite. There are tradeoffs with Service Bus that we will discuss when we start talking about the other messaging solutions later in this section.</p>
<p>One other important thing we need to cover before moving away from Service Bus is Azure Relay. This is a very important component of the Azure product line that has gone under significant change and is directly related to the Service Bus overall platform. At a high-level Azure Relay is a system for connecting corporate enterprise networks to the wider public cloud, without the need to open firewalls or make changes to corporate network infrastructure. If you have had to work with corporate network security with Windows, you may already be familiar with WCF relays - Windows Communication Foundation, that is. WCF is the legacy relay for enabling remote procedure calls securely. Azure Relay subsumes this feature and offers a second feature known as Hybrid Connections.</p>
<p>So what’s the difference between WCF and Hybrid Connections. Well to start, see the chart here. Hybrid Connections is actually an open-protocol evolution of the WCF relay approach. It can be implemented in any language with WebSockets support. Its feature set is entirely based on HTTP and WebSockets. To set it up all you need to do is define a relay namespace in your Azure account.</p>
<p>Now we don’t need to get into the nitty-gritty technical details of how Azure Relay implements all of this. The diagram should give you some idea and we’ve included a link to the documentation for people that want to know more. The key thing is to understand the problem it solves: Allowing your messaging system to safely connect traffic from the public internet to an on-premise or corporate network. (<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/service-bus-relay/relay-what-is-it">https://docs.microsoft.com/en-us/azure/service-bus-relay/relay-what-is-it</a>)</p>
<p>Now let’s get into the as yet uncovered messaging solutions. We need to talk about Azure Storage Queues, Azure Functions, and Azure Logic Apps.</p>
<p>Let’s take them in order. Azure Storage Queues are the most popular message queuing system within Azure. This is because of their incredible simplicity and flexibility. All you need is an Azure storage account and you can begin creating queues of work to process asynchronously. Using HTTP or HTTPS calls you can process millions of messages from a single queue. The two limitations to keep in mind are 1. The total capacity of your storage account and 2. Individual messages in a queue can only go up to 64 KB in size. Service Bus, by contrast, supports messages from 256 KB up to 1 MB in size depending on your tier. Even with these restrictions, Azure Storage Queues are usually better for most simple message queue use cases. They are simpler to configure than Service Bus and often cheaper. They also have wider library support as there are Azure storage libraries for C++, Python, Ruby, PHP, Node.js, and Java, as well as PowerShell and .NET.</p>
<p>Now, one tradeoff is that Azure Storage queues do not give you the same ordering guarantees as Azure Service Bus. You get an “at least once” delivery guarantee and have to make sure your app has logic to properly order operations and transactions. For this and other reasons Storage Queues are generally better for simply managing messages within your Azure app. See the detailed comparison in the slide here. As you can see there are a number of feature differences between Storage Queues and Service Bus. So thinking about use cases, if, for example, you are dealing with backend worker processes that need to communicate with frontend services, all within an Azure infrastructure, Storage Queues would probably work fine. In this use case, the overhead of Service Bus is likely unnecessary. Once you need to start integrating with external apps and you need more guarantees and real transactions, Service Bus may be the better way to go.</p>
<p>So now let’s switch gears and talk about Azure Functions. If you’re familiar with Amazon Lambda then you already have a basic idea of Azure Functions. They are a service for executing “code on demand.” They are not a message queue or ingestion system. Rather they are for processing messages coming from some other source. So often you will have something like an Event Hub or Service Bus act as an input to an Azure Function. The function takes the message, executes some code to process it, and then outputs it to some other endpoint based on your architecture. Functions are ‘pay per use’ in terms of pricing and super easy to scale; since they are serverless, Azure will do all of the scaling for you.</p>
<p>So how do we actually use an Azure Function? The basic approach is to set triggers. As you can see here there are many kinds of triggers. A Function can be triggered by messages arriving in an Azure Storage Queue, or an Event Hub, or Service Bus. Functions can also be triggered by HTTP requests, Github webhooks, timers, and other generic types of webhooks. You get a range of options and strong integration with Azure services like Event Grid, Notification Hubs, Cosmos DB, and Azure Storage. So if you’re application logic - your startup’s “special sauce” - can be easily translated into discrete code calls to be run as an Azure Function, this may be the simplest and most scalable paradigm for message processing available.</p>
<p>Finally, let’s talk about Azure Logic Apps. Logic Apps are a tool for automating workflows in Azure. So what exactly is a workflow? Well, a workflow is just a business process broken down into a series of steps. It may involve grabbing data from storage, executing a function, posting a message somewhere, sending an alert, firing an email, etc. etc. What Logic Apps do is allow you to automate these workflows and add, surprise surprise, logic! This means you can add conditions - you can make it so that workflows only trigger after specific events. You can define logic apps using the Azure Portal or by writing JSON definitions. You can also use PowerShell.</p>
<p>Logic Apps are not for creating custom code or complete software applications from scratch. They are really for wiring together parts of your Azure infrastructure or connecting it with legacy systems. So how does this relate to messaging? Well, consider the diagram here. Your messaging system needs to do more than just ingest messages. It may need those messages to trigger additional processes. You may be able to do that with an Azure Function, but that would require writing code. With an Azure Logic App you could, for example, have a message trigger an update to a Slack chatroom by having the app monitor your blob storage. This could be set up with just a few clicks on the Azure portal. Pretty cool.</p>
<p>So that about does it for our review of Azure messaging solutions. There is A LOT of content in this lesson so don’t feel bad if you need to review it a few times. We’re going to focus in on our push notification use case in the next lesson and do some light review in the final part of the section covering scalability. See you there!</p>
<h1 id="Creating-a-Push-Notification-System"><a href="#Creating-a-Push-Notification-System" class="headerlink" title="Creating a Push Notification System"></a>Creating a Push Notification System</h1><p>There are many scenarios where you will need your application to send notifications to end users’ smart devices. It may be a fitness app that tracks how many steps we have walked and wants to let us know that we reached a daily goal. It could be a messenger app letting alerting us to a new contact request. If you have a smartphone you can surely think of many other examples.</p>
<p>To demonstrate how to set up a push notification system, we’re going to take the example of a bank application. It needs to notify users whenever they receive a deposit over a certain amount of money. The centerpiece for our system will be Azure Notification Hubs. We’re going to walk through it step by step.</p>
<p>So let’s start by considering what our backend might look like. Consider this architecture. Financial data is managed by a legacy system. We’re using Azure Service Bus to ingest messages and event data. Then there is a mobile backend that subscribes to specific topics and is responsible for pushing messages to our banking mobile app.</p>
<p>The easiest way to integrate our mobile app backend with notification hub would be to use something like Azure App Service Mobile Apps. This is an Azure Platform as a Service tool that has direct integration with notification hubs.</p>
<p>App Service mobile Apps: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/app-service-mobile/app-service-mobile-value-prop">https://docs.microsoft.com/en-us/azure/app-service-mobile/app-service-mobile-value-prop</a></p>
<p>However if we want to take a more open-ended approach, the basic solution is to create a notification hub and connect it to our mobile app project. We have included a link to a detailed example for how to do that with Android. It is a little out of scope to cover how to set up an Android project, so we’re going to focus on setting up the notification hub. You can do this in the web UI by simply clicking on “create a resource,” then selecting “Web + Mobile” and finally selecting “Notification Hub.” The next menu will ask for some basic information to configure your hub, such as your Azure region, a name for the hub, and a resource group.</p>
<p>Android example: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-android-push-notification-google-fcm-get-started">https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-android-push-notification-google-fcm-get-started</a></p>
<p>Once the hub exists you will need to get the connection string from the Access Policies page. This is the credential that will let your mobile backend actually connect to your hub for pushing messages. It will be part of your mobile backend code. From there, usually your code will use some library to handle transmitting the notification with relevant target details. If a library is not available for your use-case, you can use the REST API to send notification messages.</p>
<p>The nice thing about Azure notification hubs is that it makes it easy to test push notifications once you are ready. As you can see from the diagram, in the web UI you can select a platform, create a payload, and do a “test send.” If you have configured your app correctly you should see it on targeted phones running the app.</p>
<p>So that’s basically it, at a high level at least. Actually implementing all of this in a real software stack is of course more complex and requires some programming knowledge. What we wanted to demonstrate here was just problem solved by Azure Notification Hubs - namely, giving your app a centralized easily managed service for handling transmission of notifications.</p>
<p>So now we will close out this section by talking about scaling. It’s all well and good to be able to handle lots of messages with Service Bus and send notifications with Notification hub. But how do we deal with bottlenecks and sudden increases in traffic? How do we optimize our performance? Stick around for the next lesson and you’ll find out!</p>
<h1 id="Scaling-Your-Messaging-Infrastructure"><a href="#Scaling-Your-Messaging-Infrastructure" class="headerlink" title="Scaling Your Messaging Infrastructure"></a>Scaling Your Messaging Infrastructure</h1><p>Scalability is often your biggest and most critical challenge when designing cloud infrastructure. If we cannot tolerate traffic spikes or sudden growth then we have been derelict in our duty. The first place to start when addressing scalability is to identify bottlenecks. What components of our system are most vulnerable to catastrophic failure due to changes in usage patterns?</p>
<p>With the notification and messaging systems we discussed in the previous lessons, there are, at a high level, three places we want to focus: 1. Messaging and event ingestion, or, the “on-ramp” into our system. 2. Message routing, meaning getting ingested messages to the right place without latency. And 3. Message processing, meaning once we are ready to do something with our messages, be it run some code or store them somewhere, we can do that thing quickly.</p>
<p>So let’s start with message ingestion. We’ll address Azure Storage Queues and Azure Service Bus. For Storage Queues, you get Azure’s enterprise storage SLAs, which include certain performance guarantees. See the links for full details in the Azure documentation. Basically, unless you have an extremely high volume system, Azure should be able to handle your needs. Storage Queues can tolerate 20,000 messages per second per storage account at a rate of 2000 messages per second per queue.</p>
<p>With Service Bus, performance varies a bit depending on the tier you select. In both cases you will be able to handle larger message sizes than storage queues. The main difference between the Service Bus Premium and Standard tiers is in network performance. The Premium tier guarantees consistent high throughput performance at a fixed price with the ability to scale workloads up and down. With the standard tier it is “pay as you go” with variable latency and throughput. Also note that the size of individual queues with Service Bus is fixed at a maximum of 80 GB, wherease Azure Storage queues can go all the way up to 500 TB. Keep this in mind if you have an unusual use case.</p>
<p>So the basic scaling takeaway here is that with both services you get strong performance guarantees but you may need to think carefully about whether Service Bus or Storage Queues make more sense for your needs as there are key differences.</p>
<p>Now for routing messages we’re going to just briefly mention Event Grid. It has strong scalability guarantees as well and is great for serverless architectures that need to route data to various endpoints. Event Grid includes 24-hour retry with exponential backoff to give you some breathing room if there is a temporary issue with your system. You also get a throughput guarantee of support for millions of events per second. Be aware, though, that the pricing model is pay-per-event. If cost is an issue it could be cheaper to handle events with your own custom system and only pay for network bandwidth.</p>
<p>Finally, how do we scale our message processing? Well, that depends on exactly what is doing the processing. If we’re using Azure Functions, happily, we don’t need to worry about scaling - Azure will do it for us automatically as traffic increases. Be aware that you will of course be charged based on function usage. If we have some sort of app running on a VM doing the processing, then we may need to implement some form of autoscaling. Our endpoint could also be an Azure Logic Apps. See the documentation link for details on its limitations. There are http request and message size limits that are not really changeable. If your bottleneck is needing to run more actions in a logic app workflow, you can add nested workflows to get more done.</p>
<p>So that about does it for scaling. We have talked about ingesting, routing, and processing messages using Azure solutions. In many cases we get solid default guarantees from Azure. In some cases we may need to select specific service tiers or change our configuration. The nice thing is that Azure is such a mature and robust system that, unless you are Amazon or Google, you probably can get your work done with their solutions. So we will end it there for our section on messaging. Our last part of this course will focus on handling media with Azure services. See you there!</p>
<p>Logic Apps: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-limits-and-config">https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-limits-and-config</a></p>
<p>Storage queues performance: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-scalability-targets#azure-queue-storage-scale-targets">https://docs.microsoft.com/en-us/azure/storage/common/storage-scalability-targets#azure-queue-storage-scale-targets</a></p>
<h1 id="Section-4-Introduction"><a href="#Section-4-Introduction" class="headerlink" title="Section 4 Introduction"></a>Section 4 Introduction</h1><p>In the final section of the Design Solutions Using Platform Services course, we are going to focus on media - specifically video content. Video media content is notoriously tricky to work with both for developers and cloud platforms. It is more difficult to analyze than text or images. It also tends to be far larger in size and therefore more expensive to store and transmit. You also have to worry about encoding and optimizing user experience for different browsers, media players, and bandwidths.</p>
<p>With Azure, these challenges do not go away, but they are made easier to deal with by the available toolset. Azure Media Services, Microsoft’s flagship solution for dealing with media, will help you navigate most of the above challenges. We will spend a good amount of time in the next lesson covering all of its capabilities. We will also discuss Azure Video Indexer, Computer Vision API, and a few other useful products. In the last part of the section, we will go over file-based encoding thoroughly and introduce Azure Media Analytics.</p>
<p>Once you finish this section, you should be a lot less nervous about dealing with videos and streaming content on the Azure platform. So if you’re ready, let’s dive in and get started.</p>
<h1 id="Media-Technology-Review"><a href="#Media-Technology-Review" class="headerlink" title="Media Technology Review"></a>Media Technology Review</h1><p>Azure Media Services is your base of operations for managing video media. It will handle storage, encoding, and packaging video for streaming delivery. To use it you need to create an Azure Media Services account. This is as simple as a few clicks in the Azure web portal.</p>
<p>As you can see from the diagram Media Services manages video content in five parts. First, there is upload and storage for administering content at rest. Then there is the encoding step to prepare content for media players. Next is setting asset delivery policies for clarifying how content can be used. From there, content is published to an OnDemand locator, and finally, content can be streamed to clients. Mixed into those five steps are some important security decisions. In this diagram, we add those in. There is setting the encryption content key and an authorization policy. Together these allow for content to be dynamically encrypted during playback. Media Services also includes options for encrypting content at rest.</p>
<p>Azure Media Services supports a number of approaches to delivering content. You can create streaming endpoints for video content using multi-bitrate (adaptive bitrate for unstable network conditions) streams over HLS, HTTP Live Streaming, or MPEG-DASH. You can create URL endpoints for both streaming or download. It’s up to you to decide whether you want users to be able to copy your media files, play them in browsers, or stream them in smart phones and other devices.</p>
<p>Honestly, it would take its own course to cover every single thing Media Services can do. See the documentation if you really want to go down a rabbit hole. One very important thing I will leave you with regarding Media Services, however, is that you can interact with its functionality in multiple ways. Like other Azure products Media Services works with the Azure web dashboard, a REST API, and has an SDK for .NET language support. So regardless of how you want to access your Media Services account, you will always have options.</p>
<p>Now, an important related service is the Azure Video Indexer product. Video Indexer replaces the older Video API service Azure supported in the past. Video Indexer is a relatively straightforward set of tools built on top of Azure Media Analytics, which we will cover later. It is designed to extract information from videos for easier management. So for example you can use Video Indexer to do visual text recognition on a video, transcribe audio, detect faces, translate the video to another language, and much much more. See the list of features in the slide here to get a full sense. Important to note: These tools are also supported by the SDK and can be accessed using .NET or REST calls.</p>
<p>Finally, the Azure Computer Vision API is somewhat similar to the image classification tools we discussed in the section on AI. This API gives developers tools for processing images using Azure’s advanced classification algorithms. You can access the API using languages like Python, C#, Ruby, Java, and PHP, or even just use cURL. Assuming your image meets the requirements shown in the slide, you can then call the API to do things like recognize text, flag adult content, apply tags based on content, generate descriptions, detect human faces, and even recognize domain-specific content.</p>
<p>So there you have it - we have gone over most of the basic media technologies in the Azure software ecosystem. We still have one major component to cover - the Azure Media Analytics toolset. We will cover that and briefly discuss file-based encoding systems in Azure in the next lesson. See you there.</p>
<h1 id="File-Based-Encoding-and-Azure-Media-Analytics"><a href="#File-Based-Encoding-and-Azure-Media-Analytics" class="headerlink" title="File-Based Encoding and Azure Media Analytics"></a>File-Based Encoding and Azure Media Analytics</h1><p>We will wrap up our lesson on Azure Media with a discussion on media file encoding and an introduction to the Azure Media Analytics tool set.</p>
<p>We aren’t going to go super deep here with respect to compression algorithms or the history of different codecs. For our purposes you just need to know what a video codec is. It is simply a piece of software that compresses or decompresses digital media. An encoder is for compression and a decoder is for decompression, and the codec is the software doing the work. Generally when we talk about encoding we are talking about audio or video files. There are numerous formats such as mp3, wma, mp4. Some forms are lossy or lossless depending on the compression algorithms used. Lossy formats usually take far less space but will lose information over time as the file is compressed and decompressed. Lossless formats take more space but maintain their quality over time. This is why your hipster friend is really into using FLAC for his music collection.</p>
<p>So our focus is file-based encoding. File-based encoding, as you might have guessed, relies on video files. These will be the inputs and outputs for your codec software. So you will start with some raw video file taken from a camera or other source, run that through an encoding program, and the output will be a compressed version of the video that will use less space and be playable in a wide range of media players.</p>
<p>Microsoft Azure has its own Encoding service. See the link below for the full list of supported input file types and output file options. Suffice to say, with Azure Encoding, you should have everything you need to get your video content properly formatted for delivery. The trickier question may be deciding which version of the service to use. Azure offers both a standard and a “Premium Workflow” version. Pause the video on this slide to get a thorough look at the feature differences. Probably the biggest advantage for Premium is the ability to apply conditional logic on file encoding. This will allow you to automate encoding rules and thereby encode large numbers of files quickly. If you only have a small number of video files to manage, the standard service may suit you just fine.</p>
<p>(List of formats: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/media-services/previous/media-services-compare-encoders">https://docs.microsoft.com/en-us/azure/media-services/previous/media-services-compare-encoders</a>)</p>
<p>In the last part of this section, with the other Azure media services and file encoding now behind us, we will talk about how to gain useful insights from our media using Azure Media Analytics. As you can see in the diagram Media Analytics works in parallel with the components responsible for encoding, streaming, and storing your media.</p>
<p>Media Analytics is actually a combination of several small tools that work together to give you useful intelligence on your video content. There is the Indexer service that makes your content searchable and helps generate closed-captioning tracks. There is the Hyperlapse service that adds video stabilization and time-lapse capability. There is an optical character recognition tool as well as a face and motion detector application. There is a tool for face redaction if needed for legal or security purposes. There are also content moderation and video summarization systems to make administration of large amounts of video content simpler.</p>
<p>Azure Media Analytics is your one stop shop for efficiently analyzing and optimizing your video library. It can save you thousands by baking together several tools that would be expensive if purchased separately.</p>
<p>So that about wraps it up for our lesson on encoding and media analytics. Congratulations. You are now an expert on media management with Azure. Great job!</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>So congratulations! You made it! Give yourself a pat on the back because it has been a long and tough ride. We went through a lot of pretty dense material so before we pop the champagne bottles, let’s take a minute to briefly review what we have accomplished.</p>
<p>We learned how to design a variety of software solutions using Azure platform services. You should now be ready to tackle a wide range of problems using Azure technologies. We focused on four broad categories: Artificial Intelligence, Internet of Things, Messaging, and Media.</p>
<p>Recall our four learning objectives:</p>
<p>\1. The student will have an in-depth knowledge of Azure artificial intelligence services and know when to opt for specific offerings. To that end, we covered various Azure tools including Azure Machine Learning, Machine Learning Studio, Batch AI, Cognitive Services, and Databricks.</p>
<p>\2. The student will have an in-depth knowledge of Azure IoT services and know when to opt for specific offerings.  In section 2 we went deep on this, covering many services, including Azure Event Grid, Service Bus, IoT Edge, Stream Analytics, and Notification Hubs.</p>
<p>\3. The student will be able to design a scalable messaging architecture using Azure services. In what was probably the densest section we covered both the concept of messaging in software systems and how to scale. The relevant Azure technologies were Azure Service Bus, Storage Queues, and Event Hubs, some of which were covered in IoT but required a deeper dive here.</p>
<p>\4. The student will have a deep understanding of Azure media services. So, “Azure Media Services” is the name of the core Azure tool for managing video. However, we also covered media file encoding in some depth, as well as other media services including Azure Media Analytics, Computer Vision API, and Azure Video Indexer.</p>
<p>With all this information at your disposal, you should be ready to get to work on a number of different problems. Keep in mind, however, that practice makes perfect. You won’t be a true expert until you actually make use of these different technologies and learn the nuances. To be a master Azure technologist, you will need to dive in and get your hands dirty.</p>
<p>Now that you are done I’d like to invite you to send any feedback you have about the course to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>. We greatly appreciate your comments, questions, and suggestions. Congratulations again on fighting through the whole course and good luck in your future endeavors.</p>
<h2 id="Azure-Artificial-Intelligence-Services-1"><a href="#Azure-Artificial-Intelligence-Services-1" class="headerlink" title="Azure Artificial Intelligence Services"></a><strong>Azure Artificial Intelligence Services</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/#analytics">Analytics Tools Catalogue</a></p>
<h2 id="7IoT-Azure-Technology-Review"><a href="#7IoT-Azure-Technology-Review" class="headerlink" title="7IoT Azure Technology Review"></a>7<strong>IoT Azure Technology Review</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-compare-event-hubs">IoT Hub and Event Hubs Comparison</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/notification-hubs/notification-hubs-aspnet-cross-platform-notification">How-To Guide</a></p>
<h2 id="12Creating-a-Push-Notification-System"><a href="#12Creating-a-Push-Notification-System" class="headerlink" title="12Creating a Push Notification System"></a>12<strong>Creating a Push Notification System</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/app-service-mobile/app-service-mobile-value-prop">App Service mobile Apps</a></p>
<h2 id="13Scaling-Your-Messaging-Infrastructure"><a href="#13Scaling-Your-Messaging-Infrastructure" class="headerlink" title="13Scaling Your Messaging Infrastructure"></a>13<strong>Scaling Your Messaging Infrastructure</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-limits-and-config">Logic Apps</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-scalability-targets#azure-queue-storage-scale-targets">Storage queues performance</a></p>
<h2 id="16File-Based-Encoding-and-Azure-Media-Analytics"><a href="#16File-Based-Encoding-and-Azure-Media-Analytics" class="headerlink" title="16File-Based Encoding and Azure Media Analytics"></a>16<strong>File-Based Encoding and Azure Media Analytics</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/media-services/previous/media-services-compare-encoders">List of formats</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Getting-Started-with-Azure-Container-Instances-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Getting-Started-with-Azure-Container-Instances-12/" class="post-title-link" itemprop="url">AZ-204-Getting-Started-with-Azure-Container-Instances-12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:08:32" itemprop="dateCreated datePublished" datetime="2022-11-14T11:08:32-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:33:36" itemprop="dateModified" datetime="2022-11-20T19:33:36-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Getting-Started-with-Azure-Container-Instances-12/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Getting-Started-with-Azure-Container-Instances-12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/" class="post-title-link" itemprop="url">AZ-204-Building-Containers-with-Azure-DevOps-11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:07:58" itemprop="dateCreated datePublished" datetime="2022-11-14T11:07:58-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:28:10" itemprop="dateModified" datetime="2022-11-20T19:28:10-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to “Building Containers with Azure DevOps”. My name is Thomas Mitchell and I’ll be taking you through this course. </p>
<p>I’m an Azure Instructor at Cloud Academy and I have over 25 years of IT experience, several of those with cloud technologies. If you have any questions, feel free to connect with me on LinkedIn, or send an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This course is intended for DevOps professionals who wish to learn how to design and implement, through the use of containers, strategies for developing application code and infrastructure that allow for continuous integration, testing, delivery, monitoring, and feedback.</p>
<p>To get the most from this course, you should have a basic understanding of the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> platform and of container concepts.</p>
<p>We’ll kick off by talking about ways to create deployable images. You’ll learn about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/the-power-of-docker-containers/">docker containers</a> and their role in development. You’ll also learn about microservices and where they fit in.</p>
<p>After discussing microservices, we’ll dive into the different Azure container-related services. We’ll talk about Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, and Azure Service Fabric. We’ll also tough on Azure App Service.</p>
<p>Once we finish up with the different container-related services, we’ll look at a typical Dockerfile.</p>
<p>Later on, in this course, we’ll look at Docker multi-stage builds. You’ll learn what multi-stage builds are, and things to consider when working with multi-stage builds.</p>
<p>We’ll round things out with a hands-on demonstration that shows you how to create an Azure Container Registry,</p>
<p>By the time you complete this course, you’ll have a better understanding of containers and how they are used in Azure DevOps.</p>
<p>We’d love to get your feedback on this course, so please give it a rating when you’re finished. If you’re ready to learn how to build containers with Azure DevOps, let’s get started.</p>
<h1 id="The-Power-of-Docker-Containers"><a href="#The-Power-of-Docker-Containers" class="headerlink" title="The Power of Docker Containers"></a>The Power of Docker Containers</h1><p>Hello and welcome to “The Power of Docker Containers”. Let’s talk a little bit about what Docker containers bring to the table as far as the development process goes.</p>
<p>As a software containerization platform, Docker offers developers a common toolset and packaging model. It also provides a deployment mechanism for containerized apps. This results in simplified management, regardless of the host, as well as a seamless <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">DevOps</a> experience.</p>
<p>Docker images can be created and deployed identically across virtually any environment in seconds. The Docker ecosystem is huge. This ecosystem includes hundreds of thousands of apps that are packaged in Docker containers. DockerHub, which is the Docker-maintained public containerized application registry, publishes almost 200,000 applications in the public community repository. </p>
<p>The notion that you can deploy a SQL Server Linux instance in seconds, using a Docker image, is a testament to the power of containers. It is this power that <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/microservices-and-containers/">containerization</a> brings to the DevOps sphere.</p>
<h1 id="Microservices-and-Containers"><a href="#Microservices-and-Containers" class="headerlink" title="Microservices and Containers"></a>Microservices and Containers</h1><p>Hi there. Welcome to Microservices and Containers. Although containers have been most commonly used to simplify <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">DevOps</a> through simplified developer-to-test-to-production flows, there are other uses for them. Microservices, for example, is a quickly-growing use-case for containers. </p>
<p>The term “Microservices” refers to an application development strategy where each part of an application is actually deployed as a completely self-contained component (or microservice). The microservices that comprise an application can then be individually scaled and updated. </p>
<p>The easiest way to explain the concept of microservices is to use an example scenario.</p>
<p>Let’s imagine for a second that your organization is the author of a large, monolithic tax application. As part of the development of the next revision of the software, your organization wants to migrate it to a collection of microservices. </p>
<p>Now, the current app might include a piece of code that does some specific tax calculation in certain circumstances – and this code may exist in several spots within the app. Whenever new tax laws are approved or changed, changes are needed in the calculation of taxes. This means that the same changes need to be made anywhere this tax calculation is performed within the app.</p>
<p>By moving to a collection of microservices, you could allow the application to create a notification that a tax calculation needs to be made in response to some scenario. Microservices involved in that calculation can be subscribed to those notifications – and then those individual microservices can do what they need to do to perform the tax calculations. You’d likely have one specific microservice that does the actual calculation.</p>
<p>Whenever a new tax law is enacted that affects tax calculations, you would only need to update the microservice(s) responsible for the calculations. You wouldn’t need to make changes throughout the app code base.</p>
<p>While you might operate a development or testing environment on a single server or by using a single instance of each microservice, production is typically a different story. In such an environment, you are likely going to want to be able to scale things out. You’ll probably want to scale out to multiple instances across a cluster of servers, rather than running things on one server. You’ll want the ability to scale in as well. You may also want different teams within your development department to be able to independently work on, and update, different microservices that each team is responsible for.</p>
<p>This is where microservices can really shine. By leveraging the benefits of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/the-power-of-docker-containers/">Docker containers</a> when working with more complex microservice-based applications, organizations can become more agile, because those microservices can be quickly scaled out and in to meet the loads on the application. While doing so, however, the isolation of resources and namespaces offered by containers ensures that one microservice instance does not interfere with any other instances. This makes it easier to design a solid microservice architecture, which, in turn, allows organizations to deal with the management, deployment, orchestration, and patching needs of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/container-related-services-in-azure/">container-based services</a> – while limiting the risks to availability.</p>
<h1 id="Container-Related-Services-in-Azure"><a href="#Container-Related-Services-in-Azure" class="headerlink" title="Container-Related Services in Azure"></a>Container-Related Services in Azure</h1><p>Hi there. Welcome to “Container-Related Services in Azure”. In this lecture, we’ll take a quick 30,000 foot view of each of the container-related services that are available in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a>. We’ll look at Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, Azure Service Fabric, and Azure App Service.</p>
<p>Let’s start with Azure Container Instances.</p>
<p>When you run workloads in Azure Container Instances, you can focus on app development and deployment instead of the deployment and management of the underlying infrastructure that’s necessary to run those apps.</p>
<p>While Azure Container Instances are easy to deploy, the main advantage of using them is the security that the hypervisor isolation that they provide for each container group. With this type of isolation available, you can be sure that your organization’s containers aren’t sharing their OS kernel with other containers.</p>
<p>You can read more about Azure Container Instances by visiting the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-instances/">https://azure.microsoft.com/en-us/services/container-instances/</a></p>
<p>The Azure Kubernetes Service started out as Azure Container Services, or ACS. It originally supported Docker Swarm and Mesos&#x2F;Mesosphere DC&#x2F;OS for orchestration management. However, when Kubernetes support was added, it became so popular that Microsoft eventually renamed the Azure Container Service to the Azure Kubernetes Service, or AKS.</p>
<p>At this point, Kubernetes is really the standard for container orchestration. Using the Azure Kubernetes Service, you can not only deploy and manage Kubernetes, but you can also scale and run your applications in a secure environment.</p>
<p>To learn more about the Azure Kubernetes Service, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/kubernetes-service/">https://azure.microsoft.com/en-us/services/kubernetes-service/</a></p>
<p>The Azure Container Registry is another container-centric service offering available in Azure. It allows you to store and manage your container images in a central registry, which is integrated with several other Azure services, including the App Service, Batch, and Service Fabric, among others. </p>
<p>Azure Container Registry supports many types of container deployments, including DC&#x2F;OS, Docker Swarm, and Kubernetes. Because of the broad support that Azure Container Registry offers, you can manage the configuration of your applications without being locked into the configuration of the target hosting environment. </p>
<p>To read more about the Azure Container Registry, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-registry/">https://azure.microsoft.com/en-us/services/container-registry/</a></p>
<p>Azure Service Fabric is a distributed systems platform that allows you to build and operate always-on, scalable, distributed apps. The service makes it easier to package, deploy, and manage scalable and reliable <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/microservices-and-containers/">microservices and containers</a>. It can also host and orchestrate containers.</p>
<p>By leveraging Azure Service Fabric, you can avoid infrastructure problems and focus solely on the deployment of mission-critical workloads that are not only reliable, but also scalable. </p>
<p>For more details on the Azure Service Fabric, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/service-fabric/">https://azure.microsoft.com/en-us/services/service-fabric/</a></p>
<p>Azure Web Apps is an Azure offering that provides you with a managed service for both Windows-based and Linux-based web applications. This service allows you to deploy and run containerized apps for both platforms and it also offers auto-scaling and load balancing options. You can even integrate with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">Azure DevOps</a>.</p>
<p>To read more about the Azure App Service, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/app-service/">https://azure.microsoft.com/en-us/services/app-service/</a></p>
<h1 id="Anatomy-of-a-Dockerfile"><a href="#Anatomy-of-a-Dockerfile" class="headerlink" title="Anatomy of a Dockerfile"></a>Anatomy of a Dockerfile</h1><p>Hi there. Welcome to “Anatomy of a Dockerfile”. In this lecture, we’re going to look at a basic Dockerfile, line by line.</p>
<p>Dockerfiles are used by docker build to assemble images. They are essentially text files that contain the commands that are necessary to build an image. On your screen is an example of a very basic Dockerfile. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu </span><br><span class="line">LABEL maintainer=&quot;tmitchell@cloudacademy.com&quot; </span><br><span class="line">ADD appsetup / </span><br><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc; echo $HOME&#x27; </span><br><span class="line">CMD [&quot;echo&quot;, &quot;Hi everybody!&quot;] </span><br></pre></td></tr></table></figure>

<p>Generally speaking, every image is based off another existing image. In this sample Dockerfile here, line one refers to the parent image that this new image will be based on. The Ubuntu image referred to in line one would be retrieved from either a local cache or from DockerHub.</p>
<p>I should point out here that an image that doesn’t have a parent is called a base image. If that were the case here, what we could do with this Dockerfile is completely omit the FROM line altogether. We could also replace it with FROM scratch, instead. However, since we’re using the ubuntu base image, we are referencing it in the file.</p>
<p>The second line in this sample Dockerfile uses the LABEL command to set the email address of the person who maintains the file.</p>
<p>The third line in our example uses the ADD command to add a file, called “appsetup” into the root folder of the image being created.</p>
<p>The fourth line is a RUN command that runs when the image is being created by docker build. This part of the Dockerfile is typically used to configure things within the image. </p>
<p>The last line in our sample file calls a command that we want to execute once the new container is created from the image.</p>
<p>Of course, every Dockerfile will be different – and they can be as simple or as complex as they need to be. Simpler, however, is always better than complex, when possible.</p>
<p>For more information, visit the Dockerfile reference URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<h1 id="Multi-Stage-Builds"><a href="#Multi-Stage-Builds" class="headerlink" title="Multi-Stage Builds"></a>Multi-Stage Builds</h1><p>Hi there. Welcome to “Multi-Stage Builds”. In this lecture, we’re going to take a look at what multi-stage builds are and what they bring to the table.</p>
<p>So, Multi-stage builds are a new feature that makes life easier when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/anatomy-of-a-dockerfile/">Dockerfiles</a>. They are extremely helpful when trying to optimize Dockerfiles while ensuring that they are still easy to read.</p>
<p>Prior to the introduction of multi-stage builds, what you would typically have is one Dockerfile to use for development. This Dockerfile would contain everything that you need to build the application that you wished to deploy. You’d also have a second, slimmed-down Dockerfile that you would use for production. This second file would contain just the application and only the resources needed to run it. This “builder pattern” of maintaining two Dockerfiles, obviously, isn’t ideal.</p>
<p>The code that you see on your screen is a good example of what the typical “builder pattern” consists of. Notice we have 3 different files. We have DockerFile.build, the Dockerfile, and build.sh.</p>
<p>Dockerfile.build:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v golang.org/x/net/html \</span><br><span class="line"> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line">Dockerfile:</span><br><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br><span class="line">build.sh:</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line">docker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \ </span><br><span class="line">  -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"> </span><br><span class="line">docker create --name extract alexellis2/href-counter:build </span><br><span class="line">docker cp extract:/go/src/github.com/alexellis/href-counter/app ./app </span><br><span class="line">docker rm -f extract</span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure>

<p>If you look at this example, you’ll see that it artificially compresses two different RUN commands together. This is done to avoid creating an additional layer in the image. As is the case with any sort of coding, the more code you have, the more error-prone it becomes – and the more difficult it becomes to maintain.</p>
<p>When the build.sh script is run, it first has to build the first image. Then, it needs to create a container from it, so that it can copy the artifact out, before building the second image. In this scenario, you are left with 2 images – both of which take up room on your system. You are also left with the app artifact on your local disk as well.</p>
<p>Enter Multi-stage builds, which greatly simplify things.</p>
<p>Prior to multi-stage builds, keeping image sizes down was a challenge. This is because every instruction included within a Dockerfile adds a layer to the image. Not only that, but you also need to remember to clean up unneeded artifacts before moving on to the next layer. </p>
<p>Until multi-stage builds became available, authoring an efficient Dockerfile meant using shell tricks and other logic to keep the layers as small as possible. You also had to use the same tricks to ensure that each layer has only the artifacts that it needs from the previous layer and nothing else.</p>
<p>On the screen is an example of a multi-stage file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br></pre></td></tr></table></figure>

<p>When you leverage multi-stage builds, you can use multiple FROM statements within the Dockerfile. Each of the FROM statements begins a new stage. The stages, themselves, are numbered in order, starting with stage 0. What you would typically do, though, to make the Dockerfile easier to maintain, is use the AS clause to name, or alias, each stage.</p>
<p>Notice the aliasing that’s been added to the file on your screen:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 AS builder</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go  .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br></pre></td></tr></table></figure>

<p>This example on your screen names the stage and uses the name in the COPY instruction. By referencing the name in the copy instruction, even if the instructions in this Dockerfile are re-ordered later on for some reason, the COPY won’t break.</p>
<p>I should also mention that when you build an image, you don’t have to build the entire Dockerfile, including every stage. Instead, you can specify a single target build stage. The command that you see on your screen, when using our example Dockerfile, stops at the stage named builder:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t alexellis2/href-counter:latest</span><br></pre></td></tr></table></figure>

<p>The –target option, in this command, tells docker build to create an image up to the target of builder, which is a named stage in our example file. </p>
<p>In the next lesson, we’ll take a look at some best practices that you can follow when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/best-practices-for-multi-stage-builds/">multi-stage builds</a>.</p>
<h1 id="Best-Practices-for-Multi-Stage-Builds"><a href="#Best-Practices-for-Multi-Stage-Builds" class="headerlink" title="Best Practices for Multi-Stage Builds"></a>Best Practices for Multi-Stage Builds</h1><p>Hi there. Welcome to Best Practices for <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/multi-stage-builds/">Multi-Stage Builds</a>. In this lecture, we’re going to review some of the best practices that you should be following when working with multi-stage builds. We’re going to talk about adopting container modularity, avoiding unnecessary packages, choosing an appropriate base, and avoiding the inclusion of application data.</p>
<p>When working with builds, you really want to avoid overly complex container images that couple together several applications. Instead, what you should be doing is using multiple containers, with each one intended for a single purpose. For example, you might want to put a website in one container but relegate the database for the website to another container.</p>
<p>While there are always going to be exceptions to this rule, splitting up the components of an application into separate containers makes it more likely that you will be able to minimize work effort by being able to reuse containers. Adopting container modularity will also often make it easier to scale an application. Using our website example from earlier, container modularity would allow you to add replicas of the website container while leaving the database container alone. </p>
<p>An easy way to minimize image sizes is to avoid including unnecessary packages in your images. For example, instead of including packages that you think you MIGHT need, leave them out until you are sure you need them. Once you are sure you need them, you can include them.</p>
<p>Choosing an appropriate base image, or parent image, allows you to optimize the contents of your Dockerfile. By starting with an image that only contains the packages that you need, you can keep your Dockerfiles in check. </p>
<p>Although it’s possible to store your application data right inside the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-create-an-azure-container-registry/">container</a>, doing so increases the size of your image. This runs counter to the idea of optimizing things. Instead of storing app data in your containers, you should consider using docker volume support. By doing so, you can maintain isolation of the application itself, and its data. </p>
<p>For more Dockerfile best practices, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/">https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/</a></p>
<h1 id="Demo-Create-an-Azure-Container-Registry"><a href="#Demo-Create-an-Azure-Container-Registry" class="headerlink" title="Demo: Create an Azure Container Registry"></a>Demo: Create an Azure Container Registry</h1><p>Hi there and welcome back. In this demonstration, we’re going to do a couple of different things. First, we’re going to deploy a Container Registry in Microsoft Azure using the Azure portal. Once we’ve got that deployed, we’re going to log in to that registry, using the Azure CLI from our local workstation. Once we’ve logged into our registry, what we’re going to do is use the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-add-docker-support-to-an-existing-application/">Docker</a> terminal which is also installed on our local workstation. And we’re going to first, pull down a basic hello world image from the Docker Hub.</p>
<p>Once we have the Hello World image pulled down from Docker Hub, we’ll take that image and we’ll push it to our Container Registry in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a>. Once we have it pushed to our Container Registry in Azure, we’ll go back to the Azure portal, and we’ll take a look and confirm that our hello world image has in fact been pushed into our Container Registry. So let’s get started here.</p>
<p>On the screen, you can see I’m logged into my Azure Portal here, I’m at my homepage. I am logged in as the admin here. To deploy a Container Registry, we’re simply going to create a resource. And we’ll search the marketplace for Container Registry. And we can see Container Registry here and we’ll create it. We need to give our registry a unique name. And we’ve called it my9878 and it appends, what Azure will do here is append this azurecr.io domain name to your registry name.</p>
<p>So the registry name needs to be unique across Azure. We’ll deploy into our lab subscription and into my resource group. We can leave the rest of this stuff here at its default. We’ll go ahead and click Create. The deployment here shouldn’t take long, usually a couple minutes at most. We can see it’s been deployed. So we’ll go to our resource here. And if we go into repositories within our registry, we can see we have no repositories here.</p>
<h1 id="Demo-Add-Docker-Support-to-an-Existing-Application"><a href="#Demo-Add-Docker-Support-to-an-Existing-Application" class="headerlink" title="Demo: Add Docker Support to an Existing Application"></a>Demo: Add Docker Support to an Existing Application</h1><p>So now that our my9878 <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-create-an-azure-container-registry/">container registry</a> has been deployed. Let’s log into it using the Azure CLI from my workstation. So let me bounce down here. I actually have my PowerShell running and my Docker terminal here. So let’s open up PowerShell here. And from PowerShell what I’m going to do is run the az acr login command. And when I do this, I need to specify the name of my repository.</p>
<p>Now oddly enough, I don’t need to nor should I include the azurecr.io domain name when I specify the name for my repository here. So we bounced back out to overview. See the full login server here, my9878.azurecr.io Instead, I just use the name that I gave my repository. So we’ll go ahead hit enter here and we can see that our login has succeeded. Now what we’re going to do into this exercise is push the basic hello world image up to my container registry. That being said, I have to obtain that hello world image first and I’m going to obtain that from Docker Hub.</p>
<p>Now to do that, I’m going to switch over to my Docker terminal here. Now from Docker terminal, what I’m going to do is run a Docker pull hello world command and what this will do is pull the latest hello world image from Docker.io So it’s coming from Docker Hub. Now before we push this image into our container registry. We need to first tag it with the fully qualified domain name of our ACR login server.</p>
<p>If we bounce out to our Azure portal, we can see the FQDN for our login server is my9878.azurecr.io So that’s what we’re going to use here. So let’s bounce back into our terminal here. And we’re going to use the Docker tag command to perform this tagging. Along with the tag command, we need to specify the image. After specifying the name of the image we want to tag, we need to specify the ACR login server. And with that we need to specify the name of our image and the versioning for it.</p>
<p>So we’ll go ahead and tag it. And then what we’ll do now is perform the push using the Docker push command. And essentially we’re going to specify the name we just called in the Docker tag command. And we can see it prepares and then pushes and tells us the image has been pushed. To confirm that our image has been pushed, we can go into our portal and then take a look at our repositories. And we can see hello world is now listed as a repository.</p>
<p>At this point, we can now try to run the image from our container registry. And to do that we’ll bounce back down into our Docker terminal. And from here we’ll use the Docker run command. So we’ll go Docker run and again, we’ll specify the image from our registry. And if we look closely here we can see we get a message from Docker telling me that our installation appears to be working correctly.</p>
<p>So with that, we’ve deployed a container registry in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a> using the portal. We used Azure CLI within Azure PowerShell from our local workstation to log in to our registry. And then we used the Docker terminal to pull down an image from Docker Hub. We tagged it and then we pushed that image up into our own registry. Once we confirmed that the push was successful, we were also able to successfully run the image from our registry. So with that let’s call it a wrap.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Congratulations! You’ve come to the end of “<a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">Building Containers with Azure DevOps</a>“. Let’s review what you’ve learned!</p>
<p>We kicked things off by talking about ways to create deployable images. You learned about docker containers and their role in development. You also learned about microservices and where they fit in.</p>
<p>After discussing microservices, we looked at the different Azure container-related services. We talked about Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, and Azure Service Fabric. We also touched on Azure App Service.</p>
<p>After finishing up with the different container-related services, you learned what a typical Dockerfile looks like.</p>
<p>Later on, you learned about Docker multi-stage builds. You learned what multi-stage builds are, and things to consider when working with multi-stage builds.</p>
<p>We wrapped up with a hands-on demonstration that showed you how to create an Azure Container Registry.</p>
<p>At this point, you should have a better understanding of containers and how they are used in Azure DevOps.</p>
<p>I should point out, before you go, that, in addition to completing courses like this one, you should always keep up with the latest features and services by reading Microsoft’s published documentation as well.</p>
<p>As always, thanks for watching, and happy learning!</p>
<h2 id="4Container-Related-Services-in-Azure"><a href="#4Container-Related-Services-in-Azure" class="headerlink" title="4Container-Related Services in Azure"></a>4<strong>Container-Related Services in Azure</strong></h2><p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-instances/">Azure Container Instances</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/kubernetes-service/">Azure Kubernetes Service</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-registry/">Azure Container Registry</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/service-fabric/">Azure Service Fabric</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/app-service/">Azure App Service</a></p>
<h2 id="5Anatomy-of-a-Dockerfile"><a href="#5Anatomy-of-a-Dockerfile" class="headerlink" title="5Anatomy of a Dockerfile"></a>5<strong>Anatomy of a Dockerfile</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a></p>
<h2 id="7Best-Practices-for-Multi-Stage-Builds"><a href="#7Best-Practices-for-Multi-Stage-Builds" class="headerlink" title="7Best Practices for Multi-Stage Builds"></a>7<strong>Best Practices for Multi-Stage Builds</strong></h2><p><a target="_blank" rel="noopener" href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/">Dockerfile best practices</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Running-a-Container-on-Azure-App-Service-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Running-a-Container-on-Azure-App-Service-10/" class="post-title-link" itemprop="url">AZ-204-Running-a-Container-on-Azure-App-Service-10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:07:09" itemprop="dateCreated datePublished" datetime="2022-11-14T11:07:09-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:29:48" itemprop="dateModified" datetime="2022-11-20T19:29:48-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Running-a-Container-on-Azure-App-Service-10/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Running-a-Container-on-Azure-App-Service-10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Running-a-Container-on-Azure-App-Service"><a href="#Running-a-Container-on-Azure-App-Service" class="headerlink" title="Running a Container on Azure App Service"></a>Running a Container on Azure App Service</h1><p>Welcome to “Running a Container on Azure App Service”. To get the most from this course, you should already have some basic experience using App Service. If you don’t, then you can take our “Introduction to Azure App Service” course.</p>
<p>In this course, I’ll give you a demonstration of how to build and run a Docker container on App Service. If you want to do the demo yourself, as well, then you’ll need to have an Azure account. If you don’t already have one, then you can create a free trial account.</p>
<p>Although App Service supports many different programming languages and frameworks, such as .NET, Java, and Python, sometimes you might need a different development stack that isn’t directly supported by App Service. In these cases, the solution is to create a custom Docker container that has all of the software you need preinstalled.</p>
<p>A Docker container is a self-contained software environment that includes an application and all of its dependencies. Because it includes everything it needs, the container is portable. That is, it can run on any system that supports Docker without having to worry about what’s installed in the underlying operating system.</p>
<p>Container images are normally stored in a central location, which makes it easier to manage them and deploy them. Microsoft offers a service called Azure Container Registry that provides this central location.</p>
<p>To deploy a container to App Service, here are the steps you need to take. First, create an instance of Azure Container Registry. Then build a container image. Next, upload it to your container registry. Then deploy it from the container registry to Azure App Service. And finally, try to connect to the application to make sure it worked.</p>
<p>Okay, let’s go through the steps. First, we’ll create the container registry. In the Azure Portal, type “container” in the search bar, and choose “Container registries”. Then click “Create”. We can choose an existing resource group, but let’s create a new one, which will make it easier to delete everything when we’re done. I’ll call it “demorg”.</p>
<p>The registry name has to be unique across all Azure customers, so I’ll call it “ca” for “Cloud Academy” and then “reg”. You’ll have to choose a different name if you do this yourself. For the SKU, choose “Basic”, which is cheaper. Then click “Review + Create” and “Create”.</p>
<p>When it’s done, click “Go to resource”. Then go to “Access keys” and set “Admin user” to “Enabled”. This is required for deploying to App Service.</p>
<p>Next, we need to build the container image, so you need to have Docker installed and running on your desktop. If you don’t already have it, then you can download it from docs.docker.com&#x2F;get-docker.</p>
<p>Once you have Docker running, you can build the container image in a variety of different ways, but we’re going to do it from Visual Studio Code, which is a free development tool from Microsoft. You can download it from code.visualstudio.com.</p>
<p>You’ll also need to install the Azure Tools extension. To install it, click on Extensions, search for “azure”, and install Azure Tools. When it’s done, the Azure logo and the Docker logo will show up over here.</p>
<p>Click the Azure logo, then click “Sign in to Azure”. It’ll bring up a browser tab where you have to select your Microsoft account. This came up on a different screen for me, which is why you can’t see it. Okay, I selected my account, so I’m logged in.</p>
<p>Now we need to connect to Azure Container Registry. Click the Docker logo. Then click “Connect Registry”, and select “Azure”.</p>
<p>Next, we need to create a Dockerfile, which is a file that tells Docker how to build a specific container. Normally, we’d need to type some instructions that tell Docker what base image to use and how to install our application and all of its dependencies, but this isn’t a Docker course, so we’re going to take a shortcut. We’re just going to copy an example container image that Microsoft has already created.</p>
<p>Click on the “Explorer” icon. Then click “Open Folder”, and create a new folder called “dockerdemo”. Now click “New File”. To save you the trouble of typing in the contents of this file, I’ve put the text in a readme file in a GitHub repository. You can find a <a target="_blank" rel="noopener" href="https://github.com/cloudacademy/azure-container-app">link</a> to the repository at the bottom of the Overview tab below this video. Copy this text, paste it into the editor, and save it. Call it “Dockerfile”.</p>
<p>These instructions tell Docker to get a .NET Core container image from the Microsoft Container Registry, which is Microsoft’s own registry. The last line tells Docker where the app is in the container, so it can start it when it runs the container.</p>
<p>Now we’re going to build the container image. Hit the F1 key. Then type “docker images”, and select “Build image”. This is what we want to name the image plus the tag to apply to it. We need to tell it that we’re going to put this image in our container registry, so we need to prefix this with the URL of the container registry. I called mine “careg”. Then type “.azurecr.io” because that’s where Azure Container Registry hosts it. Then slash and the name of the image. Then leave the tag as “latest” which means that this is the latest version of the container.</p>
<p>Okay, it’s done. Now we’re going to push the image to the container registry. Click the Docker logo. The image name shows up here. If you click on it, the “latest” tag appears, which means this is the version of the image that we just built. Now, right-click on the image and select “Push”. It brings up the image name and tag again up here, so hit “Enter”. It takes quite a while to push the image to the registry, so I’ll fast-forward.</p>
<p>All right, it’s done. To check that it worked, click the Refresh button next to “Registries”, and the image name should show up under your registry. If you click on it, the tagged version of the image is there.</p>
<p>Now that the container image is in our registry, we can finally deploy it to Azure App Service. Right-click the tagged image, and select “Deploy image to Azure App Service”. Choose a globally unique name for the app. I’m going to use “ca” and the “dockerdemo”. You’ll have to choose something else. Then select the resource group you created before. I called mine “demorg”. Then select a region.</p>
<p>Finally, select an App Service Plan. If you haven’t created one already, then you can create one from here. The pricing tier for your service plan has to be at least Basic because you can’t deploy a container to a Free plan.</p>
<p>If you have an App Service Plan and it’s not showing up here, it might be because it’s for the wrong operating system. This Docker image runs on Linux, so you can only select a Linux App Service Plan. It’s possible to deploy a Windows container to App Service, but most people use Linux.</p>
<p>Now, it’s pulling the image from the container registry and deploying it to the App Service Plan. Okay, it’s finished. Now we can make sure it worked by clicking “Open Site”. If you need to do this after the popup disappears, you can click on the Azure logo. Here’s the app we just pushed to App Service in a container. If you right-click, you can select “Browse Website”. It came up on my other monitor, so I’ll bring it over. It opened the URL of the app we just deployed on App Service. This is Microsoft’s sample app, so it worked.</p>
<p>That’s the end of this demo. If you want to avoid incurring any additional charges, then the easiest way to delete everything is to delete the resource group you created. I’ll do that with my demorg resource group.</p>
<p>And that’s it for running a container on Azure App Service. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>
<h2 id="Running-a-Container-on-Azure-App-Service-1"><a href="#Running-a-Container-on-Azure-App-Service-1" class="headerlink" title="Running a Container on Azure App Service"></a><strong>Running a Container on Azure App Service</strong></h2><p><a target="_blank" rel="noopener" href="https://github.com/cloudacademy/azure-container-app">Course GitHub repo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Configuring-Networking-in-Azure-App-Service-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Configuring-Networking-in-Azure-App-Service-9/" class="post-title-link" itemprop="url">AZ-204-Configuring-Networking-in-Azure-App-Service-9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:06:07" itemprop="dateCreated datePublished" datetime="2022-11-14T11:06:07-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:28:44" itemprop="dateModified" datetime="2022-11-20T19:28:44-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Configuring-Networking-in-Azure-App-Service-9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Configuring-Networking-in-Azure-App-Service-9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Configuring-Networking-in-Azure-App-Service-Introduction"><a href="#Configuring-Networking-in-Azure-App-Service-Introduction" class="headerlink" title="Configuring Networking in Azure App Service - Introduction"></a>Configuring Networking in Azure App Service - Introduction</h1><p>Welcome to “Configuring Networking in Azure App Service”. In this course, I’ll cover the most commonly used networking configurations in App Service. First, I’ll explain how to create a custom domain name for your app. Then, I’ll show you how to enable TLS&#x2F;SSL so people can reach your app using HTTPS. Finally, I’ll explain different ways of controlling inbound and outbound connections to and from your app.</p>
<p>To get the most from this course, you should already have some basic knowledge of both App Service and Azure networking. It would also help to have some knowledge of DNS, that is, the Domain Name System.</p>
<p>Okay, let’s get started.</p>
<h1 id="Custom-Domains"><a href="#Custom-Domains" class="headerlink" title="Custom Domains"></a>Custom Domains</h1><p>One of the most common things you’ll need to do when you create an app using Azure App Service is to set it up with a custom domain name. That’s because, by default, an App Service app has a URL that ends with the “.azurewebsites.net” domain, which probably isn’t what you want for a commercial website. For example, if you have an app that should be hosted at a site called contoso.com, then you’ll need to tell App Service to use that custom domain name. </p>
<p>Here’s how to do that. First, you need to make sure your App Service Plan is using a paid tier because custom domains are not supported in the free F1 tier.</p>
<p>Next, let’s assume that you’ve already registered your domain name with a domain provider and that you can edit the DNS records for your domain. This isn’t a DNS course, so I’m not going to go into detail about how DNS works. I’ll just explain what you need to do to set up a custom domain for an App Service app. If you’re not familiar with DNS, then it would be a good idea to learn more about it before you make changes to your DNS records.</p>
<p>Okay, now go into the Custom Domain settings for your app in App Service and find the Custom Domain Verification ID. This is something that you’ll add to your domain records to prove to Microsoft that you own the domain. Copy the verification ID and paste it into a text editor. You’ll also need to copy the IP address of your app and the existing URL of the app from the Custom Domains page. The existing URL will end in “.azurewebsites.net”. Paste both of these values into a text editor as well.</p>
<p>Now go to your domain provider’s website and open your DNS records. If you’re going to use a root domain, such as contoso.com, for your app, then create an A record. If you’re going to use a subdomain, such as <a target="_blank" rel="noopener" href="http://www.contoso.com/">www.contoso.com</a>, then create a CNAME record. You’ll often want to do both.</p>
<p>In the A record, set the name to ‘@’ (which means the root domain), and set the value to the IP address of your app. In the CNAME record, set the name to the subdomain, such as www, and set the value to the existing URL of your app.</p>
<p>Now to prove to Microsoft that you own this domain and its subdomain, you need to create a TXT record for each of them. A TXT record is just an informational record that doesn’t affect the resolution of your domain name. For the root domain, set the name to asuid, which I’m assuming stands for “App Service Unique Identifier”, and set the value to the Custom Domain Verification ID that you copied from App Service. For the subdomain, set the name to asuid dot and the subdomain, so it would be asuid.www in our example. And set the value to the Custom Domain Verification ID.</p>
<p>Now you need to go back to the Custom Domains page for your App Service app and add your custom domain. You just need to put in the name of the domain and the DNS record type, which will be either A or CNAME, depending on whether you’re adding the root domain or a subdomain. Then you click the “Validate” button, and Azure checks for the DNS records that you added. If it works, then your app is now accessible using your custom domain name.</p>
<h1 id="Enabling-TLS-x2F-SSL"><a href="#Enabling-TLS-x2F-SSL" class="headerlink" title="Enabling TLS&#x2F;SSL"></a>Enabling TLS&#x2F;SSL</h1><p>After you’ve configured a custom domain for your app, it will only be accessible at a URL starting with “http”, which is an insecure protocol. These days, every website should be able to respond to requests over HTTPS, which is the secure version of HTTP. To set that up, you need to enable TLS&#x2F;SSL, which takes a bit of work.</p>
<p>First, you need to make sure that the tier of your App Service Plan is at least Basic because the Free and Shared tiers don’t support TLS&#x2F;SSL for custom domains.</p>
<p>Second, you need to have a TLS&#x2F;SSL certificate file. This type of file contains a private key and a certificate with a public key. These are needed for a couple of reasons. First, the public&#x2F;private key pair is used to encrypt and decrypt traffic between the website and the browser of anyone visiting the site. Second, the certificate verifies that the browser is interacting directly with the website.</p>
<p>This might seem like an unnecessary step, but it helps prevent something called a man-in-the-middle attack. This is where another computer is intercepting messages between two parties (the web server and the browser in this case) and listening in on the conversation. In some cases, it will even change the messages. However, if the web server starts an encrypted conversation by presenting a certificate that is verified by a trusted certificate authority, then the browser can be sure that it’s communicating directly with the webserver.</p>
<p>Third, you need to create a TLS binding to your custom domain.</p>
<p>Now let’s get into the details of how to do steps 2 and 3. So where do you get a certificate file? The easiest way is to use the free App Service managed certificate. It’s provided by Digicert, which is the certificate authority that verifies the authenticity of the certificate. This solution won’t work in all cases, but it works for most situations, and it’s free, so it’s hard to beat that. If you need to do something special, then you can import a certificate file that you obtained from somewhere else.</p>
<p>To create a free certificate, go into the TLS&#x2F;SSL settings for your App Service app, then select Private Key Certificates, and click Create App Service Managed Certificate. Then tell it which custom domain you want to create the certificate for, and that’s it.</p>
<p>Once you have a private key certificate, whether it’s a free one or one that you imported from elsewhere, then you can bind TLS&#x2F;SSL to your domain.</p>
<p>Other than specifying the custom domain and the certificate, you need to tell it whether to use SNI SSL or IP SSL. SNI SSL binds the certificate using the website’s hostname, while IP SSL binds the certificate to the website’s IP address. SNI SSL gives you more flexibility, and it’s easier to configure, so it’s usually the best choice. The only disadvantage is that it doesn’t work on really old browsers, and when I say “really old”, I mean it. All major browsers have provided support for SNI SSL since 2007.</p>
<p>Once you’ve bound your certificate to your custom domain, people will be able to access your app using HTTPS. However, they’ll still be able to access it using HTTP, which is not encrypted, so if you want to ensure that everyone will access your site over HTTPS, then you can select the “HTTPS only” option in your app’s TLS&#x2F;SSL settings. There’s also a “Minimum TLS Version” option. By default, it’s set to 1.2, which is the recommended version, but you can set it to 1.0 or 1.1 if you want to support older browsers. It’s usually best to leave it set to 1.2, though.</p>
<p>As I mentioned earlier, one of the benefits of binding a certificate to a custom domain is that it lets a client device know that it’s communicating with a legitimate website and not a hacker. But the website has no way of knowing that’s it’s communicating with a legitimate client and not a hacker. If you require that level of security, then you can enable TLS mutual authentication. This is also known as client certificate authentication. It’s typically used only within an individual organization because it requires that all client devices have a client certificate.</p>
<p>To enable this, you need to go into the general configuration settings for your app, and set “Client certificate mode” to “Require”. You have to do more to make it work, though, because App Service doesn’t handle the client authentication. It just forwards the client certificate to your app. So, you need to add code to your app to handle the authentication. App Service forwards the client certificate as a base-64 encoded value in an X-ARR-ClientCert request header.</p>
<p>And that’s it for enabling TLS&#x2F;SSL.</p>
<h1 id="Inbound-and-Outbound-Connections"><a href="#Inbound-and-Outbound-Connections" class="headerlink" title="Inbound and Outbound Connections"></a>Inbound and Outbound Connections</h1><p>By default, a web app created using App Service can only be accessed through the internet. But there are many cases when you’d want to be able to connect to an app in different ways. For example, you might want an app to only be accessible internally rather than over the internet, or you might want to connect the app to a database in either Azure or an on-premises environment.</p>
<p>There are many different ways to connect to or from an app, depending on exactly what you need to do. These methods can be divided into two groups: inbound (for connecting to an app) and outbound (for connecting from an app to other resources).</p>
<p>We’ll start with the inbound methods. If you’re okay with your app communicating over the internet, but you want to restrict which IP addresses can connect to it, then the easiest way to do that is to add access restriction rules to your app. Each rule either allows or denies access to a single IP address or a block of IP addresses.</p>
<p>If you have resources in an Azure virtual network that need to connect to your app over the Microsoft backbone network rather than over the internet, then you can restrict access to your app using a service endpoint rather than an IP address. A service endpoint is something you can enable on a subnet. So you can create a service-endpoint-based rule that allows access to your app from a particular subnet in a VNet.</p>
<p>A newer way of doing this is to create a private endpoint for your app. This is a private IP address in your VNet that gets attached to your app. One advantage of using a private endpoint is that it makes it easy to connect to your app from an on-premises environment. If you already have a connection from your on-premises environment to your Azure VNet using a method such as Azure ExpressRoute or Azure VPN, then you can connect to the app through the private endpoint in the VNet. This is more difficult to do with a service endpoint. For this and other reasons, Microsoft recommends using private endpoints rather than service endpoints.</p>
<p>All of the methods I’ve mentioned so far have been for controlling inbound connections to your app. To allow your app to initiate outbound connections to various resources, we need to use different methods. An outbound connection is typically used to connect an app to a database or other type of supporting resource.</p>
<p>App Service Hybrid Connections is a feature that allows an app to connect to a resource in an Azure virtual network or an on-premises environment. To make it work, you need to install Hybrid Connection Manager on a Windows Server that has access to both networks over port 443. App Service then uses this as a relay to connect to the other environment. The advantage of using Hybrid Connections is that it provides secure access even if you don’t have an ExpressRoute or VPN connection between your on-premises environment and Azure.</p>
<p>Another method is called VNet Integration. There are two different types: Regional VNet Integration and Gateway-required VNet Integration. The great thing about the Regional method is that you don’t need to install anything.</p>
<p>To configure it in App Service, you go into the Networking section of your app’s configuration and select VNet Integration. Then you just need to tell it which VNet you want to add. If the VNet that you want to integrate with is in the same region as the app, then the only requirement is that the VNet has to have an empty subnet that the Integration feature can use.</p>
<p>Once you’ve configured Regional VNet Integration, then your app can connect to resources in the VNet or in an on-premises network that’s connected to the VNet through ExpressRoute or a VPN. It can even connect to a VNet in a different region if there’s a peering connection between that VNet and the regional VNet.</p>
<p>Pretty much the only reason you’d need to use Gateway-required VNet Integration is if your app needs to connect to a VNet in another region that isn’t peered with a regional VNet. In that case, you’d need to install a virtual network gateway in the remote VNet. This method has a number of disadvantages, though, such as not allowing connections to on-premises environments over ExpressRoute. So, in most cases, it’s better to use Regional VNet Integration than Gateway-required VNet Integration.</p>
<p>And that’s it for configuring networking in Azure App Service. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Deploying-Code-From-GitHub-to-Azure-App-Service-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Deploying-Code-From-GitHub-to-Azure-App-Service-8/" class="post-title-link" itemprop="url">AZ-204-Deploying-Code-From-GitHub-to-Azure-App-Service-8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:04:48" itemprop="dateCreated datePublished" datetime="2022-11-14T11:04:48-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:29:22" itemprop="dateModified" datetime="2022-11-20T19:29:22-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Deploying-Code-From-GitHub-to-Azure-App-Service-8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Deploying-Code-From-GitHub-to-Azure-App-Service-8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Deploying-Code-From-GitHub-to-Azure-App-Service"><a href="#Deploying-Code-From-GitHub-to-Azure-App-Service" class="headerlink" title="Deploying Code From GitHub to Azure App Service"></a>Deploying Code From GitHub to Azure App Service</h1><p>Welcome to “Deploying Code from GitHub to Azure App Service”. To get the most from this course, you should already have some experience using App Service. If you don’t, then you can take our “<a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-azure-app-service-2185/introduction/">Introduction to Azure App Service</a>” and “<a target="_blank" rel="noopener" href="https://cloudacademy.com/course/using-deployment-slots-azure-app-service-2359/using-deployment-slots-in-azure-app-service/">Using Deployment Slots in Azure App Service</a>” courses. It would also be helpful to have some experience with GitHub, although it’s not a requirement.</p>
<p>Microsoft provides many ways to deploy code to App Service, but one of the best ways is to deploy from a source code repository, such as GitHub, Bitbucket, or Azure Repos. This is useful whether you need to upload your code once or need to implement continuous deployment in a DevOps environment.</p>
<p>In this short course, I’ll show you how to deploy code from GitHub to App Service both manually and using continuous deployment. Although it’s possible to do both using the Azure Portal’s graphical user interface, I’m going to use the command-line interface to do the manual deployment for a couple of reasons. First, you can use Azure commands in automation scripts. Second, Microsoft often asks command-line questions in its Azure Developer certification exam, so if you’re preparing to take that exam, it’s good to know these commands.</p>
<p>In this demo, I’m going to show you all of the commands you’ll need to use if you don’t have any App Service resources yet. First, I’m going to create a resource group to hold the resources. Then, I’ll create an App Service Plan to host the app. Next, I’ll create a webapp in the plan. And finally, I’ll deploy a sample app from one of Microsoft’s GitHub repositories to the webapp in App Service. The sample app is called “html-docs-hello-world”. It doesn’t do much, but it’ll be fine for demonstration purposes.</p>
<p>To use the command-line interface from your desktop, you need to install the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/overview-of-azure-services/using-azure-cli/">Azure CLI</a>. But an alternative is to use Azure Cloud Shell, which has the Azure CLI preinstalled. Click here to start it. If it’s your first time running Cloud Shell, then it’ll ask you to create a storage account that it can use. I’ve used Cloud Shell before, so mine already has a storage account.</p>
<p>Okay, first let’s create a resource group. You need to use the “az group create” command. Add the name parameter and call it “webapprg” for “webapp resource group”. Then add the location parameter and specify an Azure region. I’ll use “westus”.</p>
<p>As you’d expect in a course about GitHub, I put all of the commands from this demo in a readme file in a GitHub repository so you can copy and paste them. You can find a <a target="_blank" rel="noopener" href="https://github.com/cloudacademy/azure-app-service-github">link</a> to the repository in the Overview tab below this video.</p>
<p>All right, now we need to create an App Service plan using the “az appservice plan create” command. For the name parameter, I’ll call it “asplan” for “App Service Plan”. For the resource group, we need to say “webapprg”, which is the resource group we just created. For the location, we’ll use the same region as we did for the resource group. And finally, we have to specify the SKU, which means the pricing tier for the App Service Plan. F1 is the free tier, so we won’t have to pay anything.</p>
<p>Okay, now we need to create a webapp in the plan. This will essentially be a place to put our app when the time comes, so when we first create the webapp, it’ll be empty. We use the “az webapp create” command. The name has to be globally unique, so I’ll call it “ca” for “Cloud Academy”, “webapp”. You’ll have to call it something else. Then tell it to use the webapprg resource group and the App Service plan we just created, which we called asplan.</p>
<p>All right, now we have everything we need to deploy the app. The command we need is “az webapp deployment source config”. We need to give it a lot of parameters. You can put them in any order, but I’ll put them in the order that I think is most logical.</p>
<p>First, we’ll use the “repo-url” parameter to tell it where the GitHub repository is. This is the URL for the “html-docs-hello-world” sample app. Then we need to tell it which branch of the repository contains the code we want to deploy. In most cases, you’ll probably just want to deploy the master branch, but if you need to deploy a different branch, this is where you do it.</p>
<p>Next, we need to specify the “manual-integration” parameter. This means that we’re deploying the code manually rather than telling it to automatically deploy the app every time the code changes.</p>
<p>Then we tell it the name of the webapp where we want to deploy the code. And finally, we tell it which resource group the webapp is in. This’ll take a while, so I’ll fast-forward.</p>
<p>Okay, it’s done. Now we can see if it worked by going to the URL of the webapp, which is the name of the webapp and then “.azurewebsites.net”.</p>
<p>Yes, this is the sample hello world app, so it worked.</p>
<p>If you want to configure continuous deployment, which is where the app automatically gets deployed every time the code in the repository changes, then Microsoft recommends using the Azure Portal.</p>
<p>First, I’ll find my app in the portal. Here it is. Now, we need to go to the Deployment Center. Since we already did a deployment from GitHub, it shows the configuration we used. Here’s the URL of the GitHub repository. If we wanted to do another deployment manually, then we’d just click on “Sync” up here. But we’re going to set up continuous deployment, so first we need to get rid of this manual configuration, which we can do by clicking “Disconnect”.</p>
<p>It says, “You’re now in the production slot, which is not recommended for setting up continuous integration &#x2F; continuous deployment. That’s because if a new version of the app got deployed to the production slot, it would cause the app to be unavailable until the deployment is finished, which is not something you want to do to your users. The solution is to configure continuous deployment in a non-production deployment slot.</p>
<p>Since our App Service Plan is using the Free tier, which doesn’t support deployment slots, we’ll need to upgrade our plan to the Standard tier. To do that, we go to “Scale up”, choose the S1 tier, which means “Standard”, and click “Apply”.</p>
<p>There. Now we need to create a deployment slot, so we select “Deployment slots” in the menu, and then click “Add Slot”. We’ll call it “staging” and tell it to clone settings from the production slot.</p>
<p>Then we click on the slot, and now we can go back to the Deployment Center. Good, the warning is gone because now we’re in the staging slot, which is a non-production deployment slot.</p>
<p>In the “Source” dropdown, it gives us the option to set up either continuous deployment or manual deployment. Let’s select “GitHub” in the continuous deployment section.</p>
<p>Before it can deploy the app, it needs to build it. By default, it uses GitHub Actions to do the build, but it’s usually easier to change this to “App Service Build Service”. This means that App Service will take care of building it.</p>
<p>Now I need to authorize App Service to access my GitHub account.</p>
<p>Then I need to choose the organization, the repository, and the branch. I don’t have privileged access to Microsoft’s sample repository, so it’s not something I can select here. Instead, I copied Microsoft’s repository to my own organization, where I do have privileged access. Then I’ll click “Save”.</p>
<p>That worked, so now whenever the code in the master branch of my copy of the repository changes, it will automatically build and deploy the app to the staging slot. Then I could swap the staging slot with the production slot to upgrade the production version of the app. Alternatively, I could configure auto swap on the staging slot, so it would automatically swap the slot with production once the app is running.</p>
<p>If you’ve been following along on your own, make sure to either downgrade the App Service Plan to the free tier or delete the whole resource group. That way, you won’t incur any more charges.</p>
<p>And that’s it for deploying code from GitHub to Azure App Service. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>
<h2 id="Deploying-Code-From-GitHub-to-Azure-App-Service-1"><a href="#Deploying-Code-From-GitHub-to-Azure-App-Service-1" class="headerlink" title="Deploying Code From GitHub to Azure App Service"></a><strong>Deploying Code From GitHub to Azure App Service</strong></h2><p><a target="_blank" rel="noopener" href="https://github.com/cloudacademy/azure-app-service-github">Course GitHub repo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Lab-Deploying-And-Monitoring-Azure-App-Service-Web-Apps-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Lab-Deploying-And-Monitoring-Azure-App-Service-Web-Apps-7/" class="post-title-link" itemprop="url">AZ-204-Lab-Deploying-And-Monitoring-Azure-App-Service-Web-Apps-7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 11:04:07" itemprop="dateCreated datePublished" datetime="2022-11-14T11:04:07-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:32:56" itemprop="dateModified" datetime="2022-11-20T19:32:56-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Lab-Deploying-And-Monitoring-Azure-App-Service-Web-Apps-7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Lab-Deploying-And-Monitoring-Azure-App-Service-Web-Apps-7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Using-Deployment-Slots-in-Azure-App-Service-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Using-Deployment-Slots-in-Azure-App-Service-6/" class="post-title-link" itemprop="url">AZ-204-Using-Deployment-Slots-in-Azure-App-Service-6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 06:40:15" itemprop="dateCreated datePublished" datetime="2022-11-14T06:40:15-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:29:10" itemprop="dateModified" datetime="2022-11-20T19:29:10-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Using-Deployment-Slots-in-Azure-App-Service-6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Using-Deployment-Slots-in-Azure-App-Service-6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Using-Deployment-Slots-in-Azure-App-Service"><a href="#Using-Deployment-Slots-in-Azure-App-Service" class="headerlink" title="Using Deployment Slots in Azure App Service"></a>Using Deployment Slots in Azure App Service</h1><p>Welcome to “Using Deployment Slots in Azure App Service”. To get the most from this course, you should already have some basic experience using App Service. If you don’t, then you can take our “Introduction to Azure App Service” course.</p>
<p>App Service makes it easy to deploy a new version of an app to production. All you have to do is run the “az webapp up” command. But you’d normally want to test a new version thoroughly before putting it into production. So you need a testing environment that’s as close as possible to your production environment.</p>
<p>App Service has a great solution. It’s called a deployment slot. By default, an app has one deployment slot called “Production”. But you can create other deployment slots, too, and give them names like “testing” and “staging”. Then when you deploy an app, you can choose which deployment slot to put it in.</p>
<p>Here’s a typical way to do it. First, you clone your production slot to a staging slot. When you do this, you can choose to clone the production slot’s configuration, including app settings, connection strings, the language framework, and many other settings. That way your staging slot’s configuration will be as close as possible to your production slot’s configuration, which will make your testing more valid.</p>
<p>Once you’ve cloned the slot to a new one, though, you can change any of those settings in the new slot if you need to. For example, you might change the version of the language framework to a newer version, such as going from Java 8 to Java 11.</p>
<p>You might expect it to clone the actual app as well, and not just the settings, but it doesn’t. That’s because it expects you to upload a new version of the app to the staging slot, so there’s no point in cloning the production app.</p>
<p>Note that if you use the command line to upload the app to the staging slot, you can’t use the “az webapp up” command. Instead, you have to use the “az webapp deployment source” command, which takes a bit more work. The most common deployment source is a git repository.</p>
<p>Once you’ve tested the new version in your staging slot, the next step is to swap the staging slot with the production slot. You start by setting the source slot and the target slot. The source slot contains the new version of the app, so it’s the staging slot. The target slot is the one that will be running the new version once the swap has been completed, so it’s the production slot.</p>
<p>When you tell it to swap the source and target slots, it swaps not only the two different versions of your app but also any settings that you changed in the staging slot, such as the language framework if you changed that.</p>
<p>However, there is an exception to this. You can create slot-specific settings. For example, it’s usually a good idea to have a separate test database so you don’t mess up the production one when you’re testing a new version of your app in the staging slot. In this case, you’d need to have a different connection string for the database in each slot, and you wouldn’t want this setting to be swapped. It would need to stay with the slot rather than the app, which is why it’s called slot-specific. So when you add or change an application setting or a connection string in a non-production slot, you have the option of making it a slot-specific setting.</p>
<p>Aside from giving you the ability to properly test a new version before putting it into production, there are a couple of other big advantages to using a swap to deploy an app. First, when you deploy a new version of an app, it will often cause a reboot of the virtual machines that are used to host the app. During the warm-up period when the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/getting-started-with-azure-virtual-machines-988/what-is-a-virtual-machine/">VM instances</a> are spinning up, the app is not available, so if you were to simply deploy the new version of the app to production, it would cause downtime. But if you deploy to a staging slot first, then the VM instances have a chance to warm up before you swap the slot with production.</p>
<p>Second, if there’s a problem after you swap the new version into production, you can easily roll back and revert to the previous version. All you have to do is swap the two slots again. If you’ve ever had to quickly roll back a new version that you’ve deployed, then I’m sure you can appreciate how helpful this feature is.</p>
<p>There’s also an option that makes the swap even safer if you have slot-specific settings. It’s called “swap with preview”. This does the swap in two phases. First, it temporarily copies the slot-specific settings from the target slot (that is, the production slot) to the source slot (that is, the staging slot). It then gives you a chance to test the new version of the app with all of the settings it will have after the swap is completed.</p>
<p>If it doesn’t work, then you can cancel the swap. If it does work, then you can tell it to complete the swap. At that point, it swaps the app and the other settings between the two slots. But it leaves the slot-specific settings with each slot. So the version of the app that was previously in production and is now in the staging slot has the connection string for the test database, for example.</p>
<p>There’s also a riskier option for doing a swap. If you enable “auto swap” on a slot, then every time you push a new version of your app to that slot, it will automatically swap it with whichever slot you specify. So, for example, if you enable “auto swap” on the staging slot, and you set the “Auto swap deployment slot” to the Production slot, then every time you upload a new version of the app to the staging slot, it will automatically be swapped into Production.</p>
<p>Why on earth would you do such a thing? Well, you might want to do this as part of an <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-a-build-strategy-for-continuous-integration-with-azure-devops/introduction/">automated DevOps process</a>. If you have a continuous integration system that automatically tests your app every time you commit new changes to the source code repository, then you might feel comfortable putting new versions into production without doing any manual testing.</p>
<p>So, if that’s the case, then why bother pushing it to the staging slot first and then auto-swapping it into production? Why not just push it straight to production? Well, as I mentioned earlier, when you push an app to the staging slot first, it has a chance to warm up before going into production.</p>
<p>In fact, it’s even possible to create a custom warm-up. If your app needs to be initialized before it can serve requests from users, then you can create a custom warm-up that makes sure the initialization is complete before it performs the swap. There are two ways to set this up. If your app is running on an IIS web server, then you can configure the applicationInitialization element in the web.config file. Alternatively, regardless of the web server you’re using, you can set WEBSITE_SWAP_WARMUP_PING_PATH and WEBSITE_SWAP_WARMUP_PING_STATUSES in the app settings in <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/getting-started-with-azure-app-service-949/introduction/">Azure App Service</a>.</p>
<p>So far, I’ve only talked about having two slots and having all of your end-user traffic go to the production slot. But you can have more complicated configurations if you want. First, you can have more than two slots. For example, you might want to have separate development, testing, staging, and production slots to handle the different stages of your software development process.</p>
<p>Second, you can make things really interesting by sending some of your end-user traffic to non-production slots. For example, suppose you want to do canary testing, which means that you want to reduce the risk involved with deploying a new version of your app by releasing the new version to only a small percentage of your users. Then if those users don’t have any problems with it, you can release it to the rest of your users.</p>
<p>App Service supports this type of testing by allowing you to set a different percentage of traffic for each slot. Normally, the production slot is set to take 100% of the traffic and all other slots are set to take 0%. But if you wanted to do a canary test, you could set the staging slot to 5% and the production slot to 95%. Then after you’ve done your testing, you could swap the two slots, which would put the staging version into production, and then set the production slot to take 100% of the traffic again.</p>
<p>I should mention that the total number of slots you can use depends on the pricing tier of the App Service Plan you’re using. Deployment slots are only supported in the Standard, Premium, and Isolated tiers. The Standard tier supports up to 5 slots, but the Premium and Isolated tiers support up to 20. So if you’re using the Standard tier, and for some reason, you need more than 5 slots, you can just scale up your service plan to the Premium tier.</p>
<p>And that’s it for deployment slots in Azure App Service. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Autoscaling-on-Azure-App-Service-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Autoscaling-on-Azure-App-Service-5/" class="post-title-link" itemprop="url">AZ-204-Autoscaling-on-Azure-App-Service-5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 06:38:51" itemprop="dateCreated datePublished" datetime="2022-11-14T06:38:51-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:30:04" itemprop="dateModified" datetime="2022-11-20T19:30:04-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Autoscaling-on-Azure-App-Service-5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Autoscaling-on-Azure-App-Service-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Autoscaling-on-Azure-App-Service"><a href="#Autoscaling-on-Azure-App-Service" class="headerlink" title="Autoscaling on Azure App Service"></a>Autoscaling on Azure App Service</h1><p>Welcome to “Autoscaling on Azure App Service”. To get the most from this course, you should already have some basic experience using App Service. If you don’t, then you can take our “<a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-azure-app-service-2185/introduction/">Introduction to Azure App Service</a>” course.</p>
<p>All right, let’s get started. If you need to add more resources to an app running on App Service, one way is to scale up its resources by switching its App Service Plan to a higher pricing tier. This is very easy to do, and it only takes a few seconds, but it’s not a very dynamic solution. For example, what if your app gets used a lot more on weekdays than on weekends? You wouldn’t want to scale up and scale down your app’s service plan every week.</p>
<p>A more elegant solution is to have Azure add more virtual machines when your app is busier and remove VMs when it’s less busy. This is known as scaling out and scaling in rather than scaling up and scaling down. It’s only available on Basic plans and higher. It’s not available on Free or Shared plans.</p>
<p>Keep in mind, though, that even the Basic tier probably won’t give you what you need. That’s because it only allows you to scale in and out manually. If you want Azure to scale without manual intervention, then you need autoscaling, which is only available on Standard plans and higher.</p>
<p>The service that actually handles autoscaling is Azure Monitor. So, you can get to the autoscale settings either by selecting “Scale out” from the menu in your Service Plan or by going to Azure Monitor and selecting “Autoscale” and then selecting your Service Plan.</p>
<p>The way it works is that you can create one or more scale conditions that specify exactly what will trigger Azure to add or remove virtual machines. In each scale condition, you need to add one or more rules. For example, you could say that if the average CPU percentage of the VMs in your Service Plan is over 75% for at least 10 minutes, then it should increase the number of VM instances by one.</p>
<p>There are a huge number of variations in the rules that you can create. First, there are different metrics to choose from. Aside from CPU percentage, there’s also memory percentage, data in, data out, disk queue length, and a wide variety of network metrics, such as “Socket count for inbound requests”.</p>
<p>You can also tell it to look for the minimum or maximum value of a metric rather than the average. For example, you could tell it to scale out if the CPU percentage reaches 75% at any time during a 10-minute period.</p>
<p>It doesn’t have to be a 10-minute period either. You can set it to aggregate the metric over any number of minutes you want. And, of course, it doesn’t need to be 75%. You can set that to whatever percentage you want, too.</p>
<p>Then there’s the scaling action that you want it to take. You can tell it to scale out by exactly a certain number of VM instances, such as 1 in our example, or scale out to a total number of instances, such as 3, or you can tell it to scale out by a percentage. For example, you can tell it to scale out the number of instances by 50% if the condition is met.</p>
<p>You can also set something called a “cool down” period. This is the number of minutes to wait after a scaling operation before it can scale again. By default, it’s set to 5 minutes. This gives the metrics a chance to stabilize again after the scaling operation.</p>
<p>For example, suppose you have a rule saying that if the average CPU percentage is over 70% for 5 minutes, then add an instance. Then suppose you have 2 instances, and the average CPU percentage reaches 90%, which causes it to add another instance. If you didn’t have a cool-down period, the CPU percentage might still be above 70% for a little while until the new instance has spun up and taken some load off of the other instances, which could trigger the unnecessary addition of yet another instance.</p>
<p>So far, I’ve only mentioned scaling out, but you can create rules for scaling in as well. They work the same way except that everything is reversed. For example, you could tell it to scale in by one instance if the average CPU percentage is below 25% during a 10-minute period.</p>
<p>Now, things really get interesting when you have multiple rules. For example, suppose that you have these rules:</p>
<ul>
<li>Scale out by one instance if CPU utilization is above 65 percent</li>
<li>Scale out by one instance if disk queue length reaches more than 1700</li>
<li>Scale in by one instance if CPU utilization drops below 35 percent</li>
</ul>
<p>Now suppose that your instances are at 30 percent CPU utilization, and the disk queue length is 1900 messages. Will it scale in or scale out or stay the same? The answer isn’t obvious because there are conflicting rules. The CPU utilization is below 35 percent, so maybe it will scale in by one instance. But the disk queue length is more than 1700, so maybe it will scale out by one instance. Do the two rules cancel each other out, or does one of them have priority? Well, Azure autoscaling has a very sensible policy in these situations. Scale-out rules always win over scale-in rules. That’s because if any aspect of the system needs more resources, then it should scale out. Scaling in would just make performance worse.</p>
<p>Okay, that was a lot of information, but believe it or not, there are a couple of other important autoscaling options that I haven’t mentioned yet: scaling to a specific instance count and scheduling.</p>
<p>Previously, I showed scaling based on a metric, such as CPU percentage, but it’s also possible to create a scale condition that doesn’t involve metrics. To do this, you select “Scale to a specific instance count” instead of “Scale based on a metric” when you create a scale condition. This is much simpler than the metric-based process. You just tell it the number of instances you want it to scale to.</p>
<p>Of course, this doesn’t really sound like autoscaling, does it? Without a metric, how will it know when to scale to a specific instance? That’s where scheduling comes in. You simply set a start time and an end time for when this condition should be in effect. If you want it to happen on a recurring basis, you can select “Repeat specific days” and tell it which days you want it to happen every week. For example, you could scale out to a specific instance count on weekdays.</p>
<p>It’s also possible to use a schedule for a metric-based condition. For example, you could configure it to scale based on CPU percentage only on weekends but scale out to a specific instance count during weekdays. In this example, you’d have both metric-based and specific instance-based conditions in the same Service Plan, but since you scheduled them for different days, there wouldn’t be a conflict.</p>
<p>And that’s it for autoscaling on Azure App Service. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>
<h2 id="1Autoscaling-on-Azure-App-Service"><a href="#1Autoscaling-on-Azure-App-Service" class="headerlink" title="1Autoscaling on Azure App Service"></a>1<strong>Autoscaling on Azure App Service</strong></h2><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-azure-app-service-2185/introduction/">Course: Introduction to Azure App Service</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Introduction-to-Azure-App-Service-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/AZ-204-Introduction-to-Azure-App-Service-4/" class="post-title-link" itemprop="url">AZ-204-Introduction-to-Azure-App-Service-4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 06:38:17" itemprop="dateCreated datePublished" datetime="2022-11-14T06:38:17-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:28:28" itemprop="dateModified" datetime="2022-11-20T19:28:28-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-204/" itemprop="url" rel="index"><span itemprop="name">AZ-204</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Introduction-to-Azure-App-Service-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Introduction-to-Azure-App-Service-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to “Introduction to Azure App Service”. I’m Guy Hummel, and I’m a certified Azure Developer and Solutions Architect.</p>
<p>In this course, I’ll start with an overview of Azure App Service, and then I’ll show you how to create a simple app. Finally, I’ll go over App Service Plans. This course is not intended to explain every aspect of Azure App Service, which is quite a complex product. Instead, it’s intended to help you get started with hosting web apps on Azure. We cover additional aspects of App Service, such as autoscaling, deployment slots, networking, and security, in other courses.</p>
<p>To get the most from this course, you should already have some basic experience using Azure. If you don’t have any experience with Azure, then you can take our “Microsoft Azure Fundamentals” learning path.</p>
<p>We’d love to get your feedback on this course, so please give it a rating when you’re finished. Thanks!</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>When you need to host a website on Azure, there are lots of potential choices. If it’s a static website that doesn’t require any interactions with users, then you can just store your website in Azure Storage and serve it from there. If you need to host something more sophisticated, then you could deploy it on an Azure virtual machine that’s running a content management system, such as WordPress. If you’ve built a microservices-based application in Docker containers, then you could run it on Azure Kubernetes Service.</p>
<p>But the most popular way to do it is to use Azure App Service. Why? Well, because App Service tries to make deploying a web application as easy as possible while still providing lots of flexibility and features. It’s considered to be a platform-as-a-service rather than infrastructure-as-a-service because it manages the underlying infrastructure for you. This means you don’t have to worry about things like patching the operating system.</p>
<p>App Service supports a wide variety of programming languages and frameworks, including ASP.NET, ASP.NET Core, Java, Ruby, Node.js, PHP, and Python. Not only do these come preinstalled, but they’re also updated when new patches or releases are available. For most of these frameworks, you can choose whether to run it on Windows or Linux (although that’s not the case with ASP.NET Framework 4.8, which can only run on Windows).</p>
<p>Even if you want to use a different programming language, you can still use App Service if you put your application in a Docker container that has the right dependencies installed in it.</p>
<p>There are other key development and deployment features, too. First, it’s well-integrated with Visual Studio and Visual Studio Code, which are the preferred programming environments for many software developers. It’s also integrated with continuous integration &#x2F; continuous delivery tools, such as Azure DevOps, GitHub, and BitBucket. You can also use App Service to host mobile backends and application programming interfaces.</p>
<p>Aside from the ease of deployment and maintenance, one of the biggest advantages of using App Service is its enterprise-class features. First, there’s high availability. Microsoft guarantees 99.95% uptime in most cases for apps running on this service. Then there’s scalability. You can configure it to automatically add more resources to your application when demand increases.</p>
<p>Of course, security is important, too, so Microsoft provides authentication capabilities if you only want authorized users to be able to access your apps. It also lets you control which IP addresses are allowed or denied access to your site if you want.</p>
<p>There are other features as well, but this should give you a good idea of why App Service is the preferred choice for hosting web apps on Azure.</p>
<h1 id="Creating-a-Simple-App"><a href="#Creating-a-Simple-App" class="headerlink" title="Creating a Simple App"></a>Creating a Simple App</h1><p>Now I’ll show you how easy it is to deploy an application on Azure App Service. In fact, it only takes one command to do it.</p>
<p>There are a few different options for where we could deploy it from. We could use Visual Studio, Visual Studio Code, or the Azure Command-Line Interface. I’m going to use the Azure CLI because it’s possible to use it without having to install anything. Microsoft provides something called the Cloud Shell that brings up a small virtual machine that has the Azure CLI and other tools installed on it.</p>
<p>To open it, you click here in the Azure Portal. If you haven’t used it before, then it’ll ask you for permission to create a storage account that the Cloud Shell VM can use. But I’ve used it before, so it comes right up.</p>
<p>Before we can deploy an app, we need to get one from somewhere. I’m going to use a sample .NET application. To get it, you can type this command.[dotnet new webapp -n MyFirstAzureWebApp -f net6.0 &amp;&amp; cd MyFirstAzureWebApp] To save you some typing, I’ve included this command in the transcript below. This command also moves you into the MyFirstAzureWebApp folder, which is where the app was downloaded.</p>
<p>Now that we have the app, we can deploy it to App Service using this command.[az webapp up –sku F1 –name <app-name>] The “az” means it’s an Azure command. “webapp” is the command for App Service. “up” tells it to create the web app using the code in the current directory. “sku F1” means that we want to use the free tier so we won’t be charged for this service. I’ll explain more about service tiers later. Then we say “–name” and what we want to call the app. I’m calling it “ca” for Cloud Academy”, “webapp”. You’ll have to call it something else because the name has to be unique among all of the App Service names across all Azure customers.</app-name></p>
<p>There are quite a few other options we can add, but we can get away with only including these ones. Some of the other most common options are:</p>
<ul>
<li>–resource-group for the resource group that it will put your App Service instance in</li>
<li>–location to specify the Azure region where your app will be hosted</li>
<li>–plan to specify which App Service Plan to use. I’ll tell you more about this in the next lecture.</li>
<li>–os-type, which can be either Windows or Linux. If you don’t specify one, then it’ll default to “Windows”.</li>
</ul>
<p>Since we didn’t specify any of these options, it’s going to create a new resource group and a new App Service Plan using default names, it will put everything in your default location, and it will use Windows for the operating system.</p>
<p>[Hit Enter]Okay, this is going to take a while, so I’ll fast-forward.</p>
<p>All right, it’s done. You can see the choices it made for the options we left out. For example, here’s what it called the App Service Plan, and here’s what it called the resource group.</p>
<p>Now to bring up the app we just deployed, we can use this link. We can click on it, but notice that it’s going to include the quote at the end, so it’ll give us an error. That’s okay because we can just remove the extra bit at the end.</p>
<p>That’s better. This is a very simple web page because that’s all that’s in the sample app. Now, suppose we wanted to make a change to the app. Normally, you’d probably do that in either Visual Studio or Visual Studio Code, but we can actually do it from Cloud Shell, too.</p>
<p>If you click here, it’ll bring up an editor. First, we’ll go into the MyFirstAzureWebApp folder, and then go into the Pages folder, which is where we’ll find the home page for our app. It’s called Index.cshtml.</p>
<p>Right now, the main text on the home page is just “Welcome”. Let’s change it to “Welcome to Azure”. Now we’ll save it and then close the editor.</p>
<p>Okay, we’re back at the command line. If we hit the up arrow, it’ll bring back our previous command. To update our app, we’ll use the “az webapp up” command again, but this time, we don’t need to specify the sku or the name.[Erase them and hit Enter.] I’ll fast-forward again.</p>
<p>All right, it’s done. Now if we go back to the web page and hit refresh, you’ll see that the message changed to “Welcome to Azure”, so it worked.</p>
<p>And that’s it for creating and updating a simple app.</p>
<h1 id="App-Service-Plans"><a href="#App-Service-Plans" class="headerlink" title="App Service Plans"></a>App Service Plans</h1><p>Although Azure App Service takes care of managing the underlying infrastructure for you, you still need to decide what type of infrastructure it should use. To do that, you need to create an App Service Plan.</p>
<p>The three main settings you have to choose in an App Service Plan are the operating system, the region, and the pricing tier. The operating system can be either Windows or Linux. For the region, you typically choose the one that’s closest to where most of your users are located, such as East US. Bear in mind that you can’t change a service plan’s region. So if you decide to move an app to another region later, you’ll have to make a copy of it and put it in a new App Service Plan.</p>
<p>Those first two settings are usually pretty easy to choose, but the pricing tier is much more complex. This is where you decide what type of compute resources to allocate and what App Service features you want. This table shows a summary of the different tiers, although it doesn’t actually show all of the options and features in each tier. I’ll walk you through some of the highlights.</p>
<p>If you’ll be using this plan for development and testing, then you can probably get away with using a low-powered and inexpensive option. The Free tier is a good choice as long as you only need 60 CPU minutes per day. If you need more CPU time than that, then you’ll have to go with a plan that costs money.</p>
<p>The next step up is the Shared tier, which is also known as the D1 tier. It gives you up to 240 CPU minutes per day. It’s called the Shared tier because you have to share compute resources with other Azure customers. That’s the case with the Free tier as well. Both of these tiers have just one gig of RAM and one gig of storage, so you can’t do too much with them. The Shared tier also allows you to use a custom domain name for your app’s website, which isn’t something you can do with the Free tier.</p>
<p>If you need more resources, then you can go with the Basic tier, which puts your apps on dedicated virtual machines instead of shared VMs. There are several options that vary based on the number of virtual CPU cores and the amount of memory. All of the options come with 10 gig of storage.</p>
<p>The next step up is the Standard tier, but although it has 50 gig of storage instead of 10 gig, the CPU and memory options are exactly the same as the Basic tier. The big difference is that the Standard tier supports autoscaling, which means it can automatically add more virtual machines to handle increased traffic. It lets you use up to 10 VM instances. That’s significantly more than the Basic tier, which has a maximum of 3 VM instances.</p>
<p>The Premium tier has options for more CPU, memory, and storage, and it lets you use up to 30 VM instances in most Azure regions.</p>
<p>The Isolated tier gives you a private, dedicated environment that’s in its own virtual network. While the Standard and Premium tiers allow you to connect your dedicated VMs to a virtual network, the Isolated tier actually puts your VMs in a private virtual network so they’re isolated from other App Service instances. It lets you have up to 100 VM instances.</p>
<p>Regardless of which pricing tier you choose, it’s possible to put multiple apps in your service plan. But all of those apps will share the same compute resources, so if you put too many apps in the same service plan, then you’ll run into performance issues.</p>
<p>One potential way to resolve this problem would be to add more virtual machine instances up to the limit of the number of instances allowed in the pricing tier you’ve chosen. This is known as scaling out. It’s also possible to set up autoscaling, which is such a complex topic that we cover it in a separate course.</p>
<p>If scaling out doesn’t solve the problem, then you can switch your plan to a pricing tier that has more powerful instances and&#x2F;or a higher limit on the number of instances you can have. This is called scaling up, and it’s very easy to do. You can simply select the new pricing tier, and it will only take seconds to go into effect.</p>
<p>And that’s it for App Service Plans.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>All right, let’s do a quick review of what you’ve learned.</p>
<p>Azure App Service tries to make deploying a web application as easy as possible by managing the underlying infrastructure for you.</p>
<p>It supports a wide variety of programming languages and frameworks, including ASP.NET, ASP.NET Core, Java, Ruby, Node.js, PHP, and Python. For most of these frameworks, you can choose whether to run it on Windows or Linux (although that’s not the case with ASP.NET Framework 4.8, which can only run on Windows).</p>
<p>To use a different programming language, put your application in a Docker container that has the right dependencies installed in it.</p>
<p>You can deploy apps to App Service from Visual Studio, Visual Studio Code, or the Azure Command-Line Interface. To do it from the command line, use “az webapp up”.</p>
<p>The three main settings you have to choose in an App Service Plan are the operating system, the region, and the pricing tier.</p>
<p>If you choose the Free tier or the Shared tier, you have to share compute resources with other Azure customers.</p>
<p>If you choose the Basic tier or higher, your apps will be put on dedicated virtual machines instead of on shared VMs.</p>
<p>Autoscaling is supported on the Standard tier and higher.</p>
<p>The Premium tier has options for more CPU, memory, and storage.</p>
<p>The Isolated tier gives you a private, dedicated environment that’s in its own virtual network.</p>
<p>Regardless of which pricing tier you choose, you can put multiple apps in your service plan. But all of those apps will share the same compute resources.</p>
<p>You can scale up the resources in your service plan by switching to a higher pricing tier. You can scale out your service plan’s resources by adding more VMs.</p>
<p>That’s all for now. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/141/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/141/">141</a><span class="page-number current">142</span><a class="page-number" href="/page/143/">143</a><span class="space">&hellip;</span><a class="page-number" href="/page/274/">274</a><a class="extend next" rel="next" href="/page/143/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
