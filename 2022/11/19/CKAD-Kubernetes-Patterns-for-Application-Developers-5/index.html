<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to Kubernetes patterns for application developers. This course will help you expand your knowledge about Kubernetes, particularly what is important for application developers wor">
<meta property="og:type" content="article">
<meta property="og:title" content="CKAD-Kubernetes-Patterns-for-Application-Developers-5">
<meta property="og:url" content="https://example.com/2022/11/19/CKAD-Kubernetes-Patterns-for-Application-Developers-5/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to Kubernetes patterns for application developers. This course will help you expand your knowledge about Kubernetes, particularly what is important for application developers wor">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T04:31:29.000Z">
<meta property="article:modified_time" content="2022-11-21T04:24:22.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/CKAD-Kubernetes-Patterns-for-Application-Developers-5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CKAD-Kubernetes-Patterns-for-Application-Developers-5 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/CKAD-Kubernetes-Patterns-for-Application-Developers-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CKAD-Kubernetes-Patterns-for-Application-Developers-5
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:31:29" itemprop="dateCreated datePublished" datetime="2022-11-19T00:31:29-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-21 00:24:22" itemprop="dateModified" datetime="2022-11-21T00:24:22-04:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CKAD-Certification/" itemprop="url" rel="index"><span itemprop="name">CKAD-Certification</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/CKAD-Kubernetes-Patterns-for-Application-Developers-5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/CKAD-Kubernetes-Patterns-for-Application-Developers-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to Kubernetes patterns for application developers. This course will help you expand your knowledge about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-kubernetes/introduction/">Kubernetes</a>, particularly what is important for application developers working with Kubernetes. What you will learn will not only be useful for your career, but also preparing you for the certified Kubernetes application developer certification exam. There are some tips included to help you succeed under the high pressure, time limited exam situation. I’m Logan Rakai, and I’ll be your trainer for this course.</p>
<p>I’m a content researcher and developer here at Cloud Academy. I have over 10 years of experience in software research and development and I’ve been working in the cloud since 2012. I’m a certified Kubernetes application developer and a certified Kubernetes administrator. I have also been involved with software development since 2007. You can connect with me on LinkedIn or on Twitter. This course is intended for application developers that are leveraging containers and using, or considering using Kubernetes as a platform for deploying applications but many parts of this course, appeal to a broader audience of Kubernetes users. Some of the individuals that may benefit from taking this course include, application developers, <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/devops/">DevOps</a> engineers, software testers, and Kubernetes certification examinees.</p>
<p>This course will help you succeed in designing, building, and configuring cloud native applications for Kubernetes. The lessons aim to prepare you for the certified Kubernetes application developer exam and therefore focus on specific patterns in Kubernetes, rather than writing application code. This course has lessons covering the following topics. The first lesson we’ll teach you several <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/multi-container-patterns/">multi-container patterns</a> for Kubernetes pods. You’ll understand why pods allow for multiple containers and patterns that make the most out of having multiple containers in a pod.</p>
<p>After that we’ll cover several networking concepts in Kubernetes. You will learn how to control internal and external access to applications running in a Kubernetes cluster. Next, you will learn about service accounts for Kubernetes. Service accounts provide a mechanism for pods to authenticate themselves in the cluster. You will understand why you might need service accounts and how to configure them. The last lesson focuses on showing you different ways to leverage kubectl, the command line tool for working with Kubernetes. What you learn here will be useful for certification exams and for boosting your productivity at the command line when working with Kubernetes. Other topics important to application developers such as pod design and observability are the subject of several labs here on Cloud Academy. Some topics really are learned best in the hands on environments provided by our labs. I strongly encourage you to try the Kubernetes labs after taking this course. To get the most out of this course, you should know about Core Kubernetes resources, including pods and deployments. </p>
<p>You should have some experience with the kube control command line tool for working with Kubernetes. You will also benefit from understanding the YAML and JSON file formats. You probably already have this skill if you have the prior too. When you work with Kubernetes, it won’t take long until YAML files make an appearance. If you’re not sure if you meet all these pre-requisites, I’d highly recommend you go through the introduction to Kubernetes course, here on Cloud Academy. Before taking this course, you can follow along with the course examples and I’d encourage you to. You can use whatever Kubernetes cluster you have access to including clusters you can run locally, for example using Docker Desktop for Mac or Windows, or MiniKube. </p>
<p>I’ve put the resources that I use for the demos of this course on Cloud Academy’s GitHub account under the Kubernetes patterns for application developers repository. I’m happy to hear from you and I make content for you and I want it to be as good as it can be. Please give the course a rating, please give the course a rating and send along your feedback when you’re finished. And with that, it’s time to start learning about Kubernetes patterns for application developers. Start the next lesson when you’re ready.</p>
<h1 id="Multi-container-Patterns"><a href="#Multi-container-Patterns" class="headerlink" title="Multi-container Patterns"></a>Multi-container Patterns</h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/introduction/">Kubernetes</a> pods allow you to have multiple containers sharing the same network space and can also share storage between <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">containers</a>, often using a single container is the right choice for a pod, but there are several common patterns for when you should use multiple containers. That is the topic of this lesson. In this lesson, we will first explain the motivation behind pods, and then, we’ll dive into three multi-container patterns, the sidecar, the ambassador, and the adapter. Pods are an extra level of abstraction above containers. What benefits do we get by having this extra level of abstraction? Containers alone aren’t enough for Kubernetes to effectively manage workloads. Pods allow you to specify additional information such as restart policies and probes to check the health of containers. Pods also allow you to seamlessly deal with different types of underlying containers, for example, Docker and Rocket.</p>
<p>You deal with pods regardless of the underlying container runtime by allowing multiple containers to share network and storage in a pod, you can have tightly coupled containers co-located and managed as a single unit, without needing to package them as a single container image. This allows for better separation of concerns, and can improve container image reusability. The patterns in this listen will illustrate this benefit. The first pattern we will cover is the sidecar pattern. It is the most common one. As the name suggests, the sidecar pattern uses a helper container to assist a primary container. Common examples include logging agents that collect logs and ship them to a central aggregation system. The logging example is explored in the Kubernetes observability lab, here on Cloud Academy. Other examples include file sync services and watchers. We’ll consider a file sync sidecar shortly.</p>
<p> All of these examples add useful functionality to the main container, and can be accomplished by adding a sidecar, rather than burdening the main container with additional responsibilities. It makes it easier for different development teams to work on each application separately, and also makes testing easier. Furthermore, you get the benefit of failure isolation. If the sidecar fails, say the logging agent fails, then the main container, say a web server, can continue to surf traffic. You can also independently update the sidecar container. It’s worth pointing out here that all of these benefits are also true for the other multi-container design patterns that we’ll cover. Let’s take a look at a diagram for a file sync sidecar. The primary container in the pod is the web server container. The sidecar is a content puller. The content puller syncs with an external content management system, or CMS, to get the latest files for the web server to serve. </p>
<p>The web server serves the content to any clients that request it. How does the web server get the latest content from the content puller? They share the content by using a shared storage volume. The sidecar pattern is covered in depth in the Kubernetes observability lab. You’ll see a pod manifest for configuring the sidecar pattern there. The second pattern we’ll cover is the ambassador pattern. The ambassador pattern uses a container to proxy communication to and from a primary container. The primary container only needs to consider connecting to localhost, while the ambassador controls proxying the connections to different environments. This is because containers in the same pod share the same network space, and can communicate with each other over localhost. </p>
<p>This pattern is commonly used to communicate with a database. You can configure environment and variables in the primary container to control the database connection, but with the ambassador pattern, the application can be simplified to always connect to localhost, with the responsibility of connecting to the right database given to the ambassador. In production environments, the ambassador can implement logic to work with sharded databases as well, but the application in the primary container only needs to consider a single logical database, accessible over localhost. Some of the other benefits of the ambassador pattern are that during application development you can run a database on your local machine without requiring the ambassador, keeping the development experience simple. The ambassador may also be used by multiple applications written in different languages. Since that responsibility is taken out of the primary application let’s visualize the ambassador pattern to reinforce the key points. This example is for a web app that uses a database for persistence. </p>
<p>The primary container is the web app and the ambassador is a database proxy container. The web app handles requests from clients and when the data needs to be updated the web app sends a request over local host, where it is received by the database proxy. The database proxy then forwards the request to the correct database backend. The database could have a single endpoint, or the database could be shared across multiple database instances. The ambassador can encapsulate the logic for sharding the requests in the latter case. Meanwhile, the web app is free from any of the associated complexity. Now let’s consider our final pattern, the adaptor pattern. The adaptor pattern uses a container to present a standardized interface across multiple pods. For example, presenting an interface for accessing output in a standardized format for logs, across several applications. The adaptor pattern is the opposite of the ambassador pattern, in that the ambassador presents a simplified view to the primary container while the adaptor pattern presents a simplified view of the application to the outside world. </p>
<p>The adaptor pattern is commonly used for normalizing application logs, or monitoring data, so they can easily be consumed by a shared aggregation system. The adaptor may communicate with the primary container using either a shared volume when dealing with files or over localhost. For example, when getting metric data from a rest API. The adaptor pattern allows you to adapt an application output without requiring code changes. This may be required when you do not have access to an applications source code. Even if you do have access to the source, it is a cleaner separation of concerns to use an adaptor for each potential interface that may be required, rather than burdening the application with that complexity. Let’s go through a demo illustrating how to implement the adaptor pattern. Here we have a pod manifest of a pretend legacy application. The application outputs raw metric data to a file every five seconds. </p>
<p>The problem is that the format can’t readily be consumed by your monitoring solution. Your monitoring solution requires JSON formatted data. You can see in the args, that the metrics are simply the date and the raw output of the top command, which measures system and process resource usage. Let’s view the contents of raw output using the exec command to display the content with cat. The contents include a variety of metrics, but your monitoring system is only interested in the date, memory used and user CPU percentage. Furthermore, the metrics should be presented in JSON format. This is where the adaptor pattern comes to the rescue. Let’s go through the new pod manifest that uses an adaptor container, to adapt the metrics into the desired format. The legacy app container is the same as before, but with one difference. The app mounts a volume at slash metrics so that the raw metrics can be shared with the adaptor container. </p>
<p>The adaptor container also mounts the metrics volume, giving it access to the raw metrics. The adapters args are a few commands that parse the raw output and produce a JSON output, with the date, memory and CPU usage every five seconds. The JSON is output to slash metrics, slash adapted dot JSON. At the bottom of the manifest is the volume declaration. The volume is of type emptydir, which means the volume will have the same lifetime as the pod. There’s no need for persistent volumes that can outlive the pod in this example. The main takeaways are that the container shares storage using a volume, and the adaptor presents an adapted view of the underlying raw metric data. Let’s go ahead and create the pod, and we will use exec again to view the contents of the JSON metrics file. Now the output is in the format that the metric system needs, and it’s updated every five seconds. With the metrics in a JSON file, by using the web server container to serve the metric file at a rest API endpoint, for a metric aggregation system that pulls in metrics. </p>
<p>Or alternatively, by configuring the adaptor to push the JSON file contents into a metric aggregation system. But I’ll leave that as an exercise for you. In this lesson, on multi-container patterns for pods, we explained the rationale behind why pods are the Kubernetes smallest unit of deployment, and why they allow multiple containers. Next, we explained three common multi-container patterns for pods: The sidecar, the ambassador, and the adaptor. We finished with a demo about how to implement the adaptor pattern to adapt a legacy applications metric data to the format required for the monitoring system. The next lesson will cover patterns for providing and restricting access to pods, over the network in Kubernetes. When you’re ready, continue on to learn more about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/networking/">Kubernetes networking</a>.</p>
<h1 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/introduction/">Kubernetes</a> has several concepts relevant to networking. As an application developer, you should know about the concepts and how they can be used to securely provide access to applications running in a cluster. This lesson will begin by reviewing the basic networking model employed by Kubernetes. Then we will discuss more about services. The Networking Basics and Services topics are also covered in other content here on Cloud Academy so we will only review the key concepts of each. After, we will discuss Kubernetes network policies for controlling traffic that is allowed to and from pods. The basic building block in Kubernetes is a pod. The network model for a pod is IP per pod meaning each pod is assigned one unique IP in the cluster. <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">Containers</a> in the pod share the same IP address and can communicate with each other’s ports using localhost. A pod is of course scheduled onto a node in the cluster. Any node can reach the pod by using its pod IP address. Other pods in the cluster can also reach the pod using the pod’s IP address. </p>
<p>This is thanks to whatever Kubernetes networking plugin you choose. The network plugin implements the container network interface standard and enables pod-to-pod communication. But pods should be seen as ephemeral. They can be killed and restarted with a different IP. You may also have multiple replicas of a pod running. You can’t rely on a single pod IP to get the benefits of replication. This is where services come in. The service maintains a logical set of pod replicas. Usually these sets of pods are identified with labels. The diagram only includes one replica but there could be many spread over many nodes. The service maintains a list of endpoints as pods are added and removed from the set. The service can send requests to any of the pods in the set. Clients of the service now only need to know about the service rather than specific pods. Pods can discover services using environment variables as long as the pod was created after the service, or by using the DNS add-on in a cluster. The DNS can resolve the service name or the namespace qualified service name to the IP associated with the service. The IP given to a service is called the cluster IP. Cluster IP is the most basic type of service. </p>
<p>The cluster IP is only reachable from within the cluster. The kube-proxy cluster component that runs on each node is responsible for proxying requests for the service to one of the service’s endpoints. The other types of services allow clients outside of the cluster to connect to the service. The first of those types of services is node port. Node port causes a given port to be opened on every node in the cluster. The cluster IP is still given to the service. Any requests to the node port of any node are routed to the cluster IP. The next type of service that allows external access is load balancer. The load balancer type exposes the service externally through a cloud provider’s load balancer. A load balancer type also creates a cluster IP and a node port for the service. Requests to the load balancer are sent to the node port and routed to the cluster IP. Different features of cloud provider load balancers, such as connection draining and health checks, are configured using annotations on a load balancer. The final type of service is the external name and it is different in that it is enabled by DNS, not proxying. </p>
<p>You configure an external name service with the DNS name and requests for the service return a CNAME record with the external DNS name. This can be used for services running outside of Kubernetes, such as a database as a service offering. Network policies in Kubernetes are rules that determine which group of pods are allowed to communicate with each other and to other network endpoints. Network policies are similar to simple firewalls or security groups that control access to virtual machines running in a cloud. Network policies are namespace resources meaning that you can configure network policies independently for each Kubernetes namespace. Before we get into the details there is an important caveat when it comes to network policies. The container network plugin running in your cluster must support network policies to get any of their benefits. </p>
<p>Otherwise, you will create network policies and there won’t be anything to enforce them. In the worse case, you might think that you have secured access to an application but the pods are actually still open to request from anywhere. There won’t be any error messages when you create the policy. It will be created successfully but we’ll simply have no effect. The cluster administrator can tell you if the network plugin in your cluster supports network policy or not. Some examples of network plugins that support network policy are Calico and Romana. With that caveat out of the way, we can talk about two kinds of pods, isolated and non-isolated. A pod that is non-isolated allows traffic from any source. This is the default behavior. Once a pod is selected by a network policy it becomes isolated. The pods are selected using labels, which are the core grouping primitive in Kubernetes. Let’s see how to use network policies in a demo by writing several network policies and observing their effects. To begin with, I am running a cluster with the Calico network plugin installed. You can see that by checking the pods in the kube-system namespace, and observe there’re several pods beginning with calico. </p>
<p>Calico is one of the network plugins that support network policy. I have created three pods in the network policy namespace. One is a server and the other two are clients that send requests to the server every second. Client one is in the U.S. East region, while client two is in the U.S. West region. Both clients are able to send requests and get responses from the server. This can be seen by watching the logs of each client. I use the -f option to follow or stream the logs for each pod. New logs are generated every second acknowledging response was received from the server. Let’s take a look at our first policy. Working our way down from the top, network policies are included in the networking API. This policy is made to allow traffic from the U.S. East region and is scoped to the network policy namespace. In the spec, first there is a pod selector that selects the pods that the policy applies to. Here we are using the match labels selector to select any pod with the app server label. This applies to the single server pod that is running in the cluster. If the pod selector were empty the policy would apply to all pods in the namespace. Next is the policy types list. The two allowed values are ingress to indicate the policy applies to incoming traffic, and egress to indicate the policy applies to outgoing traffic. You can include one or the other, or both as in this case. </p>
<p>If, for example, you only included egress, then all ingress traffic would be allowed by the policy. Corresponding to the ingress policy type is the ingress list, which specifies rules for where the traffic is allowed. Each rule includes a from list specifying sources and a ports list specifying allowed ports. If the from list is omitted, all sources of traffic are allowed on the specified ports. If the ports list is omitted, traffic on all ports is allowed from the specified sources. If both are omitted, all traffic on all ports is allowed. Source rules can be made of pod selectors to select traffic based on pod labels, namespace selectors to select based on the namespace of pods or IP block to select based on a range of IP addresses. This policy uses a pod selector to allow ingress traffic from pods with the us-east region label. Each item in the ports list can restrict the allowed traffic to a given port and protocol. In this example, TCP port 8888 is allowed because that is the port the server listens to. The egress mapping includes a “to” map that lists rules in the same format as the ingress rules. In this case, no rules are specified so all outbound traffic is allowed. Let’s create the policy and then check to verify that client one in the U.S. East region is allowed to communicate with the server. And it is because responses are still being received. What if we check client two, which is in the U.S. West region? There’re no new log messages being received. </p>
<p>The policy is doing its job. Besides doing some basic tests like this, you can always use the describe command to check that the policy is doing what you expect. It outputs a description of the policy in a relatively easy to understand format. Now let’s look at one more policy to see how IP block rules are configured. This policy is constructed to block outgoing traffic to a single IP address from app server pods. This policy is an egress-only policy so there is no ingress included in the policy types list. The egress list has a single IP block rule. There’re two parts to the rule. The cidr field is required and sets a range of allowed IP addresses. Cidr is a notation for representing a block of IP addresses. 0.0.0.0&#x2F;0 represents all IP addresses. If that was the complete rule all outgoing traffic would be allowed. However, there is an except list. The except field is optional but when included, it acts as a blacklist within the white list that the cidr field specifies. In this case, there’s a single exception which represents one IP address. That IP address happens to be the IP address of the client one pod. This is for demonstration purposes only. In general, you should use labels when selecting pods in your cluster because pods should be treated as ephemeral. </p>
<p>They can be terminated and brought up again with a different IP address, or as labels remain the same. No port list is specified so all ports are allowed. Let’s go ahead and create the policy. Now there’re two policies being enforced. One allows incoming traffic from the U.S. East region, which allows client one traffic in the current cluster. And the second policy denies outgoing traffic from the server to client one. Think about what you might expect to observe. Will either client pod receive responses from the server? Let’s check. Client two still doesn’t receive responses. What about client one? It is still receiving responses. That may come as a surprise. We never discussed how policies are combined. For network policies you should think of them as sets of allow rules that are added together. If any rule allows traffic, even if others deny it, the traffic is allowed. In this case, the default allow egress rule and the first policy allows all egress, even though the second policy has blacklisted a specific IP. So to see the effect of the IP block rule, we can delete the first policy with the default allow egress rule. </p>
<p>Now, if we check the logs for client one, which is not allow egress according to the policy that is being enforced, it is still able to receive responses. What is happening now? The rules apply to new connections. In the case of a client sending a request to the server, the connection is already in place and the response is sent back through the same existing connection. There is no new connection so the network policy can’t block the egress. However, if we create a connection from the server, say by running the ping command, to ping the client one pod, we can see that there is no response. Contrast that with client two which we can see that we get a response. To have a clear picture of how network policies work, it is important to remember how multiple policies are combined and that the rules apply to creating connections, not traffic sent over established connections. That’s all for this lesson on Kubernetes networking. We began with a review of basic networking principles. Then we paid some extra attention to the different types of services available in Kubernetes. Lastly, we discussed network policies and how they can restrict traffic that is allowed to and from pods. In the next lesson, you will continue with the theme of security in Kubernetes and learn about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/service-accounts/">service accounts</a>. Start the next lesson when you are ready.</p>
<h1 id="Service-Accounts"><a href="#Service-Accounts" class="headerlink" title="Service Accounts"></a>Service Accounts</h1><p>Your application running in a pod many to authenticate itself to gain access to cluster resources. That is the purpose of service accounts which we will cover in this lesson. We will start by explaining what service accounts are then we will see an example of how you configure service accounts, finally we’ll touch on image pull secrets and how service accounts can help when you’re working with the private container registry. Service accounts provide an identity to pods running in the cluster. Unlike users in <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/introduction/">Kubernetes</a> which are managed by an external identity system and they are intended to be used by real people, service accounts are made for pods. Service accounts are also resources that are stored in and managed by the Kubernetes cluster.</p>
<p>Service accounts are namespace resources meaning they can only be used within one Kubernetes namespace and name of service accounts must be unique within the namespace but not across different namespaces. One of the main reasons for using service accounts is to utilize Role-Based Access Control or RBAC is securely mechanism built into Kubernetes. RBAC largely to define roles and associated permissions to access Kubernetes APIs and resources. For example, if your application needs to know the status of nodes in the cluster, our role allows you to grab those permissions. The same access control system is used to grab permissions to users in Kubernetes.</p>
<p> A Kubernetes administrator would usually define their roles since it requires knowledge of Kubernetes APIs and small mistakes could compromise the entire cluster. The actual mechanics of a pod authenticating itself involve using an authentication token that is automatically mounted into the pods file system. That token can be used as an authentication header for request center to Kubernetes APIs server. Every namespace has a default service account that is named default. Every pod that doesn’t specify service account automatically uses a default service account. The default service account doesn’t have any additional permissions than an authenticated user, making it secured by default. Those permissions are mainly limited to discovering what API the cluster provides but does not grab permission to use them, thereby denying access to any cluster state. Let’s go see how service accounts can be configured. </p>
<p>You will work with service accounts first hand in the mastering Kubernetes pod configuration map if you are taking this course as part of the CKAD learning path. So this demo will just touch on a few key points. In a new cluster, the most interesting namespace from a service account perspective is keep system. The namespace reserves for system resources. Let’s list the service accounts in Kube system. Because a lot of the pods in Kube system need access to different APIs and resources, there are many different service accounts. For example, cluster dns is provided by coredns and there is a service account for that. The default service account is also here as it would be in any other namespace. Just to get an idea of what a role looks like. Let’s see the role that is bound to the coredns service account. In this case, it is actually a cluster role which means that it is not scoped to a specific namespace, instead, the role grabs permissions to all namespaces in the cluster. The cluster role is cloud system coredns and the described output gives the table showing the permissions granted. </p>
<p>The role gives permissions to get nodes and to list and watch endpoints, namespaces, services, and pods. That makes sense, as a dns service needs to know when pods and services are created so it can create dns records for accessing them but no write permission is needed. So how can you associate a pod with the service account? Let’s take a look at the output of a coredns pod to see that. The service account name field is what needs to be set to associate a non-default service account. You can also see above that in the volumes for the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">container</a> that the token is mounted at the var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount path and that’s all for this demo. Just before we wrap up this lesson, I want to add a note about service accounts and image pull secrets. Image pull secrets come into play when you’re using a private container registry for your container images. </p>
<p>The way that you authenticate with the container registry so that you can pull an image into Kubernetes is by using image pull secrets. The secrets may be a docker registry server address user name and a password, for example, you can specify image pull secrets in pod specs directly but service accounts can also reference image pull secrets. Service accounts can provide both an authentication token and image pull secrets. It creates a nice separation of responsibilities when uses a service account for managing image pull secrets rather than hard coring your reference into pods specs. You can only modify the default service account to have image pull secrets so that any pod and a namespace can use images for your trusted registry without specifying a service account. That’s all for this lesson where we covered the basic of service accounts. That they provide an identity to pods and in doing so, it enables Role Based Access Control for pods. </p>
<p>By default, every namespace has a default service account and it does not have any permissions beyond that of an authenticated user. Then we saw some examples of service accounts in the Kube system namespace and that the service account name field in a pod specs is how to configure the service accounts of a pod. Lastly, we learned that service accounts can also provide a convenient way to store image pull secrets. The next lesson will teach you how to get the most out of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/leveraging-kubectl/">Kubectl</a>. There are useful tips if you plan to take the CKAD exam but also very useful in practice. Check it out when you are ready.</p>
<h1 id="Leveraging-kubectl"><a href="#Leveraging-kubectl" class="headerlink" title="Leveraging kubectl"></a>Leveraging kubectl</h1><p><strong>Update</strong> - From kubectl version 1.18 the <code>kubectl run</code> command can no longer be used for creating deployments. <code>kubectl create deployment</code> or manifest files can be used as alternatives. Also the <code>--export</code> option of <code>kubectl get</code> is no longer supported resulting in functional, but more verbose output manifests.</p>
<p>Welcome back. If you spend any amount of time working with a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/introduction/">Kubernetes</a> cluster, you’ll probably be issuing a lot of kubectl commands, this is certainly the case during Kubernetes certification exams, kubectl has features that can help you overcome many challenges you might face. This lesson is intended to give you some tips to increase your efficiency and get the most out of kubectl. This lesson will demonstrate enabling auto-completions for kubectl or Kube Control to up your productivity at the command line, how to get the most our of kubectl’s Get command, quick ways to generate resource manifest files with kubectl and how to use kubectl to give you information about resource specification fields in manifest files.</p>
<p> I’ll be using a Kubernetes cluster I’ve stood up on Linux nodes running in AWS. The cluster is the same as you use in Cloud Academy lab environments and is also very similar to clusters in Kubernetes certification exam environments. You can follow along using any type of cluster however, single node clusters spun-up using Minikube or enabling Kubernetes in Docker for Mac or Docker for Windows Distributions will work just fine for this lesson. Now let’s get started. Anytime you will be using more than a few commands with kubectl, you will probably enjoy having command completions enabled, it is not very difficult to do, but if you ever forget, kubectl can tell you how, all you really need to remember is that entering kubectl by itself lists all of the available commands and completion is one of them. To display the commands for enabling completions for different systems and shells, add the help option to the completion command, you can also use -h as a short form instead of spelling out help. </p>
<p>With kubectl it is quite common to have examples and command help pages, it is tempting to hop over to your favorite search engine when you forget how to do something, but kubectl has a lot of answers as long as you know how to get at them. I’m using Linux and the bash shell, so this source command is what I need to enable completions for the current shell. To have completions enabled automatically every time a shell is created, add the command to your .bash_profile file, now you can easily have commands auto-completed by pressing Tab or list the available commands and options by pressing Tab twice if there isn’t a single completion for what you’ve entered. If I enter kubectl followed by Tab twice, the available commands for kubectl are displayed. If I type g, followed by Tab, the only command starting with a g, get, is completed. Completions will save you a fair amount of time and prevent typos, this is always useful, but especially if you are taking one of the time-limited Kubernetes certification exams. The get command is your go-to command for displaying resources in Kubernetes, I’ll press Tab twice to show the resources that can be shown with get. Let’s say we’re interested in nodes, I’ll enter nodes to display all the nodes in the cluster.</p>
<p> With completions enabled, it is easy to enter the names of resources with some Tab magic, but you can also make use of the short names for resources. To list the short names for resources, you can enter kubectl api-resources. The first column lists the full name and the second lists any short name, if there is one, so if you aren’t a fan of typing nodes, feel free to simply enter no, it’s more beneficial, considering the length of some resources, such as certificate signing requests, which can be compressed down to CSR, a whopping savings of 23 ASCII characters. To get a look at all the pods in a cluster, I’ll use the all namespaces option of the get command, you can also use the short name p-o for pods. Only pods in the Kube system namespace are running, because this is a fresh cluster, there are still quite a few pods running and it doesn’t take long before there can be significantly more. Besides selecting a specific namespace, you can also use labels to filter the output, but how do you know what the labels are, you ask? You can use the show-labels option for that. </p>
<p>An additional labels column is appended showing all the labels for each pod, if you are only interested in a subset of the labels, you can use the -L option, followed by a comma-separated list of label names. For example, if you are only interested in the k8s-app label, you can use the -L option, followed by k8s-app and the k8s-app column is added. Any resources with the value for the label have the value shown in the k8s-app column, if you are only interested in seeing resources with the label defined, you can use the lowercase l option. The lowercase l is how you filter the output and if you only want the resources with a specific value of a label, you can specify the value after an equal sign. For example, to only show the kube-proxy pods, you’d enter k8s-app&#x3D;kube-proxy. </p>
<p>Likewise, you can add an exclamation mark before the equal sign to show all resources not matching the label value, here, the pods that don’t have the k8s-app label defined showed up again because not having the label defined is a match for not having a specific value of the label. To hide the pods that don’t have the label defined, just add the label name after a comma, you can join as many label queries as you like by joining them with commas. While we’re at it, the sort by option comes in handy for organizing the output of the get command, you can sort by the value of fields in the resources manifest. For example, if you want to sort by the age of the pods, you can sort by metadata.creationTimestamp, you can verify that the age column is now sorted, the field that you give to sort by is specified using a json path, it can be read as sorting by the metadata object’s creation timestamp field. </p>
<p>Although that works, for more complicated json path expressions it is a good idea to wrap the path in single quotes and braces to avoid cell substitutions and start the path with a period to represent a child of the root json object, this is a better way to specify the json path. When writing json paths, the root object is actually represented with a dollar sign, but here, the dollar sign can be omitted, because the expressions are always children of the root object. You might be wondering, how did I come up with the metadata.creationTimestamp path to sort by age? You can use the output format option of get to list all the fields in a resource, the output formats for entire resources can be either json or yaml, yaml is more compact, so I’ll be using that. Here’s an example to output a pod in yaml, output format, notice the output&#x3D;yaml option, you can also use -o as a shortform for output. With the sort by option, you can sort by any numeric or string value field you find in the output, if you wanted to sort by the pod IP address, which is treated as a string, you would give the path .status.podIP, here’s how the get command would look sorting by pod IP. You can trust the sort is performed correctly, but how can you verify it? There’s another output format that gives additional information dependent on the type of resource, the wide format. For pods, the wide format includes the pod’s IP and if you knew you can verify that the output is indeed sorted by the value in the IP column, treating the values as strings. There is one other output format I want to mention, although there are several more. You’ve actually used the type of the format before, it is the json path format, you can use a json path expression to describe what you want to output. </p>
<p>Let’s try to output the pod IP using the same json path expression for the output format. Hmm, all the output disappeared, it must be something wrong with that json path expression. To use json path output effectively, you need to understand when the get command is returning a specific resource or a list of resources, if you specify the name of a resource, for example, the name of a pod, then get will return only that specific pod. In all other cases, where you don’t specify a specific resource, a list will be returned, when the list is returned, the json array that contains all the resources is named items. In our case, no specific pod is identified, so the items array needs to be included in the output format json path expression. Notice that you need to use square brackets to index the array, the asterisk is a wildcard, meaning all of the items in the array. The output is not as tidy as it is with the yaml or wide output format, to clean it up, you can use a more complex expression that iterates over the items in the array to also include the name of the pod and add new lines.</p>
<p> The expression takes some time to understand and it is only included to show you that it is possible to include more than single fields in json path output. For more information about json path expressions, see the link to json path support in Kubernetes in the transcript of this video. Those tips are really good for viewing what is already in the cluster, now it’s time to shift the focus to creating new resources in the cluster. The create command is your friend for that, the final name option or in short form, -f, allows you to create a resource or multiple resources from a manifest file or a directory containing manifest files. There are also several sub-commands for creating different types of resources without having to use a manifest file, to see them, just view the Create Help page. It’s usually better to use manifest files so that you can version control your configuration and practice configuration as code. So why did I mention these shortcuts? You can use sub-commands to generate manifest files when paired with the dry run and output format options, a dry run will stop any resource from actually being created and if you set the output to yaml, the output is an equivalent manifest file for the create command you enter, let’s try that with a namespace. </p>
<p>Here, I’ve used create to generate a manifest file for a namespace named tips, I’ll redirect that output to a file in a tips directory. The create command is going to create the resources in filename order. So to ensure the namespace is created first, I’ve used the number one in the name to force the order, the dry run option is available for other commands that create resources as well. Let’s say you want to create an nginx deployment, you can use the run command to generate a manifest file using the options you provide at the command line. Here, I’ve set the image to nginx, published to container port 80, set the number of replicas to two and exposed the deployment with a service using the expose option. The service will use the default type of cluster IP and the service port will be the same as the container port. If any of those are not what you want, it’s now very easy to edit the flushed out manifest file to customize it as you like. We’ll discuss services later in this course. For now, let’s say we are happy with the defaults, except we want to put the resources in the tips namespace, I’ll redirect the output to a file prefixed with two, so that the resources are created after the namespace, then I’ll add the namespace to the metadata, I’ll use VI for this, which is an alias for Vim on my system. VI is also the default editor for kubectl edit, which we will see later on in this course. You can use whatever editor you’re comfortable with, if you are preparing for a Kubernetes certification exam, you should be comfortable with the command line editor to save time copying and pasting into the exam notepad area. To learn how to become an expert at Vim, I’d recommend entering vimtutor in a Mac or Linux cell to go through a series of lessons starting from scratch. </p>
<p>And now, to set the resources namespace field. The resources will now be created in the tips namespace, to create all the resources, I’ll use kubectl -f and specify the tips directory. Other commands, such as delete, support the same pattern of specifying a directory, so when you’re finished with those resources, you can simply use the same option with the delete command and now all the resources specified in those manifests have been deleted. One last technique for quickly creating manifests is to use the get command to modify manifests from existing resources. That might be an obvious technique, but there is an option to help strip out any cluster specific, that you don’t want to be present in a manifest file, such as the pod status and creation time. As an example, if I get the yaml output for a kube-proxy pod and count the number of lines in the output, there are 133 lines of yaml, whereas with the export option, there are 92, in this case, export automatically removed 41 lines of yaml for you. Now to close out the lesson, I have one last tip. Earlier when I was explaining how to craft json path’s sort by expressions, I said you could use yaml or json output of the get command to show all the fields of resources. </p>
<p>There is actually another way and it’s very useful, it can help you with customizing generated manifests as well. It not only gives you the field names of paths but also tells you the purpose of each field and other useful information, all of that goodness is bundled up into the kubectl explain command. There are a couple of ways to use explain, they both require you to specify a simple path that is similar to a json path, but you give the kind of resource first without a leading dot and follow it with the field path that you are interested in. For example, if you want to see the top-level fields of a pod resource, you enter kubectl explain pod and the output gives you a description of a pod and the top-level fields in a pod. If you wanted to dive into the details of a field that’s further down in the hierarchy, let’s say, a pod specs container resources field, you just join the fields with dots, in this case, pod.spec.containers.resources. You can traverse the fields up and down in this fashion to understand what fields are used for and if you want to see examples, you can navigate to the provided info links when available. The other way to use explain is to provide the entire schema of a field or resource by using the recursive option.</p>
<p> For example, to see all the fields in a pod’s container field along with their types, you can enter kubectl explain pod.spec.containers and specify the recursive option. Explain can save you quite a few trips to your search engine of choice when writing resource manifests. During Kubernetes certification exams, you won’t be able to use search engines, so it’s important to know how to get the most out of kubectl for exams as well. All right, that brings us to the end of this lesson. There were quite a few tips in there and with them, you should feel confident about using kubectl to overcome any challenges you might have, such as generating manifest files or explaining specification fields. Taking it from the top, we saw how kubectl completions help write lengthy commands and prevents spelling mistakes. Remember that if you don’t know the exact syntax for enabling completions, the kubectl completion help page has you covered. </p>
<p>Then you saw how to use labels to filter and the sort by option to sort with the get command to effectively view resources in a Kubernetes cluster. We finished with some techniques for quickly generating manifest files by opening yaml from dry run commands and exporting resources from the get command. The explain command can help you customize the manifest files by explaining the schema and the purpose of different fields. We’ll wrap up the course in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/summary/">next lesson</a>, continue on when you’re ready.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Congratulations, you’ve reached the end of this course on <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/introduction/">Kubernetes patterns for application developers</a>. Let’s review what we’ve learned. We began the course looking at multi-container patterns for pods. The lesson began with an explanation of why Kubernetes has pods and why they allow multiple containers. Then we saw how the sidecar pattern can be used to extend functionality of a primary <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">container</a> with a sidecar. This pattern is often used for shipping logs to central aggregation systems and to sync files with external systems. After that we learned about the ambassador pattern and how it can be used to proxy connections from a primary container to the outside world. The example we considered involved proxying connections to a database. Lastly, we looked at the adapter pattern and how it can provide a standardized view of an application. We implemented an adapter for a legacy application that wrote metrics in a non-standard form. We then became familiar with networking topics including a review of the basic networking principles in Kubernetes such as IP per pod, container local host communication and services to avoid the pitfalls of working directly with pod IP’s. We then dove into more details on the different types of services that are available. They are cluster IP for internal only access, NodePort to open a port on each node for access to a service, load balancer to leverage a cloud providers load balancer to grant external access to Kubernetes service and external name to access services outside of the cluster using DNS CNAME records. We finished lesson by looking at network policy and how you can control access to groups of pods in a namespace. Remember that the policies don’t have any effect if the clusters network plugin doesn’t support network policy. Next, we learned about how <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/service-accounts/">service accounts</a> provide an identity to pods running in the cluster. Service accounts are compatible with role based access control allowing pods to access communities API’s when necessary. You can use the service account name field of a pod spec to configure a pod service account. We also learned the benefits of using service accounts to store image pull secrets when working with private container image registries. The previous lesson covered some tips on how to be productive with kube control. We saw how to use the completions command to enable shell completions for kube control. How do you get the filter output using labels and format output, how to use kube control to generate manifest files for a variety of resources and <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/kubernetes-patterns-for-application-developers/leveraging-kubectl/">how to use kubectl</a> to understand the resource fields. </p>
<p>We certainly covered a lot of interesting topics for application developers working with Kubernetes but the fun doesn’t end here. I’d encourage you to try out more of Kubernetes content here on Cloud Academy. There are several labs that give you hands on experience with Kubernetes clusters. The Kubernetes pod designed for application developers, Kubernetes observe ability and mastering Kubernetes pod configuration labs are all made specifically for application developers working with Kubernetes. The labs are a great place to practice and learn at the same time but keep on going after you completed them. Try things out on your own and try to solve some challenges you can think of. Think back to the leveraging kube control lesson to be as efficient and self-sufficient as possible. </p>
<p>Lastly, please share your feedback so I can find out what you want to see more of and what you’d rather see less of and make content for you, and try to make it the best that it can be. </p>
<p>Thank you for taking my course. Take what you’ve learned here and apply it and continue to expand your Kubernetes skills. Until next time, I’m Logan Rakai with Cloud Academy.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/CKAD-Knowledge-Check-Kubernetes-Basics-4/" rel="prev" title="CKAD-Knowledge-Check-Kubernetes-Basics-4">
      <i class="fa fa-chevron-left"></i> CKAD-Knowledge-Check-Kubernetes-Basics-4
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/CKAD-Kubernetes-Pod-Design-for-Application-Developers-Definition-Basics-6/" rel="next" title="CKAD-Kubernetes-Pod-Design-for-Application-Developers-Definition-Basics-6">
      CKAD-Kubernetes-Pod-Design-for-Application-Developers-Definition-Basics-6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-container-Patterns"><span class="nav-number">2.</span> <span class="nav-text">Multi-container Patterns</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Networking"><span class="nav-number">3.</span> <span class="nav-text">Networking</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Service-Accounts"><span class="nav-number">4.</span> <span class="nav-text">Service Accounts</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leveraging-kubectl"><span class="nav-number">5.</span> <span class="nav-text">Leveraging kubectl</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Summary"><span class="nav-number">6.</span> <span class="nav-text">Summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
