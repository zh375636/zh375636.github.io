<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Google Cloud FirestoreHello and welcome, this is Introduction to Cloud Firestore with App Engine, and in this lesson, we’ll be exploring the basic functionality of Cloud Firestore and how it’s used">
<meta property="og:type" content="article">
<meta property="og:title" content="GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16">
<meta property="og:url" content="https://example.com/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Google Cloud FirestoreHello and welcome, this is Introduction to Cloud Firestore with App Engine, and in this lesson, we’ll be exploring the basic functionality of Cloud Firestore and how it’s used">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T04:14:16.000Z">
<meta property="article:modified_time" content="2022-11-20T23:37:48.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:14:16" itemprop="dateCreated datePublished" datetime="2022-11-19T00:14:16-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:37:48" itemprop="dateModified" datetime="2022-11-20T19:37:48-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GCP-Professional-Architect/" itemprop="url" rel="index"><span itemprop="name">GCP-Professional-Architect</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-Cloud-Firestore-and-Datastore-16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Google-Cloud-Firestore"><a href="#Google-Cloud-Firestore" class="headerlink" title="Google Cloud Firestore"></a>Google Cloud Firestore</h1><p>Hello and welcome, this is Introduction to Cloud Firestore with App Engine, and in this lesson, we’ll be exploring the basic functionality of Cloud Firestore and how it’s used with App Engine. By the end of this lesson you should be able to: explain the purpose of Cloud Firestore, explain the relationship between Cloud Datastore and Cloud Firestore, explain when to choose Datastore Mode, and explain how to use Datastore with App Engine. </p>
<p>Most applications need a place to store queryable data, and fortunately, there is no shortage of databases to help. However the choice of database is not always a simple one, it depends on multiple factors including but not limited to the type of data being stored, how the data will be consumed, et cetera. Technical limitations are another concern. For example, will the database be able to support the amount of traffic? </p>
<p>No matter what kind of database you’re using, if it can’t support the workload that you intend to use it for, it’s not all that useful. Remember, App Engine can keep scaling up to support the demand and that means the database needs to as well, and that’s why Google created Cloud Datastore and paired it with App Engine. Now, that doesn’t mean it’s the only database you can use though it was designed to be a good likely pairing for many apps. So, if you’re interested in learning more, then let’s get started. </p>
<p>Google released Datastore in 2013 to serve as App Engine’s database, and for years that is how it has been. Datastore is a highly scalable, fully-managed, no-SQL document database. Supporting both eventual and strong consistency, it supports transactions and it offers a SQL-like query language called GQL. It stores data as properties of an entity with support for multiple data types, and it categorizes entities based on a developer supplied Kind. </p>
<p>To make entity lookups perform quickly, entities include a Datastore property named a Key which is a unique ID, and to allow entities to be queried, Datastore allows developers to create indices based on the properties for which we want to filter. </p>
<p>I mentioned queries being similar to SQL, they’re similar but not exact, and there are some limitations for which I’ll include a link App Engine is designed to run web apps and mobile backends which are broad categories with a wide range of storage requirements. There’s really just no single option that’s going to work for all workloads. If we were to compare a mobile chat application with a mobile news feed, both of them have very different storage needs. The same goes for web applications, let’s say a brochureware application is going to have different storage needs than a site such as Twitter. </p>
<p>In 2014, Google acquired a realtime database called Firebase. Realtime databases are used for data which is always changing and require processing to happen very quickly. Shortly after that acquisition, Google started building Cloud Firestore. It took the best parts of Firebase, it took the best parts of Datastore, and it smashed them together into a single service. </p>
<p>Now, the purpose of Cloud Firestore is to serve as the next generation no-SQL database for <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">Google Cloud</a>. This is where we get a bit tangled. Cloud Firestore provides one of two operating modes that are called Native Mode and Datastore Mode. Using Cloud Firestore in Datastore Mode is the next generation of Cloud Datastore. It supports Datastore’s API and it uses Firestore’s data storage layer which removes some of the previous Datastore limitations. </p>
<p>Now, currently the original Datastore and Firestore in Datastore Mode are two different products, however, Google will be moving users over to Firestore seamlessly over time. Using Firestore in Native Mode is not the next generation of Firebase, at least not publicly, at least not in this moment. Using Cloud Firestore in Native Mode is similar to Firebase, though there are some implementation changes. </p>
<p>So with all of this, the logical question is, how do I know which mode to use? Here’s some general advice, now, it’s not universally applicable, though it is a good starting place. Datastore or Firestore in Datastore Mode are intended for server workloads, meaning a service-side application interacts with a database. Now, this is exactly what App Engine does, so if you’re building with App Engine and you need a schema list database, then you’ll probably wanna use Firestore in Datastore Mode. Firestore in Native Mode is similar to Firebase, which is basically an application platform and doesn’t require developers to create service-side applications. </p>
<p>Firestore Native and Firebase both provide STKs which allow read and writes to documents for which users have access and all without a server, and if you need some sort of backend functionality, it also supports running Cloud functions based on event triggers which include, when a document is created, deleted, updated, et cetera. So Firestore in Native Mode is very cool, but it’s not the focus of this lesson, so we’re not going to go into detail, this lesson is really focused on using Datastore Mode with App Engine, though if you wanna learn more, I’ll include some links for further reading. </p>
<p>Before moving on, there are some things to commit to memory, each project can use Firestore in one mode only. So if you select Datastore Mode, that’s the mode for your project and vice versa with Native Mode. Also, and importantly, if you create an App Engine app inside a project, it’s going to automatically choose Datastore Mode, so be careful with that, if you really don’t wanna Datastore Mode, don’t create an App Engine app in that project first. </p>
<p>Alright, with all of this out of the way, how do you actually use Datastore with an App Engine application? Due to the ever-evolving nature of App Engine, there have been different methods for interacting with Datastore which varied by runtime. Currently, Google recommends the use of the Google Cloud Client Libraries. Google provides these libraries for different runtimes, and they allow engineers to interact with Datastore in the language that they’re familiar with. If for some reason you’re using a language that does not have a supported library, you can always fall back to the Rest API and use that directly, it just requires a bit more effort on your part. </p>
<p>Before wrapping up, let’s check out a demo of Cloud Datastore in the console. I’m here on the Datastore Dashboard, I’ve already enabled the Datastore API and I have some sample entities which store some dummy data. Notice here I have a Kind called EmailEvent and there are four entities. This Entities page is where we can see the different entities for a specific Kind which is specified in the dropdown. And if we click on Create it will open a form where we can add a new entity. </p>
<p>The Namespace is used to partition data, an example might be to specify a company name which would allow for a multitenant app, and if you don’t specify a namespace that’s fine, the default is used, just know, they can’t be changed once they’re set. Datastore uses the concept of a Kind to categorize an entity and that makes it easier to query specific types of entities The Key is used to look up an entity quickly, notice these properties here, these are added by Datastore to make it easier for us to populate this, it knows that this is an EmailEvent Kind so it’s given us the properties that exist on some of the other entities. </p>
<p>This is just a nice feature from the user interface to make it easier to enter our data, remember, this is a schema list database, so we don’t have to define specific properties for even the same Kind, I could just remove all of these and have a totally different property for one EmailEvent than I do for all the rest. I can’t imagine a use case in which you’d want to do that, but it is possible. </p>
<p>The query language that Datastore supports is called GQL and again, and it resembles SQL up to a certain point, so if we start by typing select star from followed by the name of our Kind, we can see this returns all EmailEvent Kinds with all the properties, though you could also specify properties to return and that way, you can get just the data you need. </p>
<p>OK, let’s stop here and see how we did. The purpose of Cloud Firestore is to serve as the next generation no-SQL database for Google Cloud. To get there, it took the lessons learned from Datastore and Firestore, probably other stuff internally as well, and put them all into a single product. Cloud Datastore is currently both its own service and a mode of Firestore, where Firestore in Datastore Mode is the latest generation of Datastore and will replace Datastore. Datastore Mode is intended for server workloads and if you’re pairing with App Engine, then it’s likely a good choice. To interact with Datastore or Datastore Mode in software, we would use the Google Cloud Client Libraries, though we could always use the Rest API directly if we needed to. </p>
<p>Alright, that’s going to do it for this lesson, I hope this has been helpful, I hope it’s filled in a few of the gaps, and I will see you in the next lesson.</p>
<h1 id="Google-Cloud-Datastore"><a href="#Google-Cloud-Datastore" class="headerlink" title="Google Cloud Datastore"></a>Google Cloud Datastore</h1><p>In this lesson, we’ll dive deeper into Cloud Datastore. We’ll cover queries and indexes and entity groups and transactions.</p>
<p>Let’s start with queries. A query can specify a kind and then zero or more filters and zero or more sort orders. We can filter on properties, keys and ancestors. Filters are basically pretty simple. Here’s an example in Python outside of the context of an actual application. We define the q variable as a query for the person kind, and then we filter it on the person name &#x3D; John, and then we can add a sort order by calling the order method, so we say order and then we specify the name, and then if we add a hyphen in front of it, it makes it descending, and we can query on ancestors as well with something like this. We can use an ancestor query specifying ancestor &#x3D; and then the key.</p>
<p>Let’s check out an example from our actual application. If we look at the images.py file, we can see that we’re using a class method called for category to fetch all of the images for a given category. It uses an ancestor key as a query filter and this allows us to get all of the images that belong to the category that was passed in. So if we were to break down this code, it would translate into something like we get the key, based on the urlsafe key, and then we use that to query all of the images that have that category as an ancestor. We sort by the created on date, descending, and then we take the last 20 results. It’s a fairly simple-to-use API, but it’s very powerful.</p>
<p>With a traditional relational database, we use indexes to improve performance. Due to the design of Datastore, we use one or more indexes for any query we run. With Datastore, there are basically two types of indexes. We have single property indexes and composite indexes. Single property indexes are automatically created for us which means each individual property is indexed, allowing us to query it. Now, these indexes take up space, which means there’s cost attached to it, so we also have the ability in our code to say index &#x3D; fault. This will allow us to skip indexing properties that we won’t ever be querying. This is going to save us money.</p>
<p>Okay, there are some limits on the queries we can run with single property indexes. We can use equality filters on one or more properties, which is a merged join, so something like first name &#x3D; Bob and last name &#x3D; James, this works because even though we’re querying on two properties, we’re using an equality filter so it’s merging the results, and we can use inequality filters on one property, such as first name &gt;&#x3D; to the letter B and first name is &lt; the letter C, and only one sort order can be defined on a single property query. Now, if we want to query on multiple properties, we can create a composite index. We can create it manually using the if find YAML syntax, or we can run our queries on the development server and it’s going to generate an index.yaml file or a datastore-index.xml file for Java.</p>
<p>Let’s check out our index.yaml file. Right here at the top it says auto-generated and that’s because when we run any code that runs a query against the development version of Datastore, it builds the index.yaml for us. That way when we deploy, App Engine knows what indexes it needs to build. Here’s an example of what a composite index might look like. We have a last name and a first name and they’re both ascending.</p>
<p>For multi-valued properties, like our tags, it looks similar except an index entry gets created for every value of a property. We can query multi-valued properties if at least one value matches the filters. We saw that when we checked out the tags on our images in a previous lesson. It’s considered best practice that we don’t index very long strings. Instead, we should be using the Search API which gives us Google-like search capabilities. Also, we should clean up old indexes using the appcfg vacuum_indexes command, and if we have properties that shouldn’t be indexed, maybe something like a very long string as we just mentioned, we can flag them as not indexed with the indexed &#x3D; false.</p>
<p>We’ve talked about how Cloud Datastore is fast and efficient for querying, but why is that? It’s because we use the indexes to shift the cost of querying to upfront when the index is created, so sometimes it’s going to take a little while for the indexes to initially build if we have very large data sets, though once an index is built, then querying them is very fast. Let’s talk about consistency with Datastore. We’ve talked about eventual and strong consistency a few times.</p>
<p>The difference is basically that for strong consistency, the data we read is the last data that was written, and with eventual consistency, the data that we read may not be the last data written. Eventual consistency is great for when we don’t need anything critical. This can be things like a blog post, and we’d use strong consistency when it’s vital to see the latest updates. Now, this can be for things like the price of a product in our catalog. If we need strong consistency, we have a few options. We can use an ancestor query. We can fetch an entity using the get method on a Key, or we can use a transaction. We’ve talked about the first two throughout our discussion on Datastore. However, we haven’t talked about transactions, so let’s dive into that a bit more.</p>
<p>We can use transactions to gain strong consistency. Let’s say that we wanted to update a property and in this example, it’s the amount of tickets available for a conference. So, we’re able to ensure that if this executes successfully, any future queries will have this data. The ndb library makes it easy to perform transactions with this transactional decorator, along with the other methods that we can find in the API documentation. Now, sometimes we’re going to need to work with entities that are not part of the entity group we’re using.</p>
<p>Let’s say we have two bank account entities that are not part of the same group, and we want to transfer funds from one to another. We want to be able to ensure strong consistency with something like this since eventual consistency could result in something like withdrawing more money than we should have available or not being able to withdraw enough money that we should have. For something like this, we can use cross-grouped transactions to ensure strong consistency. We still use the same transactional decorator. However, we set the xg parameter to true.</p>
<p>There are some best practices for transactions. First, because entity groups can only be written to once per second, we need to consider the design of our entity groups in advance. Next, an entity group’s relationships are immutable, so if we need to make a change to the relationship, we need to delete the entities and recreate them with the new relationships. Also, we have a 60-second time-out on transactions. This is intended to reduce the chances that an entity is edited in another transaction during that same time. Finally, inside of transactions, the only type of query we can run is an ancestor query. So, we may need to fetch data outside of the transaction and pass it off to the code that’s going to be running that transaction.</p>
<p>All right. Let’s summarize what we’ve covered in this course. A query can specify a kind, and then zero or more filters and zero or more sort orders.</p>
<p>We can filter on properties, keys, and ancestors. With Datastore, there are basically two types of indexes. We have single property indexes and composite indexes.</p>
<p>Datastore supports strong and eventual consistency, and we can use ancestor queries calling the get method of a Key and transactions for achieving that strong consistency, and transactions can also be cross-grouped to allow us to support strong consistency for disparate entity groups.</p>
<p>Thanks for taking the time to watch this course. For Cloud Academy, I’m Ben Lambert. Thanks for watching.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/GCP-Professional-Architect-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-15/" rel="prev" title="GCP-Professional-Architect-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-15">
      <i class="fa fa-chevron-left"></i> GCP-Professional-Architect-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-15
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/GCP-Professional-Architect-Introduction-to-Google-BigQuery-17/" rel="next" title="GCP-Professional-Architect-Introduction-to-Google-BigQuery-17">
      GCP-Professional-Architect-Introduction-to-Google-BigQuery-17 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Google-Cloud-Firestore"><span class="nav-number">1.</span> <span class="nav-text">Google Cloud Firestore</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Google-Cloud-Datastore"><span class="nav-number">2.</span> <span class="nav-text">Google Cloud Datastore</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
