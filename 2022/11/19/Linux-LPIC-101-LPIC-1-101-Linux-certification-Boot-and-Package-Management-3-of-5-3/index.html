<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course introductionWelcome to the third course in CloudAcademy’s LPIC 1 Certification Preparation series. In this course, we’ll learn about the preparation and process of effective Linux installatio">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-LPIC-101-LPIC-1-101-Linux-certification---Boot-and-Package-Management-3-of-5-3">
<meta property="og:url" content="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course introductionWelcome to the third course in CloudAcademy’s LPIC 1 Certification Preparation series. In this course, we’ll learn about the preparation and process of effective Linux installatio">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T05:08:46.000Z">
<meta property="article:modified_time" content="2022-11-21T00:19:38.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux-LPIC-101-LPIC-1-101-Linux-certification---Boot-and-Package-Management-3-of-5-3 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-LPIC-101-LPIC-1-101-Linux-certification---Boot-and-Package-Management-3-of-5-3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 01:08:46" itemprop="dateCreated datePublished" datetime="2022-11-19T01:08:46-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 20:19:38" itemprop="dateModified" datetime="2022-11-20T20:19:38-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LPIC-1-101/" itemprop="url" rel="index"><span itemprop="name">LPIC-1-101</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Course-introduction"><a href="#Course-introduction" class="headerlink" title="Course introduction"></a>Course introduction</h1><p>Welcome to the third course in CloudAcademy’s LPIC 1 Certification Preparation series. In this course, we’ll learn about the preparation and process of effective Linux installations, and how to manage software packages through their entire life cycles. We’ll explore partitions and file systems, and the roles that they play together. We’ll learn how to select and install a boot manager and about software libraries, and how they can be shared among processes. We’ll also understand how dpkg and RPM, the two largest Linux managed software repositories work, and how you can use each of their front end applications, APT, and Yum.</p>
<h1 id="Partitions-and-Filesystems"><a href="#Partitions-and-Filesystems" class="headerlink" title="Partitions and Filesystems"></a>Partitions and Filesystems</h1><h3 id="Designing-Linux-disk-partitions"><a href="#Designing-Linux-disk-partitions" class="headerlink" title="Designing Linux disk partitions"></a>Designing Linux disk partitions</h3><p>While mature Linux distributions like Debian, Ubuntu, and Fedora come with their own automated GUI installation progRAMs, that can smoothly handle most people’s needs, at some point in your career as an administrator, you’re probably still going to have to manually configure an installation that’s meant to perform some special function. Coaxing nonstandard combinations of hardware and software to get along nicely with each other can still sometimes be a delicate and demanding process. So whether your future deployment security needs require that you completely separate parts of the file system from each other, or whether your reliability concerns demand a Raid 10 disk array, the solid understanding of Linux partitions and file systems you gain now will pay off solid dividends later. The principles of good disk design require balancing two opposites: separation and accessibility.</p>
<p>For example, you don’t want regular users having access to each other’s private files or to your system configuration files. But they can’t be so completely cut off that they can’t function either.</p>
<p>A partition is a portion of a disk drive that’s been logically walled off from the rest of the disk. Thus, a single one terabyte disk can contain four primary partitions, each say 250 gigabytes in size. From the perspective of software and users, these four partitions can look and behave like four physically separate disks, with all the security benefits and access headaches that go with it. On the other hand, you can also design your media so that resources on multiple physical disks can appear to reside on a single disk through either the logical volume manager, LVM or mount points. We’ll talk about LVMs a bit later in this video.</p>
<p>And even though we’ll discuss mount points in a later course in this series, it can’t hurt to quickly show you how it’s done right now. I have a USB drive that’s been designated as sdc. So it’s primary data partition would be &#x2F;dev&#x2F;sdc1. We’ll go to the &#x2F;tmp directory and use mkdir (make directory) to create a directory called drive. We’ll then type sudo mount &#x2F;dev&#x2F;sdc1 drive, then CD into the drive directory. ls will list all the contents, which are actually the contents of my USB drive, meaning that we’ve successfully mounted that drive to the directory &#x2F;tmp&#x2F;drive.</p>
<p>Let’s begin with a look at the Linux file system itself. I divided the top level directories into four sections. The home directory, under which users directories and files are kept. The system directories like etc, var, and lib. Virtual or pseudo directories like dev and proc and boot which as we’ll soon see is in a category all its own.</p>
<p>Under normal circumstances, you’ll spread your installation over three partitions. The root file system, a single 500 megabyte partition containing the Boot file system, which includes the Master Boot record, and a swap partition for virtual memory for use when you run out of RAM. You will usually create a swap partition that’s twice the size of your system RAM per graphic desktop computers and the same as your RAM for servers. But there’s also times when you’ll to keep the home directory tree on a separate partition or sometimes even on a separate disk entirely. This way, if something should happen to corrupt any or all of your system files, rendering your computer unbootable, it will be much less likely to have any effect on your user’s personal and work files. That will give you the option of simply copying the entire home system intact to wherever you’d like to rebuild your computer. You will have to create their accounts and assign new passwords, something that shouldn’t require more than a few minutes work . But their data will all survive.</p>
<p>Similarly, if you’ve got a development server that’s accessed by a team of coders and admins using it as test bed for deployment experiments, you might want to keep the &#x2F;var directories in a separate partition from everything else to contain the consequences of an experiment that might go wrong. However you decide to organize your partitions, you’ll want to accurately anticipate how much space each will need.</p>
<p>It is possible to re-size a partition once it’s been created, but it’s something you’d far prefer to avoid because every re-size operation carries a risk of failure. And failure, in this area, usually means the complete loss of all disk data. So how much space will you need. The main Linux system can be comfortable on less than four gigabytes.</p>
<p>You might think you should save everything else for your &#x2F;home directories and the terabytes of all those funny cat videos they’re eagerly waiting to download. But there are other important things to consider. Linux systems can generate an awful lot of data, especially log files. And they’re mostly kept in the &#x2F;var&#x2F;log directory. I’ve seen individual log files larger than 100 gigabytes. Naturally, as we’ll discuss in a future video, you will want to properly rotate your logs so things don’t get out of hand. But some projects might not let you. And there’s always a chance, as I’ve seen happen many times, that someone will launch at test process on a virtual container and forget about it, allowing its logs to cheerfully consume a higher and higher percentage of total disk space. This, by the way, is one reason many administrators create a separate partition for var so that if things do get out of hand, it won’t clog up the whole system.</p>
<p>So you’ll have to carefully access how your system is going to be used in order to properly accommodate your actual needs. We’ll talk about how you can actually create partitions in a later video. But for now, we’ll break with our regular practice so we can illustrate what partitions might look like on a real system. Just this once , we’ll use a GUI program. GParted is a front end for the command line partitioning tool, parted. And while Linux admins normally prefer the command line to anything else, some have even been known to order pizza from a terminal. gparted is something of an exception. As you can see, there are two hard drives in my system designated as sda and sdb.</p>
<p>sda is a semi-retired disk that, until it began showing some indications that it might soon fail, was my main system disk. I now keep it running just in case I ever need to access old files. My luck, it’s been running this way for more than a year and hasn’t yet failed. sdb is my current boot drive containing my live deployment of Ubuntu 14.04. You can see that it has three partitions. sdb1 is a 500 megabyte partition mounted to &#x2F;boot&#x2F;efi. It’s obviously my boot partition with the Master Boot Record. Five hundred megabytes is probably far more than the boot partition will ever need. But in an age of incredibly cheap storage space, this has become pretty much a standard practice.</p>
<p>Note that the boot flag has been set, which signals to BIOS that is a bootable drive. Note also that it was formatted as fat32, which will allow it to be booted to Window Operating System should that be necessary. sdb2 is the largest partition, nearly 500 gigabytes and is mounted in two places. But the only detail that interests us right now is root represented by a single slash. And sdb3 is my swap partition set as a Linux swap File System. You can also see that all of these partitions are represented as devices in &#x2F;dev directory.</p>
<p>Gparted’s main purpos, of course, is to create, delete, and re-size partitions. We’re not going to do that now though. By the way, you should definitely be aware that you can display the partition information for all your block devices from the command line using lsblk and a great deal more information using sudo fdsk -l.</p>
<p>As a quick review, partitions organize and protect data and file systems. You can mount file systems so they’ll seem to live in different places than they actually do.</p>
<h3 id="Introduction-to-the-Linux-Logical-Volume-Manager-LVM"><a href="#Introduction-to-the-Linux-Logical-Volume-Manager-LVM" class="headerlink" title="Introduction to the Linux Logical Volume Manager (LVM)"></a>Introduction to the Linux Logical Volume Manager (LVM)</h3><p>Normal Linux installations will create three partitions. Root, represented by a slash, boot, and swap. But for business and practical considerations, you might want to separate other directories. And you always need to care for the future space and access needs. Another way to manage drives and partitions is through LVM, Logical Volume Manager. If your system is already configured with LVM, which is something you’re not expected to do for the LPI exam, you can use it to treat every physical hard drive attached to your computer as a single drive and to easily and safely re-size and rearrange any individual parts of those drives just about any way you like. For the exam, it’s enough to be familiar with some of the basic LVM tools. First of all, PV stands for physical volume. VG stands for volume group, which is a collection of one or more physical volumes and LV represents logical volume, a virtual volume you create from the contents of a volume group. To create a volume group, you could use VG Create followed by the name you like to give your group, say My VG. You follow that with the physical partition or partitions you’d like to build the group.</p>
<p>In our case, that will be &#x2F;dev&#x2F;sdb2 and &#x2F;dev&#x2F;sdb3. To create a logical volume, use LV Create &#x2F;l and the total size you want for your volume, 250 gigabytes in our case, &#x2F;n followed by the name you’d like to give to the logical volume. And then the name of the volume group from where you’d like the space to come. Finally, use LV Scan to confirm that everything worked out the way you wanted it to .</p>
<p>To review, in LVM2, physical volumes are called PV, Volume Groups, VG, and Logical Volumes, LV. You create a new Volume Group using VG Create. Create a new Logical Volume with LV Create, and display your volumes using LV Scan.</p>
<h1 id="Working-with-a-boot-manager"><a href="#Working-with-a-boot-manager" class="headerlink" title="Working with a boot manager"></a>Working with a boot manager</h1><p>In the previous course, we discussed how to edit the Grub menu to control the boot process. Now we’re going to take a bit of a step backwards, to learn how to install Grub on a computer from scratch, and to identify and update existing Grub settings. I should note that Grub is a bit of a moving target. Not only have there been different versions, known as Grub Legacy and Grub2, that for awhile at least, existed in parallel with each other, but the configuration files and commands will vary among Linux distributions, and even from one release to the next of a single distribution.</p>
<p>It can be especially confusing trying to figure out what someone means by Grub2. Is it the Grub Stage 2 that we discussed earlier, the launched by either Grub stage 1 or Grub stage 1.5, or is it Grub version 2? We’ll do our best to clear things up. One question did originally bother me a bit. If I’ve got a Linux computer running happily, why should I ever want to install or update Grub? This question is especially strong, considering how good Linux installation processes are at installing Grub automatically. In fact, many users can go for years without even being aware that Grub exists. There are two main answers to this question. First of all, there is always the possibility that you may come across a computer, especially an older application server that isn’t booted very often, that’s still running an older version of Grub, that is now known to have bugs. Just to be sure, we’ll actually reboot the next time, it can be a good idea to install the latest version.</p>
<p>But by far, the most common reason people have for considering Grub updates is to figure out how to recover from a Grub configuration that’s become corrupted. Did Windows wipe out your Grub? Did an update go badly? You might well be a candidate for some of what we’re going to talk about here.</p>
<h3 id="Managing-the-grub-bootmanager"><a href="#Managing-the-grub-bootmanager" class="headerlink" title="Managing the grub bootmanager"></a>Managing the grub bootmanager</h3><p>Okay. First of all, let’s check to see if Grub is even installed on a system by querying a package manager. By a Fedora install, use RPM-Q for query, Grub2. Note how Fedora calls it Grub2 and not just Grub. If it’s there, RPM will output the current version. If it’s not installed, run again on Fedora, Grub2-install &#x2F;dev&#x2F;sda, where dev sda is the partition where you’d like it installed. Believe it or not, that is often all you’ll need.</p>
<p>If you’ve already got a living, breathing version of Grub installed, but you’d like to edit the way it works, you need to know about a few files. Grub itself uses a script called Grub.cfg on Ubuntu or Fedora, or menu.lst on SUSE or Debian. These files are kept in the &#x2F;boot&#x2F;grub directory, except for Fedora of course, which keeps it in boot&#x2F;Grub2. The first thing you’ll see when you view the file, however, is that editing this file directly won’t do you any good. the grub script is, in fact, generated by grub-mkconfig (or grub2.mkconfig for users of you-know-which distribution) using templates from &#x2F;etc&#x2F;grub.d and settings from &#x2F;etc&#x2F;default&#x2F;grub.</p>
<p>To be more specific, &#x2F;etc&#x2F;grub.d contains files defining available operating systems and allows you to add others for your own custom menu entries. &#x2F;etc&#x2F;default&#x2F;grub is a config file that sets the rules grub will use - like the way the grub menu should appear, how to determine which OS to boot by default, and how long the default timeout should last (before automatically launching the default OS).<br>So, assuming that we’ve made some important edit to the settings files, you can update the grub.cfg (or menu.lst) file using something like grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg (for Fedora, obviously).</p>
<p>You may sometimes come across references to a command called update-grub or update-grub2. As you can see from the contents of &#x2F;usr&#x2F;sbin&#x2F; on my Ubuntu system, update-grub2 is a symlink to update-grub, and update-grub is nothing more than a script that will run the grub-mkconfig file. So I guess all those rivers lead to the same ocean.</p>
<p>Finally, while this has nothing to do with the LPIC exam, here’s a tip that can - and probably will - save your skin someday when you’re under pressure. There’s a wonderful free Linux package called Boot-Repair that will do just that: repair a broken boot process. I know what you’re thinking: if you can’t boot your computer, how are you going to load some software package? Boot-Repair thought of that, too. You can easily find simple instructions on creating a USB disk that you can plug into your comptuer and boot right into Boot-Repair. You can also launch a regular live-session of Linux, download Boot-Repair, mount your hard drive, and let Boot-Repair’s magic do the rest. You’ll definitely thank me for this one day.</p>
<p>Let’s review. The current version of grub, sometimes known as grub2, is the replacement for what we now refer to as legacy grub. grub2-install (or grub-install) followed by a target partition will install grub, grub.cfg, grub2.cfg, or menu.lst - all to be found in &#x2F;boot&#x2F;grub - are scripts generated by files in &#x2F;etc&#x2F;grub.d and &#x2F;etc&#x2F;default&#x2F;grub. the GRUB_DEFAULT setting controls which OS will boot by default (if none is selected before the timeout), other settings you can control include menu color and timeout.</p>
<h1 id="Working-with-shared-libraries"><a href="#Working-with-shared-libraries" class="headerlink" title="Working with shared libraries"></a>Working with shared libraries</h1><p>The speed and quality of an operating system is largely determined by the way it accommodates the application packages that are meant to run on it. If every office productivity and media viewing package you installed was more or less expected to create its own way of storing and handling files, identifying the local hardware environment, and connecting to the Internet, then there would be a lot less software packages available. And, those that did exist, would be a great deal larger and slower.</p>
<p>Linux ensures that software developers don’t have to reinvent the wheel with each program by providing libraries. Now, rather than, say, programming an interface to the filesystem from scratch, developers can simply have their program call a local library that will do it for them.</p>
<h3 id="Working-with-Linux-shared-libraries"><a href="#Working-with-Linux-shared-libraries" class="headerlink" title="Working with Linux shared libraries"></a>Working with Linux shared libraries</h3><p>There are two kinds of libraries: static and dynamic. A program will read a static library as it is initially installed, and incorporate its contents into its own code. This can make the program run a bit slower, but it has the significant advantage of remaining independent of external content once it’s running. For a system recovery tool, for instance, this can be a huge advantage.Dynamic libraries must remain available as it is accessed whenever the program needs its information. This, obviously, allows for much leaner and faster tools.<br>When a package is prepared for a Linux system, it will establish the libraries - or dependencies - that it will need. The various curated software repositories that serve various Linux distributions - like apt and yum - will be aware of these dependencies and will do a great job of making sure that they’re all met during the installation process. </p>
<p>However, as an administrator, you will sometimes have to work with software that’s not part of the mainstream repositories, and you’ll therefore need to handle access to libraries yourself. In this video, we’re going to learn how these libraries are designed and how you can work with them for your own projects.As you might imagine, many libraries live in or beneath the &#x2F;lib directory. From my Ubuntu system, you can see some libraries in &#x2F;lib itself, and others organized by category in subdirectories. Let’s break down a filename to understand how the naming conventions can tell us quite a lot about a library. The file begins with the letters l<em>i</em>b - telling us that it’s a library. the next section - until the first dot - is the unique library name. s*o means that this is a dynamic library - a static library would have a letter “a”, instead. The number after the second dot is the library’s version.<br>Applying the ldd program against a library will print its dependencies - libraries, you will discover, are often built on other libraries. ldd displays a library’s dependencies and the locations of their files. By the way ldd, when applied to a binary file - like these in &#x2F;bin - will also display whether the binary is dynamically linked, and if it is, what its dependencies are.<br>When a new software package prepares to install itself on Linux, it looks to a file in the &#x2F;etc directory called ld.so.cache for information on all the libraries currently available to the system. Since this file is not human-readable, there’s another file in &#x2F;etc - ld.so.conf - that mirrors the information from ld.so.cache. On some systems, ld.so.conf will contain thousands of lines of data, but at least on Ubuntu and Fedora, it only contains a pointer to the &#x2F;etc&#x2F;ld.so.conf.d directory, which, in turn, contains files pointing to libraries kept elsewhere on the system, like &#x2F;usr&#x2F;lib. Either way, with this information, you will know how to find what’s available to you.</p>
<p>You can also access the names and locations of all your currently installed shared dynamic libraries by using ldconfig Although, since I have more than 1,700 libraries right now, that might be a lot of reading. As always, you can use our old friend grep to make our lives easier. So, if we were looking to see if anything related to libQtGui might be available, we would run ldconfig -p | grep libQtGui…which will be much more manageable.</p>
<p>If you manually add or change a library, you’ll have to give Linux the good news. You can do this either by adding your library to LD_LIBRARY_PATH, or by creating a file in &#x2F;etc&#x2F;ld.so.conf.d&#x2F; called something like my_lib_name.conf in which you simply point to the directory that will host your library. You then need to run ldconfig -v to update Linux’s list - where -v tells ldconfig to be verbose and keep you up on what it’s doing.</p>
<p>To review, shared libraries provide important system information to software packages. Dynamic libraries - identifiable by the letters s<em>o, can be called whenever a program is used, while static libraries - taking an “a” rather than s</em>o - are used only during installation. Most libraries are kept in or below &#x2F;lib. ldd will display the dependencies and file locations of either a binary program or a library. &#x2F;etc&#x2F;ld.so.cache is where software packages look for a list of system libraries, while we humans can get that information through &#x2F;etc&#x2F;ld.so.conf, which points to the files in &#x2F;etc&#x2F;ld.so.conf.d&#x2F;ldconfig -p will display all current libraries, while ldconfig by itself will update the official library list.</p>
<h1 id="Debian-package-management"><a href="#Debian-package-management" class="headerlink" title="Debian package management"></a>Debian package management</h1><p>As we mentioned in the previous video on shared libraries, the various Linux package management systems do a spectacular job handling installation and dependency tracking for us. Of course, they also do much more. Since these repositories are closely curated, you can be confident that the software you download will be useful, fully functional and malware-free. And considering just how many thousands of software packages these repositories contain, the fact that everything works as well as it does is something of a marvel.</p>
<h3 id="Managing-packages-on-Debian-Linux-systems-using-dpkg-and-apt-get"><a href="#Managing-packages-on-Debian-Linux-systems-using-dpkg-and-apt-get" class="headerlink" title="Managing packages on Debian Linux systems using dpkg and apt-get"></a>Managing packages on Debian Linux systems using dpkg and apt-get</h3><p>Linux distributions mostly align themselves with one or another of the larger package management systems. The two largest of these - Debian’s dpkg, and RPM - serve some of the most popular modern distributions: dpkg can count Debian, Ubuntu, and Linux Mint among its “customers,” while RPM (whose “r” originally stood for Red Hat) serves Red Hat, Fedora and openSUSE, among others. Through this video and the next, we’ll focus specifically on these two managers - which just happens to line up nicely with the exam expectations.<br>Besides maintaining the software repositories themselves, to ensure easy compatibility, package managers also establish rules and practical guidelines for how the packages are built.</p>
<p>Thus, a .deb package meant for dpkg won’t work on a system that’s looking for .rpm. That’s seldom a problem, since most software that’s available on one, will be similarly accessible through the other. But it does mean that the fine working details of the two package managers will be a bit different, and you will definitely be expected to be familier with them for the exam. So let’s take a good look at Debian’s dpkg - and leave RPM for the next video. </p>
<p>You can install, remove, status-check and generally manage your software using the dpkg command and its arguments. However, there are a number of frontend programs - each with its own unique features - that can do a great deal more. We’ll explore three of these: apt, aptitude, and synaptic a bit later. In the meantime, we’ll go through some of dpkg’s own functions. dpkg’s default behavior is controlled by the dpkg.cfg file found in the &#x2F;etc&#x2F;dpkg directory. This particular copy has only two settings concerning package signatures and log locations. If you’ve directly downloaded a .deb package you can install it with root authority using dpkg -i</p>
<p>We’ll use this fictitious package to illustrate Debian naming standards, where my_package is the package name, the number is the package version, i386 is the architecture it was written for (32-bit, in this case), and deb identifies it as a Debian package. You can use dpkg…to unpack package files without actually going through configuration process. I would imagine this might be useful if you plan to manually create a non-standard configuration profile.</p>
<p>You can remove a package that’s currently installed, identifying it through its short name, using dpkg -r. To remove the package files AND its user settings, use purge. And dpkg-reconfigure will reconfigure an already-unpacked package. You can use debconf if you want to simply display a package’s configuration:</p>
<p>To review. You can manage local software packages using dpkg. dpkg defaults are kept in the dpkg.cfg file. You can install a package using dpkg -i. dpkg –unpack will unpack but not install. dpkg -r will remove a package, dpkg -P will purge it, and dpkg-reconfigure will allow you to configure a package’s settings over again</p>
<p>Now, as you might have noticed, dpkg only works with local packages, and not external repositories. The best way to access the wide world of Linux software, therefore, is through APT (which stands for Advanced Packaging Tool). You tell Linux how to find the Debian repositories through the sources.list file that’s kept in the &#x2F;etc&#x2F;apt directory.</p>
<p>You can see pairs of links to Internet URLs: one of each pair called deb - obviously for Debian - and the other deb-src. Each link points to the repo associated with a particular release - in this case Ubuntu’s Trusty - and a specific category. We can see main, universe, and multiverse here. Each of those contains a different range of programs. deb URLs will contain program packages including binary files, while deb-src sites contain program source code files. If you want to manually add a previously inaccessible repo source - perhaps a trusted third party source - this is the file you will update. Just be careful to get the syntax right or it might not work.</p>
<p>The most popular command line tool for software management is apt-get. apt-get update will tell your local apt system about any new package information available from appropriate remote repositories. apt-get install, followed by the package name, will install a package. apt-get upgrade will search for and apply all available package upgrades. apt-get dist-upgrade is similar to apt-get upgrade but, in addition, will also intelligently remove dependencies made unnecessary by overall changes. apt-get remove will, predictably, remove a package you no longer need. Finally, running apt-get install using the -s flag will display dependency and installation information, but without installing:</p>
<p>Another way to view package data is through apt-cache. apt-cache stats will display some package information about a specified package. apt-cache depends will display package dependencies and apt-cache unmet will display any unmet dependencies associated with a specificed package. Running apt-cache unmet without specifying a package will output all unmet dependencies on the whole system. Be prepared to go through a lot of reading!</p>
<p>Besides running apt from the command line, you can also use Aptitude, which is a terminal-based interface for people who aren’t yet comfortable with apt-get but too embarrassed to use a true GUI interface like Synaptic. To be honest, I’m not really sure what value Aptitude has these days (although, now that I’ve said that, I’m sure that I’ll receive hate mail from it’s supporters), but the LPI exam expects you to know about it. Hitting the ? key will give you a help page, and hitting q will exit. What more could you possibly need?</p>
<p>Let’s review. The sources.list file tells Linux where to find your remote software repositories. Links in the sources.list file point to repo URLs, including repo type, address, distribution, and category. apt-get update will update information about available upstream packages. You can install packages using apt-get install, upgrade all packages using apt-get upgrade or apt-get dist-upgrade, apt-get remove will, predictably, remove a package you no longer need. apt-get install -s will display package information but not install it, and apt-cache stats, depends, or unmet will also display package information.</p>
<p>Finally, Synaptic will nicely manage your packages from the Desktop. Besides doing just about everything apt-get can do, Synaptic is also a great research tool, allowing you to search for packages [chess] and look up file and version information.</p>
<h1 id="RPM-x2F-YUM-package-management"><a href="#RPM-x2F-YUM-package-management" class="headerlink" title="RPM&#x2F;YUM package management"></a>RPM&#x2F;YUM package management</h1><p>We’re going to continue discussing the topic of package managers, a topic the LPI considers more important than most.</p>
<p>Interestingly, the job description for the first full-time Linux sysadmin job I got demanded familiarity with Linux package management more than anything else. Many months later, I asked my boss why he focused on that the way he did, especially considering how many other skills I had to draw on for the day-to-day work I’d been doing. He replied he’d done it that way for two reasons. Because package management is, in fact, a major foundation for so much else in Linux administration, and because being comfortable with apt and yum was a particularly good indication of good general experience. I now agree. As with the dpkg system that we discussed in the previous video, RPM software packages that already exist locally can be installed and removed directly using, in this case, the RPM program.</p>
<h3 id="Working-with-RPM-and-Yum-package-management"><a href="#Working-with-RPM-and-Yum-package-management" class="headerlink" title="Working with RPM and Yum package management"></a>Working with RPM and Yum package management</h3><p>The file naming conventions for RPM work much the same way as for dpkg as we can see from this package I downloaded to my Fedora machine. In case you’re wondering, it’s ApacheDS, an LDAP and Cerberus server. Here, ApacheDS is the package name. The number is the package version, X86_64 is the architecture it was built for. This time, it’s 64-bit, and the .rpm extension tells our system that it’s an RMP package.</p>
<p>As the root user, we would install the package using rpm -i. We can also install - or upgrade it - using rpm -U …which, if you ask me, can be a bit dangerous, as, under the circumstances, you’d normally associate u with uninstall. rpm -q will query the existence of a package. We’ll run that against our ssh server to make sure it’s there. Of course, since I’m currently logged into Fedora using ssh, I’d definitely assume it is. rpm -i –test will test a package for dependencies. In this case, it’s a good thing we checked, because apacheds is a 64-bit package and the machine Fedora is running on is - if you can believe it - only 32 bit. rpm -e will remove a package. Running rpm -e with the –nodeps argument will only remove files that aren’t dependencies elsewhere.</p>
<p>You can (and should) get the checksum from an rpm package using rpm -vK (where v adds more verbose messages). You should then compare the output to the checksum provided by your package source. rpm -V will verify a package. In our case, we’re correctly told it’s not yet installed.</p>
<p>Let’s review. rpm packages place the package name first, the version next, followed by the architecture and the .rpm extension. rpm -i or -U will install a package. -U will also upgrade the package. rpm -q queries the existence of a package. rpm -i –test returns a package’s dependencies. rpm -e will remove a package, and adding –nodeps will respect other package’s dependencies. rpm -K returns a checksum. And rpm -V will verify a package.</p>
<p>Like apt-get on the Debian system, yum provides a powerful front end for rpm. The folder &#x2F;yum.repos.d&#x2F; will contain repo files for each repo that’s currently in use on your system. Here, rather than throwing them all into a single file the way apt does it, yum provides a separate file for each software category. Repo information can also be stored in the &#x2F;etc&#x2F;yum.conf file.</p>
<p>Using yum to work with packages is straightforward. You can install a package using yum install xboard. xboard, by the way, is a chess game. If you’re already bored with that, you can remove it using yum remove. To update a package, use yum update. And to search for an installed program, use yum search. yum list will list all available programs. Although, since there are bound to be lots of them, you might prefer to use grep to narrow down your search. yum list installed will list installed programs. You can also directly download packages from online repositories without installing them using yumdownloader, where –resolve will take care of dependencies.</p>
<p>Since rpm files are usually compressed using the cpio file archiver, if you ever want to access all or some of the files from an rpm archive, you’ll need to use rpm2cpio. In this example, we’ll pipe the contents of the apacheds package to cpio itself, and where i tells cpio to restore the archive, and d tells it to create leading directories where needed.</p>
<p>By way of review, the folder &#x2F;etc&#x2F;yum.repos.d&#x2F; or the &#x2F;etc&#x2F;yum.conf file will contain pointers to repo sources. Yum is really simple: install will install a package, yum update will update, yum remove will remove, and yum search will search. yum list and yum list installed will display packages according to your needs. You download packages without installing them using yumdownloader</p>
<h3 id="Working-with-Yum-on-AWS-Linux"><a href="#Working-with-Yum-on-AWS-Linux" class="headerlink" title="Working with Yum on AWS Linux"></a>Working with Yum on AWS Linux</h3><p>AWS Instances using the Amazon Linux distribution use rpm and yum for file management. By default, the &#x2F;etc&#x2F;yum.repos.d directory contains links to specially managed Amazon repos like amzn-main. Of course, if you choose an Ubuntu-based instance, you will find everything through dpkg and apt. The software installed on AWS instances can also be provisioned by script using deployment services like Elastic Beanstalk.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/" rel="prev" title="Linux-LPIC-101-LPIC-1-101-Linux-certification---System-Architecture-2-of-5-2">
      <i class="fa fa-chevron-left"></i> Linux-LPIC-101-LPIC-1-101-Linux-certification---System-Architecture-2-of-5-2
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-101-Create-Your-First-Amazon-EC2-Instance-Linux-4/" rel="next" title="Linux-LPIC-101-Create-Your-First-Amazon-EC2-Instance-Linux-4">
      Linux-LPIC-101-Create-Your-First-Amazon-EC2-Instance-Linux-4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-introduction"><span class="nav-number">1.</span> <span class="nav-text">Course introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Partitions-and-Filesystems"><span class="nav-number">2.</span> <span class="nav-text">Partitions and Filesystems</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Designing-Linux-disk-partitions"><span class="nav-number">2.0.1.</span> <span class="nav-text">Designing Linux disk partitions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction-to-the-Linux-Logical-Volume-Manager-LVM"><span class="nav-number">2.0.2.</span> <span class="nav-text">Introduction to the Linux Logical Volume Manager (LVM)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Working-with-a-boot-manager"><span class="nav-number">3.</span> <span class="nav-text">Working with a boot manager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Managing-the-grub-bootmanager"><span class="nav-number">3.0.1.</span> <span class="nav-text">Managing the grub bootmanager</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Working-with-shared-libraries"><span class="nav-number">4.</span> <span class="nav-text">Working with shared libraries</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Working-with-Linux-shared-libraries"><span class="nav-number">4.0.1.</span> <span class="nav-text">Working with Linux shared libraries</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Debian-package-management"><span class="nav-number">5.</span> <span class="nav-text">Debian package management</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Managing-packages-on-Debian-Linux-systems-using-dpkg-and-apt-get"><span class="nav-number">5.0.1.</span> <span class="nav-text">Managing packages on Debian Linux systems using dpkg and apt-get</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPM-x2F-YUM-package-management"><span class="nav-number">6.</span> <span class="nav-text">RPM&#x2F;YUM package management</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Working-with-RPM-and-Yum-package-management"><span class="nav-number">6.0.1.</span> <span class="nav-text">Working with RPM and Yum package management</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Working-with-Yum-on-AWS-Linux"><span class="nav-number">6.0.2.</span> <span class="nav-text">Working with Yum on AWS Linux</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
