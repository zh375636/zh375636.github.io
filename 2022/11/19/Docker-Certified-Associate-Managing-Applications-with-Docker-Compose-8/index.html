<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course IntroductionWelcome to managing applications with Docker Compose. About MeI’m Logan Rakai and I’ll be your instructor for this course. I’m a content researcher and developer here at Cloud Aca">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8">
<meta property="og:url" content="https://example.com/2022/11/19/Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course IntroductionWelcome to managing applications with Docker Compose. About MeI’m Logan Rakai and I’ll be your instructor for this course. I’m a content researcher and developer here at Cloud Aca">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T04:44:37.000Z">
<meta property="article:modified_time" content="2022-11-21T02:23:42.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:44:37" itemprop="dateCreated datePublished" datetime="2022-11-19T00:44:37-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 22:23:42" itemprop="dateModified" datetime="2022-11-20T22:23:42-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker-Certified-Associate/" itemprop="url" rel="index"><span itemprop="name">Docker-Certified-Associate</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Docker-Certified-Associate-Managing-Applications-with-Docker-Compose-8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Welcome to managing applications with Docker Compose.</p>
<p>About Me<br>I’m Logan Rakai and I’ll be your instructor for this course. I’m a content researcher and developer here at Cloud Academy. I’ve mostly worked on developing Labs, but I’m excited to be your instructor for this course. I’ve put a lot of thought into it and I hope you enjoy it. I have over ten years of experience in software research and development including five years in the cloud. I’m an AWS Certified DevOps Engineer Professional and a Microsoft Certified Solutions Expert: Cloud Platform and Infrastructure. You can connect with me on LinkedIn or on Twitter.</p>
<p>Who this course is for<br>This course is for anyone who could find themselves working with Docker containers. Among the roles that might be in that situation are <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/devops/">DevOps</a> engineers, developers, cloud engineers, and test engineers.</p>
<p>Prerequisites<br>In order to get the most out of this course, you should have experience with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-to-docker-2/course-intro-1/">Docker</a>. You probably have enough experience if you have ever written a Dockerfile or if you can answer questions like when should you use a volume? And when should you use a user-defined network? The course includes some development demos that are most beneficial if you have some software development experience. You can follow along and I’d encourage you to. You will need Docker version 1.13 or greater installed. I’ll be using a Mac with Docker for Mac installed but you can follow along in Linux or Windows. The code I’ll be using is all available on GitHub. A clickable link is available at the bottom of the transcript for this lesson. You’ll benefit from a good integrated development environment or IDE. I’ll use Visual Studio Code which is available for free on mac, Linux, and Windows.</p>
<p>What we’ll cover<br>In this Course, we’ll go over what <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/docker-compose-overview-1/">Docker Compose</a> is and why you would use it. Then we’ll explore the two parts of Docker Compose: Docker Compose files and the Docker Compose command-line interface. Next, we’ll get into demo-focused lessons beginning with running a web app with Compose. After that, we’ll see how to build images in a development scenario with Compose. Lastly, we’ll see how to use Compose to adapt an application to multiple different environments. In particular, we’ll see how to use Compose to manage an application in development and production. Wow, after seeing all those exciting topics I need a second to Compose myself.</p>
<p>Learning Objectives<br>After completing this course, you will be able to:<br>• Understand the anatomy of Docker Compose files<br>• Configure your application using Docker Compose files<br>• Use the Docker Compose CLI to manage the entire lifecycle of applications<br>• Build your own images from source code with Docker Compose<br>• Extend Docker Compose files to adapt applications to multiple environments</p>
<p>Feedback<br>I’m happy to hear from you. I make content for you and I want it to be as good as it can be. If you have any feedback, please get in touch with me by leaving a comment on the Comments tab below the video, by emailing <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>, or by connecting with me on Twitter where my handle is @LoganRakai.</p>
<p>All right, that’s all for the introduction. In the next lesson, we’ll start to get a better idea of what Docker Compose is. Continue on to the next lesson whenever you are ready.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/cloudacademy/docker-compose-training">https://github.com/cloudacademy/docker-compose-training</a></p>
<h1 id="Docker-Compose-Overview"><a href="#Docker-Compose-Overview" class="headerlink" title="Docker Compose Overview"></a>Docker Compose Overview</h1><p>Thanks for joining me. We will start to peel back the outer layers of Docker Compose in this overview lesson.</p>
<p>I will begin by looking at how you might accomplish a task without Docker Compose. This will highlight some of the issues that Docker Compose was made to solve and give motivation for this lesson and really the entire course on Docker Compose.</p>
<p>Then I will define Docker Compose at a high level in terms of what it can do and how it does it.</p>
<p>Lastly, I will introduce the two parts that make up Docker Compose.</p>
<p>By the end of this lesson, you will understand what Docker Compose is, why you would use it, and get to know a bit about the parts that make up Docker Compose.</p>
<p>Ok, to start off with, I want to share the motivation for Docker Compose and it will give an opportunity to review some core Docker concepts. Let’s say that you are working on developing an application with Docker. The application is relatively simple, consisting of two services that communicate with one another. Each service corresponds to a container in the diagram. One service, let’s call it service A, is entirely stateless and should be accessible from the host machine on a port. The other service, service B, is required to persist data. You have Dockerfiles for both services already.</p>
<p>The task at hand is to spin up a temporary environment with the application running to perform some tests and tear it down when you are finished. How do you create this environment?</p>
<p>In a world before Docker Compose, you might go about achieving that with the following series of Docker commands. You want to follow best practices in isolating your application’s containers from other containers that are running on the Docker host. To give you the most control over that you create a user-defined bridge network.</p>
<p>Using a user-defined network also gives you access to automatic DNS resolution from container names to IP addresses that your application might take advantage of.</p>
<p>For service B that persists data, you want to follow best practices again by choosing an option that is easy to back up and migrate, that can be managed using the Docker commands, can be safely shared among multiple containers, and have the flexibility to be stored on remote hosts or in the cloud. You naturally decide to create a volume to achieve this.</p>
<p>Now you build the Docker images using docker build with the –f option to specify the different Dockerfiles for each service.</p>
<p>Almost there. You only need a couple more commands to start running the containers using the images you built. The docker run command creates the containers and starts running them. You use the –network option so that both containers are in the app_network in order to communicate. You use the -p option so that Service A is accessible on a host port. You use the –mount option for service B to mount the volume into the container.</p>
<p>Now everything is up and running so you can perform some tests.</p>
<p>After your tests are completed you decide to tear down everything you created to keep the environment pristine.</p>
<p>Start by stopping the service A and service B containers. Once the containers are stopped, you are able to remove them. Next you can remove the images you built for service A and service B. After that, you’re free to delete the volume for service B’s persisted data. And finally, you can remove the network that enabled communication between the two containers. And that’s it.</p>
<p>Now let’s take a moment to discuss the solution in the grand scheme of things. Setting up and tearing down the environment required about ten Docker commands. Relatively speaking, it is not too bad compared to a solution using virtualization and even better when compared to what would be involved using bare metal. Docker has made great progress in creating environments quickly and without having to worry about nasty issues like configuration drift.</p>
<p>Now, the series of commands used isn’t the minimal number you could use to achieve the same result. For example, you might decide that it is acceptable to have Docker automatically create the volume for you as a side effect of the –mount option in the run command instead of explicitly creating the volume with docker volume. But even after some optimizing, the fact remains, there is a lot of typing involved to accomplish a fairly common task. Not to mention there could easily be more options involved for configuring each command. </p>
<p>However, it is natural to ask the question, can we do better? One option that could be useful when performing the commands more than once is to put all the commands in a script. That also allows you to check the script into version control to better manage changes and collaborate with other team members. But to write the script you still need to know all of the docker commands required and the sequence to put them in. You are in essence telling Docker how to do something with the commands in the script. This is sometimes referred to as the imperative paradigm in DevOps where you give explicit steps to perform.</p>
<p>As an alternative, wouldn’t it be nice to only have to declare what you want to make instead of the explicit steps to perform to create what you want? That is to take a declarative, as opposed to an imperative, approach and let some tooling figure out the steps to create what you want.</p>
<p>That is in essence what Docker Compose gives you with respect to defining and managing multi-container environments in Docker. You still get the benefits of being able to use source control, but the emphasis shifts to describing what you want instead of how to create it. By way of analogy, Docker Compose is similar to using Dockerfiles. You can run a container, attach to it, run some commands, and use Docker commit to create a new image from the container. But in most situations, you want the enhanced documentation and maintainability that a Dockerfile gives you for accomplishing the same task along with Docker build. Analogously, you usually want to use Docker Compose instead of running a series of Docker commands.</p>
<p>That gives you a high-level understanding of what Compose is and why you might use it. In the context of Docker, you can refer to Docker Compose simply as Compose. You will see a lot of examples of Compose in action throughout this course to develop a more robust understanding of Compose. </p>
<p>It is also worth noting that Docker Compose files can be used to manage multi-container applications that are distributed over a cluster of computing resources. To natively manage a cluster in Docker, you run Docker in swarm mode. Swarm mode is outside of the scope of this course. You can learn more about swarm mode in other excellent content on Cloud Academy. I just want you to know that the time you spend learning Docker Compose in a single host environment will pay dividends later on when you start running applications on a Docker swarm cluster.</p>
<p>Docker Compose consists of two parts: a specially formatted file called a Compose file, and a command-line interface.</p>
<p>A Compose file is where you declare services that comprise your application. You can do a lot inside a Compose file. The Docker commands you use for creating containers, volumes, and networks have equivalent declarative representations in Compose files. Knowing Docker commands makes writing Compose files quite easy given their close connection.</p>
<p>There is an entire lesson devoted to the details of Compose files in this course. To get a sneak peak of what’s to come, take a look at this example Compose file. The services section declares two services: web and redis. Each service has a set of options underneath it. For the web service, there’s an option for specifying the image, which ports to make expose on the host machine, and a volume to mount in the container created for the service. There is also the depends_on option which isn’t something that has an equivalent docker command option. It becomes necessary in the context of Compose because you need a way to specify the order services come up. You can no longer issue commands in a specific order as you would with docker commands. But I’m getting ahead of myself. We’ll cover a lot more details on Compose files in an upcoming lesson.</p>
<p>The other part of Compose is a command-line interface. It has a familiar feel to the docker command-line interface. Many of the commands you use with docker exist in docker-compose but generalized to multi-container applications. The name of the Compose binary is appropriately docker-compose. As an example of the power of docker-compose, the series of docker commands that was presented in the Motivation section can be performed with just two commands in Docker Compose. One for bringing the application up, and another for tearing everything down. The simplicity of creating isolated environments with Docker Compose makes automated testing one of its key use cases. As with Compose files, there is an entire lesson in this course devoted to the Compose command-line interface. You will also see a lot of both Compose files and command-line interface in all of the lessons that present examples showing you how to use Compose for different tasks.</p>
<p>It can be difficult to manage multiple container applications. In the example at the beginning of this lesson, many commands and options are required to start and stop a relatively simple multi-container application. The difficulty in managing multi-container applications grows with the number of containers involved.</p>
<p>Docker Compose lets you specify services in a multi-container application using a declarative paradigm. You declare what you want and Compose figures out how to create it.</p>
<p>There are two parts to Compose. Compose files are where you declare the services you want, and the docker-compose command-line interface is how you manage the multi-container application declared in a Compose file.</p>
<p>That’s all for this overview lesson on Docker Compose. We’ll dive deep into Compose files in the next lesson. Whenever you are ready, continue on and start to see your multi-container applications through the Docker Compose lens.</p>
<h1 id="How-to-Create-Docker-Compose-Files-Using-YAML"><a href="#How-to-Create-Docker-Compose-Files-Using-YAML" class="headerlink" title="How to Create Docker Compose Files Using YAML"></a>How to Create Docker Compose Files Using YAML</h1><p>It’s time to start digging into the details of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">Docker Compose</a>. We’ll start by taking a close look at Compose files in this Lesson.</p>
<p>Agenda<br>I will start by giving you a brief introduction to the file format used for Compose files: YAML. If you haven’t used YAML before, you’ll learn enough to understand the Compose file examples used in this course.</p>
<p>Next, I will teach you about the root elements in a Compose file document. These are the top-level element of a Compose file and include: Compose file version, services in the application, volumes used by the services, and networks to be created. There is a lot of similarity between these sections of a Compose file and Docker commands that you are familiar with.</p>
<p>I will finish the lesson with a couple special topics in Compose files.<br>Let’s get started with YAML.</p>
<p>YAML</p>
<p>YAML is a data serialization language. Data serialization languages can be employed for a broad variety of programming scenarios including internet messaging, object persistence, or, in the case of compose, configuration files. Some of the design principles of YAML are that it should be human-friendly, and that it should work with any programming language. When YAML is stored in a file, the file can have a .yaml or .yml extension. Both are recognized as YAML. The capabilities outlined in the YAML specification are quite extensive. We’ll only really scratch the surface of what you can do with YAML.</p>
<p>Another, perhaps more common, data serialization language is JavaScript Object Notation (JSON). JSON formatted files are supported by Docker Compose. However, it is rare to see JSON Docker Compose files in practice. Comparing a YAML file to its JSON equivalent shows the cleanliness and fewer characters needed to represent the contents. In this example, Part of the reason why it can cut down on the line count is because it is whitespace sensitive. That means if you insert an extra space at the wrong place, the file will be corrupted. JSON on the other hand isn’t whitespace sensitive, meaning that you could squash all the whitespaces out and not harm the integrity of the file. However, readability would not fare so well. For that reason, JSON files tend to be formatted with abundant whitespace resulting in a less compact representation than YAML. It can take some getting used to working with a whitespace sensitive language, but IDEs tend to have support for formatting YAML files making it quite painless to work with. Some features of YAML, which is actually a superset of JSON, further enhance the compact representation of Compose files. You will see an example of this later in this lesson.</p>
<p>Data Types<br>Let’s take a look at a few basic data types in YAML. This list isn’t comprehensive but is enough to understand what usually goes into Compose files.</p>
<p>The first YAML data type we’ll consider are integers. Integers are whole numbers like zero or 1. You can also include a leading plus or minus sign to indicate positive or negative integers.</p>
<p>Strings are a sequence of characters that aren’t interpreted as a different data type. Strings can include spaces and the use of quotes to indicate the start and end of a string. Quotes are optional unless you use symbols that have a special meaning. Use single quotes around strings that use YAML syntactic characters like the pound symbol or colon. Use double quotes if you want to escape control characters like backslash n for newlines. If you want an integer to be interpreted as a string, you need to enclose it in quotes because it will be interpreted as an integer otherwise.</p>
<p>The null type is used to represent the absence of a value, or no value. It isn’t very common to see in Compose files but is a recognized data type in Compose. You use a tilde or the word null to represent it.</p>
<p>Booleans<br>Booleans are the last data type we’ll discuss. They indicate one of two values: true or false. Booleans can be represented with true, false, yes, no, on, off as well as the same words with the first letter capitalized or all the letters capitalized. In YAML any matches of a pattern including yes, and on get converted to true. This can cause unintended consequences if you have conditions testing Boolean values. For example, if you had a condition that was checking if a variable has a Boolean value of yes but it automatically got converted to true. Compose simply disallows the use of Booleans in contexts where such issues can arise to be on the defensive side.</p>
<p>You’ll see an error message similar to this if you use a Boolean value. In this particular case, I tried to use a Boolean as an environment variable. As the error message hints, only strings, number, or a null can be used. If you want to use true or false, yes or no, on or off as values, you need to use the string representation by wrapping them in quotes. If you ever encounter an error message involving true or false, this is probably what it relates to.</p>
<p>Collections<br>Collections are data structures that allow you to collect basic data type values in an organized manner. The first YAML collection we’ll consider is the mapping. Mappings are also known as dictionaries or hashes in different programming languages. Maps consist of keys mapped to values. The syntax for a mapping is a key followed by a colon, a space and then the value. The space is important. A mapping can have multiple key value pairs.</p>
<p>Mappings can also have mappings as values. Using a mapping as the value for a mapping is referred to as nested mappings. In Compose files the inner mapping is usually located on a new line with indentation.</p>
<p>There is also an inline syntax that lets you write a nested mapping on a single line. You use braces to wrap the inner mapping in this case. You may see this from time to time but I think it tends to hurt readability and should be avoided.</p>
<p>Sequences<br>The other kind of collection is a sequence. Sequences are also called lists or arrays in other languages. Sequences are simply lists of values.</p>
<p>You use dashes to indicate items in a sequence. Each item goes on its own line at the same level of indentation.</p>
<p>Sequences can also be nested. To represent an inner sequence, you use an indented dash on a new line below the outer sequence.</p>
<p>As with mappings, there is an inline syntax to represent a sequence on a single line. You use brackets to wrap a comma-separated list of items to use inline syntax. You see this inline syntax used for command options in Compose files.</p>
<p>Combos<br>You can also combine the sequence and mapping collections. For example, you can have a sequence as the value of a mapping. The dash in a sequence as a mapping value also counts as indentation, so you don’t have to use spaces for indentation when including a sequence in a mapping. That means both of these examples are valid YAML. You might prefer to indent for consistency, but they are not required and you will see both styles used in practice.</p>
<p>Similarly, you can use mappings in a sequence. There is again two ways to represent a mapping in a sequence. You can use a line with only a dash followed by the indented mapping, or you can include the first line of the mapping on the same line as the dash. Both styles get used and you should be aware of each.</p>
<p>The last thing I want to mention about YAML is that is supports inline comments. This makes it much more useful in terms of documenting Compose files than JSON which doesn’t support commenting. In YAML, a comment starts when a pound character is encountered and continues to the end of the line. The exception to a pound character starting a comment is if it’s within a quoted string.</p>
<p>That is enough YAML to get through the example Compose files used in this course. It’s also enough to understand most examples you might find online and enough for you to write your own Compose files. As I mentioned before, using an IDE that can automatically format YAML can save you some headaches. Compose also includes a command for verifying configuration files in case you need to verify your YAML syntax and configuration declared in a Compose file.</p>
<p>Compose files<br>Now that we’ve built up a foundation in YAML, we can focus on Compose file specifics. As mentioned earlier, YAML Compose files are the focus and make up the vast majority of Compose files in use. We will only consider version 3 Compose files.</p>
<p>From this compatibility table, you can see that version 3 Compose files require a Docker Engine of version 1.13 or higher. The <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/docker-compose-cli-1/">Docker Compose command-line interface</a> has a different release schedule than the docker engine, and requires version 1.10 or high for version 3 Compose files. Docker recommends using version 3 Compose files. There are multiple minor version numbers for version 3, for example 3.0 and 3.4. Unless otherwise noted, examples used in this course follow the 3.0 Compose file format. This covers versions of Docker released since the beginning of 2017.</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file">https://docs.docker.com/compose/compose-file</a> The Compose file reference is a great reference for understanding all the configuration options available to you in Compose files. This course covers many frequently used configuration options, but leaves out many that might be useful in certain situations. Let’s take a quick look at it now.</p>
<p>Here we are at the Compose file reference page. It defaults to showing reference material for the latest major version which is 3 at this time. There is a handy navigation bar on the right to see all the available configuration options</p>
<p>Just note that it can be confusing at times because some configuration options only apply to Docker swarm mode (deploy), some only apply when not running in swarm mode (security_opt), or specific Compose file minor versions (Extension fields), and sometimes different options are available for Docker running on Linux or windows based systems (isolation).</p>
<p>Version<br>A YAML Compose file is a mapping with several keys at the root or top level. The first one we’ll discuss is the version. The value for the version must be a string. The string can specify a major version number only, for example 3, or a major and minor version number, such as 3.1. If a only major version is included, the minor version is implied to be 0, or the earliest release. So if you want to use a feature that came out in the latest minor version release, you need to include it in the version string. The version string tells Compose how the contents of the file should be parsed.</p>
<p>Services<br>The services mapping is where you configure the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">containers</a> created for services in your application. Each service is configured in a nested mapping under the services key. You can assign an arbitrary name for each service. In the image, the service names are web and redis. Each service has a nested mapping that declares the configuration for containers started for the service. The configuration is the main piece of declaring services in a Compose file, so let’s focus in on that.</p>
<p>Configure the container for the service.<br>Inside of the service configuration mapping, you declare the configuration options for service containers in a way that is similar to how you would configure containers using docker run command parameters.</p>
<p>This table shows how you would configure a container using the docker run command and the corresponding configuration key in a Compose file. The only required argument for docker run is the image name, which you specify using the image key in a Compose file. There are a few ways to configure a volume with docker run, but they all map to the volumes key in Compose files. There are different syntaxes in Compose to support the different volume configurations that you use different parameters for with docker run. The -p parameter to publish ports on the host corresponds to the ports key in Compose files. The -e parameter for setting environment variables in a container maps to the environment key in Compose files. With docker run you have two parameters for setting up logging and both parameters go into a nested mapping under the logging key. The last one that I’ll mention is security-opt for setting security options which only differs in the use of an underscore in Compose files. There are many more, but aside from a using YAML and slightly different names your experience with docker run will make writing Compose files easy.</p>
<p>Caveats<br>There are some points to be aware of for the correspondence between docker run and Compose file service configuration. Some docker run parameters that you might expect to be able to use in Compose only work in swarm mode. This is the case for setting runtime constraints such as -m for memory limit, or –cpus for number of cpus. It’s possible to run Docker in swarm mode with a single machine so it isn’t a significant barrier. However, Swarm mode is outside of the scope of this course so that’s all I will say about it.</p>
<p>Other docker run parameters such as -d to run in detached mode or –rm to clean up the container when it exits are specified through the command-line interface and not in the Compose file configuration.</p>
<p>Dependencies<br>Because Compose supports multi-container applications, there are additional options for configuring services that don’t exist with docker run.</p>
<p>The depends_on key provides a way to list the services a service depends on. Docker Compose can use the dependency relationships to determine the order to start services. If you tell Compose to start a specific service instead of the entire application, Compose can also use the information to automatically start any dependencies of the service. However, it’s important to note that Compose won’t wait for the dependencies to be ready before starting a service. For example, Compose can start a database before a web service but it can’t account for the time it takes the database process to be ready to handle connections. Because of this, it’s best practice to write your applications in a way that can tolerate connection failures. If that isn’t an option, you can use scripts that poll the dependencies to wait until they are ready. One such script is called wait-for-it.sh.</p>
<p>The other key that expresses dependencies is links. Links correspond to the link parameter of docker run allowing you to grant access to a container to access an exposed port on a private interface and to provide aliases to reach containers. Links in Compose carry the same meaning but additionally determine startup order of services, the same way depends_on does. Generally, networks are a better way to express communication relationships. We’ll discuss more about networks in a bit.</p>
<p>Examples<br>To get a taste of service configuration in Docker Compose, let’s look at some examples. I’ll arbitrarily use the redis image for the examples. Starting off simple, this docker run command will start a container named app-cache using the redis image.</p>
<p>The equivalent service configuration in a Compose file would like this. In the first line we need to specify that we are using version 3 of compose files. The services mapping is a pretty simple conversion of the docker run command parameters. The container name used as the service key, and the redis image argument used as the image key-value pair.</p>
<p>Now, if you specify a tag to pull a specific version of the image,<br>you add the same tag to the image value. Note that although the colon is a special character in YAML, you don’t need quotes around the string because colon only takes on special meaning when followed by a space.</p>
<p>If you want to the redis server port of 6379 available on the Docker host, you include the -p argument like so.</p>
<p>The corresponding Compose file includes a ports key which has a sequence of port strings. Just like with Docker run you can specify host and container port, or just the container port to allow Docker to choose an available host port. When specifying host and container port like in the example, it’s a good idea to put quotes around the string because YAML will parse numbers separated by a colon as sexagesimal or base 60 numbers if the numbers are less than 60.</p>
<p>In this last example, a command with arguments is added to override the default command.</p>
<p>The same string can be used as the value of the command mapping in a Compose file.</p>
<p>Or you can use the same syntax you would use in a Dockerfile for setting the default command of an image. In this case you do need quotes around the last argument “yes” otherwise it gets treated as a Boolean value. It’s best to always quote as you would in a Dockerfile. You might also recognize that syntax as the inline syntax of a sequence.</p>
<p>That means you can also express the command in the normal sequence syntax. This form can make long commands more readable. You get the idea of how to work with service configuration in Compose files through these examples. You might need to consult the Compose file reference to get the correct key names but it’s usually a fairly straightforward exercise to write the configuration.</p>
<p>Volumes<br>The next root key in the Compose file mapping is volumes. It is an optional key. You use the volume mapping in a way that is similar to how you use docker volume create. Services can reference volumes in each service’s volumes configuration key.</p>
<p>It’s a good time to point out that you can use volumes in the service’s configuration even if you don’t have a volumes key in your Compose file. The use case for the root volumes key is to use named volumes and to share volumes across services.</p>
<p>You can also declare external volumes that have been created outside of the context of the Compose file. For example, a volume created by docker volume create, or a different compose file. In a volume’s nested configuration mapping, you can set the external key to true to declare an external volume. If the external volume doesn’t exist, an error will be reported.</p>
<p>Take a look at this example Compose file using the root volumes key. There are two named volumes declared on lines 13 and 14. The first, called named-volume, doesn’t have any nested configuration. This will create a volume using the default local volume driver. YAML sees the absence of any value and represents it as a null. You could equivalently write a tilde or the word null for the value on line 13. The other named volume is called external-volume and is configured as an external volume.</p>
<p>In the app-cache service’s volumes configuration starting on line 5, you can see a few ways to declare volumes in Compose. The first is using a named volume in the root volumes key and will be mounted at &#x2F;data in the container. The next example on line 9 uses a relative path to set the source of the mount. Relative paths are relative to the location of the Compose file. The last example on line 11 will have the Docker Engine create a volume automatically to mount at &#x2F;tmp&#x2F;stuff in the container.</p>
<p>Lastly for volumes, you can configure a custom volume driver using the driver and driver_opts keys. The named volume in the example called ebs-volume uses the convoy docker volume plugin by rancher. If you want to specify any driver-specific options, you can do so under the driver_opts key.</p>
<p>Networks<br>Networks are declared under the top-level networks key. By now it will come as no surprise, that network configuration in Compose files aligns closely with the docker network create command. However, there are a few new concepts to networking in Compose.</p>
<p>By default, Compose will automatically create a new network using the default bridge driver for an application in a Compose file. The name of the network is based on the name of the directory the Compose file is in with default appended on the end. All containers created for services in the Compose file join the default network and can be reached and discovered by the corresponding service name. This is slightly different from running containers with docker run and not specifying a network. In that case, the containers get added to the default network named bridge.</p>
<p>To review how you can use a bridge network, consider this example Compose file. There are two services, web, and cache. The Compose file doesn’t declare any networks so all service containers will join the default network created for the app declared in the Compose file.</p>
<p>In the default network, the cache container can reach the web container by using web as the hostname for the container.</p>
<p>Similarly, web can reach cache by resolving the cache hostname. Because web is inside the network, it uses the container port of 6379 to connect.</p>
<p>From the Docker host machine, cache can be reached at the host port of 36379. What about web? How can the host reach web?</p>
<p>It cannot reach web, because no ports are published making it accessible to the host.</p>
<p>Besides the default network, you can declare custom networks under the root networks key. This gives you more control and allows you to create more complex network topologies. Custom networks can be external to the application, similar to external volumes worked. You add the external: true mapping to tell Compose to verify the network already exists and join services to that external network.</p>
<p>This example Compose file illustrates how custom networks are used. The file declares two networks under the top-level networks key beginning at line 18. The frontend network uses the default network configuration, while the backend network refers to an external network created outside of the Compose file. The networks mapping for each service shows the proxy and app service are part of the frontend network, and the app and db service are in the backend network. With this configuration, the db and proxy services are isolated from one another. This approach of limiting communication between services to allow only what is necessary is a best practice. The db service further configures the alias database for itself on the backend network. The app container could resolve the hostname db or database as a result of the alias. The mapping syntax must be used for specifying aliases.</p>
<p>Special Topics: Variable Substitution<br>I will finish of the lesson by discussing a couple special topics in Compose files, starting with variable substitution. Variable substitution allows you to generalize your Compose files to create different environments without having to modify the Compose file. Docker Compose will substitute shell environment variables in place of variable placeholders in a Compose file. You indicate a variable by using a dollar sign before the variable name, and optionally surrounding the variable name in braces. If the variable is not defined in the environment where Docker Compose is running, an empty string is substituted for the variable. The example on the bottom half of the slide shows a snippet of a Compose file that uses a variable named REDIS_TAG for the image tag. In the shell environment, the REDIS_TAG environment variable is set to 4.0.5. When Docker Compose creates the application, the environment variable is substituted into the image value string.</p>
<p>Special Topics: Extension Fields<br>The other special topic I wanted to mention is extension fields. Extension fields let you reuse configuration blocks and move important configuration fragments to the root of the Compose file. Extension fields only work with version 3.4 or higher Compose files, so you will need to include a minor version number to get this to work in version 3. To use extension fields, add a root key that begins with x- and add the configuration to reuse under it. To insert the configuration somewhere else in the file, you use YAML anchors. Anchors allow you to create an alias for the configuration that effectively inserts the configuration fragment wherever you reference the anchor. The example on the right shows how an extension field called x-logging is used for configuring logging in two services. The anchor is indicated with an ampersand and is named default-logging. In the service definitions, the asterisk precedes the anchor name to indicate that an anchor is being used as the logging value. The extension field mapping including both options and driver are inserted at the proper indentation level where the default-logging anchor is referenced with an asterisk. The example illustrates how extension fields are useful for removing configuration clones.</p>
<p>Recap<br>This lesson began with a crash course in YAML. You learned about the string, integer, null, and Boolean data types. You also learned about the two collections in YAML: mappings, and sequences. This was just enough YAML to understand and write Compose files.</p>
<p>Next you understood the anatomy of a Compose file. The configuration in compose files falls under the top-level mapping keys of version, services, volumes, and networks. The configuration for services, volumes, and networks are similar to parameters you pass for docker run, volume create, and network create commands, but formatted in YAML syntax.</p>
<p>We finished the lesson by covering a couple special topics in Compose files. Variable substitutions allow you to generalize a Compose file using environment variables. Extension fields let you reuse configuration fragments to cut down on clones.</p>
<p>Up until now, you’ve only seen how to declare what’s in your multi-container applications. In the next lesson, you will see how to use the docker-compose command-line interface to run and manage the applications. When you are ready to learn how to start running your Compose file applications, continue on to the next lesson.</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file">https://docs.docker.com/compose/compose-file</a></p>
<h1 id="Features-and-Commands-of-Compose-Command-Line-Interface"><a href="#Features-and-Commands-of-Compose-Command-Line-Interface" class="headerlink" title="Features and Commands of Compose Command-Line Interface"></a>Features and Commands of Compose Command-Line Interface</h1><p>In this lesson, we’ll see how to use the Docker Compose command-line interface to turn the multi-container applications described in Compose files into actual running environments in Docker.</p>
<p>Agenda<br>I’ll start by reviewing some of the high-level features of the Compose CLI.</p>
<p>Next, I will go through some of the installation options available for different platforms.</p>
<p>Lastly, I’ll finish the lesson by looking at how to use the docker-compose CLI by the reviewing common commands and parameters</p>
<p>Features<br>One of the features of the Compose CLI that I want to highlight is its ability to run multiple isolated environments on a single host. Some scenarios where this is extremely useful is on a continuous integration server where you need to run automated tests for each build version. The ability of Compose to run multiple isolated environments means you don’t have to sequentially iterate through each version. A development scenario where this comes in handy is when you may need to create multiple copies of an environment for different feature branches. You can use variable substitution in the Compose file to create the desired branch environment. We’ll talk more about development scenarios in later lessons in this course.</p>
<p>The Compose CLI uses a parallel execution model to perform tasks for creating and deleting an application environment. Not everything can run in parallel due to dependencies and limitations in Docker, but when possible parallel execution is used to reduce the time it takes to manage applications.</p>
<p>Another useful feature to be aware of is the change detection capabilities of Compose. Every time you start a container for a service in Compose, the configuration is cached. If you later restart a Compose application, Compose will reuse any <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">containers</a> that haven’t changed configuration. This is a bit like how layers are cached when building images from a Dockerfile. Just like with Dockerfiles, you can instruct Compose not to use the existing containers and instead force all containers to be rebuilt.</p>
<p>The last feature, using the term loosely, is that <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">Docker Compose</a> is an open-source project on Github with an active community. You can report issues and make feature requests there. If you are familiar with the Python programming language, you can fork the project and modify the source to better suit your needs. Maybe even make a pull request to have your improvements included into the project.</p>
<p>Installation<br>Before we get into using the Compose CLI, I want to say a few words about getting Compose installed on your system.</p>
<p>For mac users,<br>Compose comes installed with the Docker for Mac application and Docker Toolbox for older systems.</p>
<p>For Windows users,<br>If you obtained Docker through Docker for Windows, or Docker Toolbox<br>Compose came included with that.<br>If you are running the native Windows Docker Daemon, on Windows Server 2016 or Windows 10 with the Anniversary Update<br>You need to install Compose separately. You can choose the appropriate version of Compose and download an installer from the Compose Github releases page. For example, you could download version 1.17.0 to get the version of Compose I’m using for this course.</p>
<p>For Linux systems,<br>Docker Compose is included in many distribution repositories<br>For example, on CentOS or RedHat distributions you can use yum or dnf, and apt on Debian-based systems.<br>If Compose isn’t available through the distribution’s package repo or you want a specific version,<br>you can get Compose from the Github release page.</p>
<p>Usage<br>All right! With that out of the way, we can look at how to use the Compose CLI. I’ll show a couple slides to cover the Compose CLI basics and then hop over to my terminal to briefly illustrate using the Compose CLI.</p>
<p>docker-compose follows similar patterns to the docker CLI. You specify options to Compose, followed by a command, and add arguments for the command at the end. You can always use the –help argument to print a help page for any command.</p>
<p>Compose will use the Docker Daemon running on the host by default.</p>
<p>You can connect to a Docker Daemon running on a remote host using the -H option. Along with that, you can secure the connection to the remote host using transport level security options. This requires the remote host to have been configured to use tls for the Docker Daemon.</p>
<p>For commands that reference a Compose file, the default Compose files that the CLI tries to find in the current directory are named docker-compose.yml or docker-compose.yaml.</p>
<p>It can be restrictive using only the default Compose file, so the -f option is provided to allow you to specify a path to any file that you want Compose to use as the Compose file for a command.</p>
<p>Each isolated application is associated with a project in Compose. The project is given a name and that name appears in resources that get created by Compose. For example, the names of networks and containers created by Compose begin the project name followed by the arbitrary name key declared in the Compose file.</p>
<p>The default project name is the name of the directory containing the Compose file.</p>
<p>You can assign a custom project name by using the -p option.</p>
<p>Commands<br>As we have seen, Compose tries to make adoption easy for users already familiar with Docker. Most of the commands in the Compose CLI are familiar Docker commands that are generalized to work with multi-container applications.</p>
<p>This is the list of commands that exist in both Docker and Compose CLIs as of Compose version 1.17. As an example of how a command is generalized to multi-container applications, consider the stop command. In Docker, you use the stop command to stop one or more running containers passing the container names as arguments to the command. In Compose, the stop command will stop all containers declared in a Compose file, unless you provide the names of individual services to stop. Most commands generalize as you would expect. Some commands like config are not related to the Docker command. Config is useful for validating the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/anatomy-of-a-compose-file-1/">YAML</a> and configuration in a compose file. It’s important to note that you can still use the docker CLI to work with resources created by Docker Compose. For example, containers created by Compose are listed by docker ps since they are created by the Docker daemon. Compose is just wrapping commands to generalize them to how you would expect them to work with multi-container applications.</p>
<p>After removing the commands that exist in Docker, there are currently only two non-deprecated commands that are unique to Compose and they are big ones.</p>
<p>The first is up.</p>
<p>The up command performs the actions required to instantiate the application described in a Compose file. It starts by creating default and named networks as applicable, and any named volumes.</p>
<p>It then takes the actions required to bring up service containers. This includes building images if required, then creating and starting containers, and finally attaching to the containers to aggregate output and error streams from the containers. When the command exits, the containers are all stopped. However, you can use the -d option to let the containers run in detached mode.</p>
<p>The up command is also responsible for performing change detection when you bring up an application that has already been brought up. It will recreate containers with changed configuration and join them to the appropriate networks. Any connections that were established with the original container are closed. There are several options for configuring how Compose does this if the default behavior isn’t what you want.</p>
<p>The other command unique to Compose is down. Down is a partial opposite of up.</p>
<p>What I mean by partial opposite is that down will only remove containers, as well as any named and default networks by default.</p>
<p>It won’t delete volumes or images that up created, unless you pass arguments instructing the command to do so. Up and down make it easy to perform integration tests in a continuous integration pipeline. You can simply wrap a test script between up and down to have the tests run in the isolated environment. Ok, with that, we’ve covered enough of the Compose CLI to try it out and to use the help argument to find out more information when needed.</p>
<p>@Terminal docker-compose<br>Here we are at my terminal. I want to demonstrate using the Compose CLI just to give a first look at it. We will cover more in-depth examples showing Compose in action in the remaining lessons in this course.</p>
<p>To start with, you can always get the usage information by appending –help on any command or docker-compose itself. I’ll pipe it into more to page through the output. I won’t read through the output since we’ve discussed most of what is shown. The help output finishes with a list of all the available commands.</p>
<p>To get more information on the up command, I’ll enter docker-compose up –help. I’ll jump down to the options to see what’s available for configuring the behavior of the up command. Just as an example, –no-deps can be used to prevent starting dependent services. This doesn’t sound very useful when you first bring an application up, but if you later modify the configuration of one service, it can be useful to not restart the services that the one service depends on. As another example, adding the –remove-orphans option can clean up any services that are no longer declared in a compose file. This can happen if you delete a service outright from a Compose file or if you rename one.</p>
<p>To finish up, I’ll demonstrate how to use docker-compose’s config command to debug any YAML or configuration errors. You will also see how config shows you the effective configuration that is used by Compose after variable substitutions and extension field references.</p>
<p>If I switch over to VS Code, I have a Compose file open called 1-extension-fields.yml. It follows an example shown in the slides for using extension fields.</p>
<p>It’s using version 3.4 which is good because that’s the earliest version that supports extension fields. To see if everything is ok with the file, run the config command on it. At the terminal, I’ll use the -f option to specify that file as the Compose file to use. So, Compose reports an error about services.cache.command contains true which is not valid. If I jump back to Code, it seems strange at first because there is no instances of true in the file. But remember that multiple words get mapped to true in YAML. Yes is one of them. Code has even changed the color to indicate that it isn’t a string value. I’ll add quotes around it to correct the error.</p>
<p>Running config again reveals a different error. The cache service doesn’t set an image or build command so it can’t be created. I’ll set the image to redis, but I want to use variable substitution to set the tag, like so. Now when I run the config command again there are no errors and the effective configuration is displayed. Here you can see the default-logging YAML references have been replaced with the associated configuration under each services logging key. Compose reports a helpful warning at the top about the REDIS_VERSION variable not being set so an empty string is substituted. You can see that in the displayed configuration. That will need to be corrected. I’ll export the variable<br>Export REDIS_VERSION&#x3D;4.0.6<br>And the config command output confirms the variable is substituted into the configuration. I’ll leave it at that for now. We’ll see several more examples of Compose at the command-line in upcoming lessons.</p>
<p>Recap<br>This lesson started by outlining some of the features of the Compose CLI including, how it can create multiple isolated environments on the same host. This makes it appealing for continuous integration, testing, and development scenarios. It also has built-in Compose file change detection support to only do what is required to bring the application to the desired state described in a Compose file.</p>
<p>We saw that the docker-compose CLI follows the same pattern as the docker CLI. Most of the commands in docker-compose are analogous to ones you find in docker.</p>
<p>There are however, two important commands that are unique to compose. Up does everything required to bring an application described in a Compose file up, and down brings an application down, removing containers and networks, but leaving images and volumes untouched by default.</p>
<p>In the next lesson, we’ll go a step farther and bring up a web application with Compose using <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/run-a-web-app-1/">pre-built images from Docker Hub</a>. When you are ready to see more of Compose in action, continue on with the next lesson.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p>
<h1 id="Deploying-and-Configuring-a-Web-Application-with-Compose"><a href="#Deploying-and-Configuring-a-Web-Application-with-Compose" class="headerlink" title="Deploying and Configuring a Web Application with Compose"></a>Deploying and Configuring a Web Application with Compose</h1><p>Welcome back. This lesson will go through deploying a web application with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">Compose</a>. This lesson is more applied than the previous ones. We’ll spend most of our time at the command-line and making changes to a Compose file.</p>
<p>Agenda<br>I’ll start by briefly introducing the web application.</p>
<p>Then we’ll get right into the demo.</p>
<p>Wordpress<br>The web application that we’ll use is WordPress. WordPress is a popular content management system or CMS. You can create websites and blogs in WordPress. WordPress is written in PHP and uses MySQL as a database. The images for WordPress and MySQL are maintained by Docker. Both images have over 10 million pull on Docker Hub. This scenario relates to operating the application. This is where images have been created and you pull them from a registry, possibly Docker Hub, or your own corporate image registry. The following lesson gets into developing applications with Compose. Now the stage is set, so let’s hop over to Visual Studio Code to look at the Compose file I’ve prepped for the application.</p>
<p>@Terminal<br>Here is the Compose file, wordpress.yml. All of the contents just fit on the screen. Let’s take a moment to go through it since it ties together a lot of what we’ve seen in the course so far. There are two services, one for WordPress which is where the PHP application code exists and is served up by an apache web server, and one for the MySQL database. Both services use a specific tag on the image to have more control over the environment and to prevent unexpected changes from creeping in. Both services also have a restart key with the value of always. This is the same as the restart option for docker run. To make the application more production-worthy it’s a good idea to have the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">container</a> restarted automatically if it exits for some reason. You definitely want to persist data for a CMS, so the database service is using a named volume called db_data. This mounts into &#x2F;var&#x2F;lib&#x2F;mysql in the container and is where MySQL stores its database files. Each service has a set of environment variables configured. The db service uses a mapping for its environment variables to create users and a database called wordpress. The wordpress service uses a sequence of strings to configure the database user and host with equal signs separating the variable names from their values. Both syntax styles are allowed and equivalent. One variable to highlight is WORDPRESS_DB_HOST in the wordpress service. It configures the database hostname. The value that is assigned is db on port 3306, the default port for MySQL. There are no named networks in this file. How can the wordpress service connect to the db? Both services will be added to the default network that Compose will create. The last bit of configuration, is the publishing of the wordpress port. The app will be available on port 8000 on the Docker host. The string is enclosed in quotes as a best practice although not strictly necessary in this case because the container port, 80, wouldn’t mistakenly be interpreted as a base-60 number.</p>
<p>Switching over to my terminal, I’m in the webapp directory which contains the wordpress.yml compose file. I’m starting with a clean Docker environment. No containers, no volumes, and only the default Docker networks. I’ll bring the wordpress application up now, using the -f option to specify a custom compose file. The db’s mysql image gets pulled first followed by the wordpress image. I’ll speed this up while the image layers get pulled. Now you can see in the output that the container for the db service is created first followed by the container for the wordpress service. This is guaranteed because the db is in the wordpress services depends_on sequence. The webapp at the beginning of the container name is the project name and it defaults to the current directory name which is webapp. The up command then attaches to the containers and aggregates their output. Compose uses color to distinguish between the output from different containers. You can see WordPress attempting to connect to the database and failing. Recall that depends_on doesn’t wait until the database is ready, it only sequences the order containers are started in. Fortunately, WordPress follows the best practice of having the application handling failed connections and retrying until a connection is made. At this point, the db and wordpress services have finished initializing. I’ll stop the docker-compose command with ctrl+z instead of exiting with ctrl+c so the containers don’t get stopped. After clearing the screen, I’ll list the containers with docker ps and confirm that the containers made by compose are like any others. Checking on the volumes, we can see the db_data named volume created by Compose. The unnamed volume comes from the WordPress image. It declares a volume for the WordPress web assets that get served up by the Apache web server in the &#x2F;var&#x2F;www&#x2F;html directory. Next, we can see the default network Compose created in the networks list.</p>
<p>To verify the application is functioning correctly, I’ll jump over to a browser and navigate to port 8000 on localhost where the WordPress service published its web server container port. The first time you use wordpress, you need to configure the language, a site title, and some user information. I’ll set the title to Composing. The other details aren’t important. With those details set, I can log in and see the admin dashboard. Up in the upper right corner I can navigate to the public site that’s hosted by default. Here it is with the Composing title that I specified earlier. Everything is working as expected. We successfully ran a web application in Compose!</p>
<p>Let’s see how the Compose change detection works. Say we decide to accept the risks of using the latest tag for the wordpress image. I’ll change the tag, save the file, and go back to the terminal.</p>
<p>I’ll repeat the up command except using the -d argument to run the containers in detached mode so the shell prompt will be returned to me after the command finishes. It starts by pulling down the latest version of the wordpress image. After that, it checks and sees that the db service container already running matches the configuration in the Compose file. There is no need to restart it. It then detects that the wordpress container doesn’t match the configuration in the Compose file and recreates it using the updated configuration. You can change the behavior of up to suit your needs in different scenarios though. If you were uncertain if any other services had changed configuration and wanted to avoid recreating the db container at all costs, you can specify the –no-deps argument to up along with the service you want to bring up. In the output, notice that no check of the db service is made. If you want to recreate all containers even if their Compose configuration hasn’t changed, you can pass the –force-recreate argument. The output indicates each container is being recreated now. To be certain, check the output of docker ps and see the containers have just been created. Now I will demonstrate bringing the application down with the down command. The output describes the steps Compose is taking, stopping containers, then removing containers, and lastly the default network Compose created. Docker ps -a verifies there is no trace of any service containers. I can bring the application back up again very quickly having previously downloaded the images. Now, if I load WordPress in the browser, what do you think I will see?</p>
<p>We don’t see the first-time configuration page, we see the same composing site as before. That’s because docker-compose down leaves the volumes by default.</p>
<p>You can change that default behavior though. Add –rmi all to remove all the images used in the Compose file, –volumes to delete the named volumes declared in the Compose file as well as well as any anonymous volumes attached to service containers, and –remove-orphans to delete any project containers that are no longer defined in the Compose file. This time you can see the removal of volumes and images in the output. There is still the old 4.9.0 wordpress image kicking around however. I’ll use the image prune command to remove any images that are left over.</p>
<p>Closing<br>That was pretty awesome! Managing the multi-container web app with Compose was painless. In the next lesson, we’ll see how Compose works when we need to build the images using Dockerfiles.</p>
<h1 id="Using-Compose-Configurations-and-Commands-to-Build-Images"><a href="#Using-Compose-Configurations-and-Commands-to-Build-Images" class="headerlink" title="Using Compose Configurations and Commands to Build Images"></a>Using Compose Configurations and Commands to Build Images</h1><p>Up until now, we have seen <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">Compose</a> working with images pulled from a Docker registry. Can you use Compose in development scenarios when the code isn’t ready to be sealed in an image? How do you build images with Compose? These are the questions I’ll answer in this lesson.</p>
<p>Agenda<br>I’ll begin by getting into the Compose file configuration and Compose commands needed for building images.</p>
<p>With that foundation in place, I’ll finish the lesson with a demo that illustrates how to use Compose to build an image in a development scenario. Compose will bring the application up and your code changes will be reflected in the running <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/containers/">container</a> without needing to rebuild or stop the container. This provides a similar experience to developing on your local machine without Docker, but the server and all of the application dependencies are running inside a container.</p>
<p>Building in Compose<br>When you build images in Compose, you make use of the same tried and true Dockerfiles that you use when building images with the docker build command. We won’t get into the details of Dockerfiles in this lesson, but I’ll quickly review one in the demo.</p>
<p>To instruct compose to build an image, add the build key in a service’s configuration. There can be more than one service in a Compose file with a build mapping.</p>
<p>The Docker-compose up and docker-compose build commands can be used to build images. We’ll take a closer at the build key and these commands in the next few slides.</p>
<p>Build Key<br>If a service has a build key present, Docker Compose will build the image for the service. There are two forms of build configurations in a Compose file. The short form sets the build value to the path of the build context which is where the Dockerfile is located.</p>
<p>The longer form uses a nested mapping. The context is a required key and it has the same meaning as the context for the short form. The Dockerfile key is optional. If specified, the value is the name of the Dockerfile to use. If it isn’t specified, Dockerfile will be used as the name for the file containing the image build instructions. Args are optional as well, and can be used to pass Arg values at build time. The Dockerfile should have corresponding ARG instructions.</p>
<p>The built image will be given a name that follows the pattern of Compose project name followed by the service name. If you want to use a different name, or want to specify a tag for the built image, beside the default latest tag, you can do so by using the image key. The image specified the image to pull from a Docker registry before, but if a build configuration is present for a service, the image is interpreted as the name of the built image.</p>
<p>Docker-compose up will build any image for services that don’t have one already built. Subsequent up commands won’t rebuild the image, unless you pass the –build option. This might not give enough control over built images, so there is another command for building.</p>
<p>Docker-compose build will build images or rebuild them if they already exist. Just like with the docker build command, there are a couple options to customize the behavior of docker-compose build. The –no-cache option will prevent using the layer cache causing all layers to be rebuilt. The –pull option will always attempt to pull a newer version of a base image described in the Dockerfile. That’s all there is to building in Compose.</p>
<p>Demo<br>Now, we’ll get into a demo to illustrate building in Compose. The demo will use a NodeJS project that uses MongoDB for persistence. The image shows the app. It simply accumulates whatever messages users enter. The goal of the demo is to build an image with Compose that will allow on the fly updates as you modify the source code. No rebuilds and no stopping the containers. This gives the instant feedback that developers crave. Let’s see how to do that.</p>
<p>Here in VS Code, I have a Dockerfile for the project open. It’s called dev.dockerfile. I’ll try to stay as language-agnostic as possible but the specific RUN instructions are specific to NodeJS development. At a high level, the instructions install the dependencies for developing and running the application. On line 5, nodemon is installed. nodemon is a tool that watches for changes to development files and automatically restarts the server to reflect the changes. On line 17, nodemon is set as the default command for running a container using the image. On lines 8 through 11, the src directory is created and set as the working directory. Then the application dependencies file, package.json, is added to the src directory in the image. The npm install command installs all of the dependencies in the src directory. Note that only the dependency file is added and not any source files. The image has everything the code needs to run but not the code itself. The development server port of 3000 is exposed on line 14. So how will this image be used to develop the code? The default command is expecting a file at &#x2F;src&#x2F;app&#x2F;bin&#x2F;www to start the server but it doesn’t exist in the image. How will that work? The answer to both questions is by mounting a volume. Specifically, the source will be mounted at &#x2F;src&#x2F;app. The default command will then start a server using the code in your development environment. Let’s take a look at the Compose file, that I’ve called dev.docker-compose.yml.</p>
<p>There are two services, app and app-db, that are in the backend network. App publishes the port of 3000 so that the host can access the development server. There are a couple environment variables to configure NodeJS for development and to pass the hostname of the database. What’s most important for this lesson is the build configuration. Because the dockerfile doesn’t have the default name, the mapping syntax is required. The context is ., representing the directory of the Compose file which is also where the dockerfile is. The volumes key also plays an important role. The src directory on the host is mounted at &#x2F;src&#x2F;app where the development server expects to find it. Let’s bring up the application using the Compose CLI. Thanks to the image configuration mapping, the built image will be named accumulator and will receive the default tag of latest.</p>
<p>I’ll use the up command which builds the image since there is no prior image to use. I’ll skip ahead to the build part. Each of the instructions in the Dockerfile are executed just like with docker build. I’ll jump ahead to when the image is ready. There are some harmless warnings because some optional dependencies are specific to macs but the image is Linux. The output reports that the accumulator:latest tag is used. Compose also gives a helpful warning telling you to use the build command or pass the –build option to rebuild the image. Let’s verify the app is up and running.</p>
<p>I’ll point my browser to localhost on port 3000 and voila, the accumulator app is up and running. I’ll enter some messages and refresh the page to ensure they are persisted in the database. Everything looks to be working.</p>
<p>I’ll hop back to VS Code, and edit one of the views by adding a colon after Enter messages to accumulate, to confirm that the change gets updated in the browser. I’ll save that change, and refresh the browser.</p>
<p>And there is the colon. That change was to a file that doesn’t require restarting the server. To confirm that nodemon is correctly watching for changes, I’ll modify a server-side JavaScript file.</p>
<p>I’ll add some exclamation marks at the end of the development environment notice that appears in the upper right corner. Going back to the browser and refreshing</p>
<p>We see the changes reflected. No stopping the container and no build command required.</p>
<p>To show that nodemon detected the change, let’s look at the app service’s logs. There it is in green, restarting due to changes. That’s pretty cool. You can use the development image to bundle up all the dependencies and all you need on your machine is the source files. You don’t need the dependencies installed locally. By relying on the image for dependencies, you are a step closer to having parity between development and production because the production image would be using the same dependencies. The chance of the code working on your machine but not in production is greatly reduced. We’ll look more at dev-prod parity in the next lesson.</p>
<p>I’ll take the application down now. And if I bring it back up, do you think the test messages I entered into the application will still be there?</p>
<p>Let’s refresh the page and see. In this case, the messages are gone. Recall that the db image isn’t using a volume, so once the container is removed, everything is gone. That give an easy way to start fresh when developing this app, but you could easily add a volume if you wanted to persist the messages.</p>
<p>Recap<br>This lesson illustrated how to build images and develop with Compose. The next lesson will further build upon what we’ve learned in this Lesson to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/extending-compose-1/">adapt Compose to multiple environments</a> so you can share common configuration between development and production. When you are ready, continue on to the next lesson to see how it’s done.</p>
<h1 id="How-Compose-Handles-and-Combines-Multiple-Files"><a href="#How-Compose-Handles-and-Combines-Multiple-Files" class="headerlink" title="How Compose Handles and Combines Multiple Files"></a>How Compose Handles and Combines Multiple Files</h1><p>We saw how to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/building-in-compose-1/">use Compose to build an image</a> in a development scenario where the code is not ready to be sealed into the image. But what about once the code is ready? How can you use Compose to make the production image? Do you need to use two independent Compose files and Dockerfiles? This lesson will clear up these questions.</p>
<p>Agenda<br>I’ll start with a discussion of how Compose handles multiple Compose files.</p>
<p>Then I’ll mention a few considerations for using Compose for production environments.</p>
<p>I’ll finish by reviewing the concepts we discuss in a demo. The demo extends the app from the previous lesson to use Compose for development and production environments.</p>
<p>Multiple Compose Files<br>Although it’s an option to maintain completely separate compose files for each environment you maintain,</p>
<p>Compose has a useful feature that can combine Compose files.</p>
<p>The semantics of combining Compose files is to treat the first file as a base configuration and each additional file overrides configuration specified in the base configuration. The overrides can add configuration that isn’t present in the base configuration as well, not only strictly overriding existing values in the base configuration.</p>
<p>By default, Compose is set up to read two Compose files, the familiar docker-compose file, as well as an optional override file called docker-compose.override.yml.</p>
<p>The -f Compose option can be used multiple times to specify non-default override files. Each override file overriding the previous ones.</p>
<p>The Docker Compose config command is useful when writing and debugging multiple Compose files. It will display the effective Compose file after everything is combined.</p>
<p>The -H option of Compose allows you to manage the application on different Docker hosts, since the different environments are probably on different machines.</p>
<p>Multiple Compose Files Example<br>Let’s consider an example that uses Compose in two environments, one that is not intended for development, and another that is for development. The Dockerfile for the application is shown here. It’s follows the non-development image pattern of copying all of the source code into the image, and installing the dependencies. Note that the source files are in the &#x2F;src directory.</p>
<p>Here is the docker-compose.yml file, which plays the role of the base configuration in our example. <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">Compose</a> is instructed to build the web image using the current directory as the context, along with publishing a port on the host, and running a redis container. During the build the source files in the current directory get added to the image. The image can then create containers that don’t have any dependency on source files outside of the container. This is what you want in a non-development scenario. Let’s see how an override Compose file can extend the application to work in development scenarios. Can you guess?</p>
<p>On the right, I’ve shown a development override Compose file. To use source files on your local machine instead of inside the image, you can use a volume. The example mounts the current directory at &#x2F;src in the container. Because of the way that layering works in images, the files that are in the container are effectively overwritten by the volume. With this override, you can modify the source files on your local machine and see the changes reflected in a running container. It isn’t always possible to use a common Dockerfile for each environment you intend to use the container. In that case, you can override the Dockerfile for each environment using the build’s dockerfile configuration in each Compose file.</p>
<p>Production Considerations<br>Moving to production environments is worthy of a course of its own. I will mention a few Compose file considerations for moving to a production environment, but know that there is more to it.</p>
<p>Remove any volumes for source code. You want the code to be frozen inside of a production image.</p>
<p>Consider using the always restart policy so services will automatically bring themselves back up if they exit.</p>
<p>Avoid host port conflicts that can prevent an application from coming up by letting Docker choose the host ports to use. You do this by only specifying the container port in the ports sequence.</p>
<p>Usually the runtime and the application have environment variables to configure production mode. This may reduce verbosity of logs and disable debug information.</p>
<p>The last one that I’ll mention, is consider additional services that may be useful in production. For example, monitoring and log aggregation services. Now let’s wrap up with a demo illustrating some of the concepts of using multiple compose files for development and production environments.</p>
<p>Demo<br>I have a project open that is similar to the example in the previous lesson, except I’ve modified it to use multiple Compose files. The development Dockerfile is the same as before. This is the file, dev.dockerfile, to refresh your memory. Because the application uses different ports and default commands for development and production, I’ve written a separate production Dockerfile.</p>
<p>This is it here, prod.dockerfile. It doesn’t install any development dependencies like nodemon and it copies all of the source files into the image, not just the dependency file. The exposed port has changed from 3000 to 8080 as well.</p>
<p>Now let’s get to the main subject, the Compose files. This is the base Compose file, docker-compose.yml, that has configuration that is common to both environments. Then each environment has its own override file to add its own unique configuration. Alternatively, you could use the base configuration for the production environment, and have a single override file for development that not only adds but actually overrides settings in the base configuration. The configuration in this file is similar to the Compose file in the previous lesson’s demo with the development specific configuration removed. One change is that the image has been given a registry URL. This allows you to later use docker-compose push to push the production image to a corporate registry, for example.</p>
<p>Looking at the development override Compose file now. This is the development specific configuration extracted from the single configuration in the previous lesson. When you tell Compose to use the base configuration plus this configuration as an override, it effectively reproduces the single development environment Compose file in the previous lesson. We’ll actually see how they combine with the docker-compose config command in awhile.</p>
<p>And over to the final file we’ll look at, the production override Compose file. I’ve use the name prod but the image could and probably should be used for automated testing in a continuous integration system and&#x2F;or staging before going into production. First, note the build configuration is set to use the prod dockerfile. We can also see several of the production considerations manifested in this override file. There is no volume for the app, both services are configured with the always restart policy, no specific host port is set to avoid port conflicts, and a production environment variable is set to configure the application for production. The last override is that the database is set to use a named volume to persist its data. In development it was considered optional, but we definitely want a volume in the production environment. Now let’s take a look at how to use multiple Compose files on the command-line.</p>
<p>I’ll focus on using the config command to show the effective configurations when you specify override files. I’ll start by validating the configuration for the development environment. The command just adds an extra -f for the development override file. The output shows the combined configuration that Docker Compose will use. The output of config is more explicit than what was in the Compose files, in terms of using absolute paths and not having implicit null values. But we can clearly see that both configuration’s options are there. For example, the base configuration’s image and the development override’s source code volume. I’ll clear that and have one more go at it, this time specifying the production override file. And here we can see the effective configuration for the production environment. For example, the always restart policy on both services.</p>
<p>Closing<br>In this Lesson, you saw how multiple Compose files and Docker Compose’s override feature makes it easy to manage your multi-container applications in multiple environments. We also discussed some considerations for when one of those environments is production. When you are ready, continue on to the next <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/summary-6/">lesson</a> where we’ll wrap up the course.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Congratulations! You made it to the end of the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/course-introduction-18/">course</a>. I hope you enjoyed the course and learned a lot along the way. Let’s talk a walk down memory lane together.</p>
<p>Course Review<br>We began the course by introducing the problems that Compose aims to solve. Namely, simplifying the process of managing multi-container applications in Docker. Then we dove in to study the anatomy of Compose files. We covered a relatively small but powerful subset of YAML that I said was enough to understand all the examples in the course. Looking back, it was enough wasn’t it. I think you’ll find that it’s enough to understand almost any Compose file you come across. The YAML mapping used to declare multi-container applications in a Compose file has four top-level keys: version, services, volumes, and networks. We went into the details of each and drew upon experience with Docker commands to make it easier to write our own Compose files. We then covered the other part of Compose, the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-applications-with-docker-compose/docker-compose-cli-1/">Compose CLI</a>. In addition to many familiar commands that are generalized to work with multi-container applications, Compose introduces two new commands: up and down. We then demonstrated how to use Compose to manage WordPress, a popular content management system. The lessons learned applied to managing applications made up of pre-built images. We then looked at using Compose in development scenarios when you need to build the image yourself and still be able to modify the source code. This is possible with the build configuration that works with plain old Dockerfiles and strategically mounting volumes. Lastly, we saw how Compose can be used to manage applications that target multiple environments, such as development and production. Compose override files make it possible to do without duplicating common configuration shared between environments.</p>
<p>Learning Outcomes<br>By taking this course, you have achieved the following learning outcomes:<br>• Understand the anatomy of Docker Compose files<br>• Configure your application using Docker Compose files<br>• Use the Docker Compose CLI to manage the entire lifecycle of applications<br>• Build your own images from source code with Docker Compose<br>• Be able to extend Docker Compose files to adapt to multiple environments</p>
<p>Learning More<br>There are a few places I’d recommend for learning more. Try out some of the labs, quizzes or other courses on Cloud Academy. There is content on Compose as well as Docker swarm mode which lets you run multi-container applications on a cluster of computers instead of a single host.<br><a target="_blank" rel="noopener" href="https://cloudacademy.com/">https://cloudacademy.com</a></p>
<p>The Docker Compose docs are a great place to learn all the intricacies of Compose and to stay on top of release changes.<br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<p>The Docker Compose GitHub repository is also a good place to learn about what’s coming next for Compose and learn from discussions around reported issues. Of course, you can file your own issues and even contribute to the code base.<br><a target="_blank" rel="noopener" href="https://github.com/docker/compose">https://github.com/docker/compose</a></p>
<p>The broader GitHub community can also be a great place to learn more about using Compose. There are around a quarter of a million Compose files using the default docker-compose.yml or .yaml name on GitHub.<br><a target="_blank" rel="noopener" href="https://github.com/search?q=filename:docker-compose.yml+filename:docker-compose.yaml&amp;type=Code">https://github.com/search?q=filename:docker-compose.yml+filename:docker-compose.yaml&amp;type=Code</a></p>
<p>Feedback<br>I’m happy to hear from you. I make content for you. If you have any feedback, please get in touch with me by leaving a comment on the Comments tab below the video, by emailing <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>, or by connecting with me on Twitter where my handle is @LoganRakai.</p>
<p>Thank you<br>That’s all for this course on managing applications with Docker Compose. I want to end by thanking you for going through the course with me. It’s been a blast! Now go on and put what you’ve learned here into action. Until next time, I’m Logan Rakai with Cloud Academy.</p>
<h1 id="1Course-Introduction"><a href="#1Course-Introduction" class="headerlink" title="1Course Introduction"></a>1<strong>Course Introduction</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/cloudacademy/docker-compose-training">Course Github Repo</a></p>
<h1 id="8Summary"><a href="#8Summary" class="headerlink" title="8Summary"></a>8<strong>Summary</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">Docker Compose docs</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/compose">Docker Compose GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/search?q=filename:docker-compose.yml+filename:docker-compose.yaml&type=Code">Docker Compose YAML files</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/Docker-Certified-Associate-Docker-Swarm-Playground-7/" rel="prev" title="Docker-Certified-Associate-Docker-Swarm-Playground-7">
      <i class="fa fa-chevron-left"></i> Docker-Certified-Associate-Docker-Swarm-Playground-7
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/Docker-Certified-Associate-Software-Development-Testing-and-Delivery-with-Docker-9/" rel="next" title="Docker-Certified-Associate-Software-Development-Testing-and-Delivery-with-Docker-9">
      Docker-Certified-Associate-Software-Development-Testing-and-Delivery-with-Docker-9 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker-Compose-Overview"><span class="nav-number">2.</span> <span class="nav-text">Docker Compose Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-Create-Docker-Compose-Files-Using-YAML"><span class="nav-number">3.</span> <span class="nav-text">How to Create Docker Compose Files Using YAML</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Features-and-Commands-of-Compose-Command-Line-Interface"><span class="nav-number">4.</span> <span class="nav-text">Features and Commands of Compose Command-Line Interface</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Deploying-and-Configuring-a-Web-Application-with-Compose"><span class="nav-number">5.</span> <span class="nav-text">Deploying and Configuring a Web Application with Compose</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Using-Compose-Configurations-and-Commands-to-Build-Images"><span class="nav-number">6.</span> <span class="nav-text">Using Compose Configurations and Commands to Build Images</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-Compose-Handles-and-Combines-Multiple-Files"><span class="nav-number">7.</span> <span class="nav-text">How Compose Handles and Combines Multiple Files</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Summary"><span class="nav-number">8.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1Course-Introduction"><span class="nav-number">9.</span> <span class="nav-text">1Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8Summary"><span class="nav-number">10.</span> <span class="nav-text">8Summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
