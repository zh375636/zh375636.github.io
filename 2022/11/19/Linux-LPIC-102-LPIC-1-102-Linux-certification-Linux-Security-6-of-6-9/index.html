<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroThis is the final course in Cloud Academy’s 11-part series preparing you for the LPIC1, Linux Server Professional 101 and 102 exams. With this course, you’ll hopefully have everything you need">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-LPIC-102-LPIC-1-102-Linux-certification---Linux-Security-6-of-6-9">
<meta property="og:url" content="https://example.com/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Security-6-of-6-9/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroThis is the final course in Cloud Academy’s 11-part series preparing you for the LPIC1, Linux Server Professional 101 and 102 exams. With this course, you’ll hopefully have everything you need">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T05:11:53.000Z">
<meta property="article:modified_time" content="2022-11-21T01:30:44.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Security-6-of-6-9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux-LPIC-102-LPIC-1-102-Linux-certification---Linux-Security-6-of-6-9 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Security-6-of-6-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-LPIC-102-LPIC-1-102-Linux-certification---Linux-Security-6-of-6-9
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 01:11:53" itemprop="dateCreated datePublished" datetime="2022-11-19T01:11:53-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 21:30:44" itemprop="dateModified" datetime="2022-11-20T21:30:44-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LPIC-1-102/" itemprop="url" rel="index"><span itemprop="name">LPIC-1-102</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Security-6-of-6-9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Security-6-of-6-9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>This is the final course in Cloud Academy’s 11-part series preparing you for the LPIC1, Linux Server Professional 101 and 102 exams.</p>
<p>With this course, you’ll hopefully have everything you need to fly through the exams. But more importantly, to more productively and more profitably make use of the many opportunities Linux provides.</p>
<p>This course will focus on security. There’s more than one way to secure your servers and their data.</p>
<p>You can look at it from the perspective of user access, network connectivity, and both file and connection encryption.</p>
<p>We’ll learn about securing your local system resources against misuse, maintaining safe and secure network connections, using OpenSSH to encrypt, and thereby secure your remote terminal sessions, and about encrypting individual files so they can be safely sent across insecure channels.</p>
<h1 id="System-Security"><a href="#System-Security" class="headerlink" title="System Security"></a>System Security</h1><p>To keep the servers and PCs under your care secure, you will have to have control over the users who login both locally and remotely. You will also need to find ways to intelligently monitor the system processes themselves so you can spot strange activities and dig deeper. We’re going to discuss some of the tools available to Linux SysAdmins. It’s possible, by the way, that some of these tools aren’t installed by default on your system, but apt-get or yum can quickly fix that. If you’re not sure where to find a package, on a Debian-based system including Ubuntu, you can use apt-cache search and then the name of the program you’re after. In this case, we can see the netstat is part of the net-tools package. One of the simplest things you can do to prevent unauthorized control over your servers is to limit who gets administrative rights and when.</p>
<p>Your first job, therefore, is to make sure that users who don’t need admin rights don’t get them. To protect against legitimate admin users carelessly leaving their root sessions unwatched, discourage your admin users from using root sessions via sudo su.</p>
<p>Instead, they should use sudo. Sudo invokes root powers, but only for that particular command. Once the command is done, the shell session returns to non-admin permissions. This makes it much less likely that some kind of account hijacking will cause all that much damage.</p>
<p>As we previously seen, users can use sudo to invoke root if they’ve been added to the sudo group in etc&#x2F;group, or in some Linux distributions, to the wheel group.</p>
<p>Behavior of the sudo group is controlled through the etc&#x2F;sudoers file, which by the way, requires sudo just to view. Note the user privilege specification line, which in my case gives full root authority to members of the sudo group. As you can see, sudoers should never be edited directly, but through the visudo command.</p>
<p>You can add or remove a user from the sudo group either by editing the etc&#x2F;group file or by using usermod. The -a -G will add Steve to the group called sudo.</p>
<p>It’s no secret that passwords are among the weakest links in the security chain. Most people choose short passwords that are easy to remember, and then use them over long periods of time for multiple accounts, which is exactly what makes them the easiest to guess or crack. And the more accounts people have, the more likely it is that they’ll compensate with even fewer and weaker passwords.</p>
<p>We simple system administrators can’t be expected to solve all the world’s problems, but we can use Linux tools to enforce some password standards.</p>
<p>Although this isn’t an LPIC exam requirement, you should at least be aware of packages like PAM or APG that force users to use longer and more complex passwords. What is part of the LPIC exam is chage, which stands for change age.</p>
<p>We’ve seen this in a previous video, but let’s have a quick review. We’ll run chage against my own user Ubuntu. We’re shown the last time I changed my password, expiry settings and minimum and maximum days between password changes. Meaning that as an admin, I can force the Ubuntu user, who happens to be me in this case, to change the login password every X number of days.</p>
<p>You set the maximum with the uppercase M, and the number of days you’d like to force the new password; 30 in our case.</p>
<p>Let’s review. Sudo, which invokes root powers only for a single command, is far preferred over starting a root shell using sudo su.</p>
<p>Sudo can be used by members of the sudo or Wheel group which is controlled by the etc&#x2F;sudoers file. You use usermod to add sudo to the sudo group.</p>
<p>Chage can be used to force users to regularly change their passwords. Besides controlling system access, you should also regularly monitor the system itself for unusual and suspicious behavior. For the remainder of this lecture, we’re going to explore some tools and techniques for doing that.</p>
<p>However, it’s unreasonable to think that you’re actually going to do all these things regularly enough to make them useful. It’d be much more realistic to include them in scripts run automatically by cron that will issue notifications of anomalies.</p>
<p>At any rate, here’s how you can effectively monitor your servers. As we discussed way back in the Linux partitions and filesystems course, you can, if necessary, provide non-root users full access to system binaries, even to binaries that will act with root privileges through SUID and SGID.</p>
<p>This way, for instance, as we’ve explained, regular users will change their passwords using usr&#x2F;bin&#x2F;passwd even though passwd works by updating the etc&#x2F;shadow file which belongs to root.</p>
<p>We can see this by looking at the passwd file in the usr&#x2F;bin directory. Notice the S in the first set of permissions, signifying that the SUID bit is set. We could remove the bit using chmod -s, but then you’d need to be root in order to update your password.</p>
<p>As you can probably guess, chmod +s will add the SUID bit. Using the SGID bit, you can do the same thing for binary files group permissions. Now all this is very nice, I hear you saying.</p>
<p>But what does it have to do with system security? Good question. The point is that while SUID and SGID bits are really useful, they’re are also a huge security hole, since any user can exploit them to effectively get full root access. If you want to maintain control of these permissions, you should regularly audit your system to make sure that there aren’t any files that through accident or malice have been left improperly open.</p>
<p>You can do this using find. A slash followed by -type f tells find to search for and list files in every directory below root whose user permissions include the SUID bit.</p>
<p>We could run the same command using -G to search for SGID bits. Now you can look through the output to see if there’s anything there that shouldn’t be.</p>
<p>Alternatively, you can create a script that checks the output of find against the files you know should be there, and then sends an alert if there is anything new.</p>
<p>You should also be able to keep track of processes running on your system to make sure nothing is being used without proper authorization. PS as we’ve seen, will list all running processes, and grep can help you find specific entries from out of the long list. But you might need to narrow down your search based on more specific rules. Fuser, which stands for file user, will return all processes running within a specified directory. In this case, we can see all the process IDs currently running within the root hierarchy. You will want to run fuser as sudo to make sure you’re accessing all system processes. For more information like the process user and the command, run fuser with the verbose argument. You can restrict your output to a specific executable like the Apache 2 Web server in this case. Or if you suspect that someone might be accessing a particular port without authorization, you can run fuser with -n specifying the TCP protocol and the HTTP port 80. In addition to netstat, which we discussed in the previous course, you can learn a great deal about the state of your network facing server using nmap. We’ll run nmap against the LXC container I’m on right now.</p>
<p>We can see that port 22 is open for SSH, port 25 for outgoing mail, and 80 because I have the Apache Web Server installed and working.</p>
<p>All that is what I would’ve expected taking into account the various ways I’ve been using this container. If there is anything I didn’t recognize, I would naturally want to investigate. By default, nmap looks for TCP activity. If I wanted to scan for processes using the UDP protocol, I would add -sU as an argument.</p>
<p>Note how UDP searches require sudo authority. It’s also important to keep track of who is logged onto your system.</p>
<p>Since Linux is by design built for multiple users, you can have all kinds of users logged in from remote locations without you even being aware of it. You’ll really want to keep an eye on login activity to make sure that there’s no one sneaking in behind your back. Linux has a few very similar tools that can do this, each with a subtle angle all its own. Last will print the login times of all users since the beginning of the month.</p>
<p>By default, it uses data from the file var&#x2F;log&#x2F;wtmp. Besides the Ubuntu user and root, we can see that Steve is logged in too. W will display a list of all users logged in along with information on their current activity. Who will also print the names of logged in users. When used with -b, it will also display the time of the last system boot. Now that we know whose accounts are logged into our system, and that Steve is one of them, we might like to find out what he’s been up to.</p>
<p>Since just about everything that happens in Linux is built on files, searching for files that are open and associated with a particular user can tell us a great deal.</p>
<p>Lsof which stands for list open files can do just that. A quick look through the data we get back shows that these are all normal processes associated with any normal SSH session. But if there was something funny going on, it wouldn’t be too hard to spot.</p>
<p>Let’s review. You can search for files with the SUID or SGID bit set using find. Fuser will print all processes running within a specified directory or file, or using a particular port. Netstat and nmap will both scan network addresses for open ports. Last, w and who will all display user login data. Lsof can tell us which files are currently open and who is using them.</p>
<h1 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h1><p>The previous video focused on system security, that is, maintaining the integrity of locally-running processes and resources. This lecture is about protecting your system from network-based threats. With that in mind, you might wonder why we’re going to start by talking about passwords and the files used to store them, when it would seem to be something we should already have discussed. I believe the LPI placed password files together with network security because securing key system data, like passwords, is an important part of maintaining control over network access.</p>
<p>How? Because, if a hacker manages to break into your system for various reasons, he’s more likely to do it as a regular non-admin user. But if he can easily access a file containing user passwords, even if they’re encrypted, then he’s a step closer to getting the keys to the castle. And it’s for that reason that many Linux distributions stopped keeping encrypted passwords in the &#x2F;etc&#x2F;passwd file. Let’s take a look. Notice first of all, that we can view the file without sudo, which is what makes it so vulnerable. Now take look at how the data is arranged. Each field is separated by a colon. The first field is the Username, Steve, in this case. The second field is just an X. Once upon a time, this would’ve been the encrypted version of Steve’s password. But that’s now been moved somewhere else, which we’ll get to in a minute. While we’re here however, we might as well explain some of the other fields.</p>
<p>The User ID and Group ID come next, followed by Steve’s Home directory, and finally, his default shell. So, where have all the passwords gone? If you can still log into the system, they’ve got to be somewhere. The answer is, they are now usually kept in &#x2F;etc&#x2F;shadow file. Note that we can’t read the file without sudo.</p>
<p>That, obviously, is to protect the contents from non-admin users. But with sudo, we’ve got full access. Now we can see the encrypted version of Steve’s password. With enough time and compute power, it might be possible to decrypt the string, but it’s not a trivial matter. And the fact that everything is here in the shadow file protected by admin permissions, makes it just that much more secure. If your system ever becomes vulnerable or unstable and requires emergency care, and you can bet that at some point it certainly will, you can easily shut down access to everyone but the root user by creating an empty file in the &#x2F;etc directory with the name nologin.</p>
<p>As long as this file exists, users won’t be able to login to new sessions. You should be careful with this. If you create the nologin file, then logout yourself, since you’re not the root user, even if you’re part of the sudo group, Linux won’t let you log back in. You may find yourself having to mount your filesystem from a different machine and removing the nologin file manually. Let’s review. Encrypted records of user passwords are usually kept in the &#x2F;etc&#x2F;shadow file which is restricted to access by admin users. The &#x2F;etc&#x2F;passwd file contains only basic user account details, but no passwords. Adding an empty file named login to the &#x2F;etc&#x2F; directory will prevent non-root logins.</p>
<p>Now we can turn our attention to some more obvious network security considerations. When a remote client requests a network connection, your server has to know how to respond. Normally, local requests for some services cause system daemons to start, and once a service is no longer needed, stop. However, it wouldn’t be very secure to allow remote requests to directly spawn local daemons. So, a class of daemon manager, or a super-daemon, was created.</p>
<p>Originally called inetd, for internet service daemon. Inetd manages local daemons on behalf of remote clients. By the way, be careful not to confuse the various inet files and directories with the similar sounding init and inittab files and directories that we discussed earlier. Those services control system boot and run levels, and had relatively little to do with security. What’s important for us right now is to be aware that inetd can be configured to accept or reject remote requests according to your instructions. On Debian systems, until very recently at least, inet configurations were kept in the &#x2F;etc&#x2F;inetd.conf file. Over time, security concerns caused most distributions to replace inetd with more sophisticated super-daemons like xinetd, which would be controlled by the &#x2F;etc&#x2F;xinetd.conf file, or by files in the &#x2F;etc&#x2F;xinetd.d&#x2F; directory. In this case, xinetd.conf contains nothing more than a pointer to the &#x2F;etc&#x2F;xinetd.d&#x2F; directory where individual service config files are kept.</p>
<p>Let’s take a look at an xinetd file, the one called time. The value of the service line is the service name, time, in our case. By default, network access to time is disabled as we can see from the yes value of the disabled line. We can also see both tcp and udp versions. To provide real-time protection, the tcp.d daemon, otherwise known as a TCP Wrapper, can be invoked before a requested service is actually started up. Tcp.d will then check the client host against lists of allowed or denied addresses, and if everything’s okay, drop out, allowing the service to start. The files tcp.d reads are both in &#x2F;etc, hosts.deny and hosts.allow.</p>
<p>Hosts.deny is a blacklist, meaning any host addresses listed will be blocked from making requests, while requests from everywhere else will be allowed.</p>
<p>Hosts.allow, on the other hand, is a whitelist, so that only those domains actually listed will be allowed access, and all others will be denied. If there are entries in both files, matches from hosts.allow will be acted on, and anything from hosts.deny will be ignored. To review, the super-daemon controls remote client requests according to configurations found in the &#x2F;etc&#x2F;inetd.conf or &#x2F;etc&#x2F;xinetd.conf, or files in the &#x2F;etc&#x2F;xinetd.d&#x2F; directory. The tcp.d daemon will check the origins of remote requests against the entries in the hosts.allow whitelist file and the hosts.deny blacklist file. As we’ve briefly seen in previous videos, a lot of the access control for resources living in Amazon’s AWS cloud is handled by security groups and access control lists, or ACLs.</p>
<p>You can therefore open up a port, like https port 443, for traffic from a specific range of sources, either using the ACL at the virtual private cloud level, or within the security group at the resource level. You can also precisely manage access by particular services using AWS’ Identity and Access Management service, IAM. In this example, network access to a DynamoDB database table is restricted to only IAM users whose name matches the name of the table. By the way, Cloud Academy has a number of courses that deal with a AWS security in much greater detail.</p>
<h1 id="Connection-Encryption"><a href="#Connection-Encryption" class="headerlink" title="Connection Encryption"></a>Connection Encryption</h1><p>Since managing network computers will often mean you’ll be spending plenty of time transferring resources back and forth among machines, and logging in and out of remote shell sessions, it’s hugely important that you should make sure that you’re not exposing passwords and sensitive data in the process. The best way to address this need is through encryption, which uses complex algorithms to convert your plaintext data into an unreadable mess of apparently random characters. For all practical purposes, the only way to decrypt such data is by using software that can apply the original algorithm in reverse. Linux employs a program called OpenSSH to ensure that remote communication is properly encrypted. As you’ve seen many times in the series, you initiate OpenSSH remote shell sessions using ssh, followed by the account name and address of the machine you want to access. By default, you will now enter the password for the user account on the host machine, then you’ll be in. As you’ll see in just a minute, OpenSSH can also be configured to permit passwordless remote sessions. And in fact, from a security perspective, those are much preferred. But let’s first learn a bit about how OpenSSH actually works.</p>
<p>When a login session opens, the ssh agent program launches to hold all private keys that will be used for public key authentication. The encryption is controlled by files in the etc&#x2F;ssh directory. Here, we can see eight ssh key files which are really four pairs of host key files. One of each pair is public, recognizable of course through their .pub extension, and the other is private. We’ll talk more about the differences between public and private files a bit later.</p>
<p>Each of the four pairs is built using a different encryption algorithm: DSA, RSA, Ed25519 and ECDSA. DSA stands for Digital Signature Algorithm. And RSA are the first letters of the names of the three MIT researchers who created the particular algorithm: Rivest, Shamir and Adleman.</p>
<p>It is these keys that will be used to authenticate and encrypt all incoming traffic from clients also using OpenSSH.</p>
<p>These keys, by the way, all use the SSH protocol 2. The way your machine will be allowed to host remote client sessions is controlled by the sshd_config file.</p>
<p>We can see that the file allows you to control many configuration details, including the session port, which is currently set to the SSH default port of 22.</p>
<p>Changing that value to a very high port, like say, 45123, would make unauthorized access to your system that much harder. But you’d have to make sure that all legitimate clients were configured properly. The file also points to four host keys we saw just before, and defines other behavior like logging and authentication. Since you could also use this machine as a client to access a different machine, OpenSSH will control client behavior. This time through the ssh_config file. The ssh_config file controls a long list of behavior variables, most of which are currently not enabled. Let’s review. OpenSSH encrypts data passing between machines using key pairs stored in the etc&#x2F;ssh directory.</p>
<p>SSH protocol 2 algorithms include RSA and DSA, with RSA being the stronger. SSH server or host behavior is controlled by the sshd_config file, while SSH client behavior is managed through the ssh_config file.</p>
<p>Now let’s explore the way OpenSSH allows remote sessions that work between trusted machines without the need to enter passwords each time.</p>
<p>Besides the key pairs we’ve already seen in etc&#x2F;ssh, OpenSSH can be told to create different key pairs in a &#x2F;.ssh directory, in a user’s home directory.</p>
<p>This machine doesn’t yet have any keys, or even a .ssh directory. So let’s create some. First of all, we should make sure that OpenSSH is properly installed. Now we’ll run ssh-keygen to automatically generate a new key pair.</p>
<p>We’ll create an OpenSSH 2 key pair using the RSA encryption algorithm. We could specify our own filename, or simply go with the default. For significantly stronger protection, we can add a passphrase to protect against the possibility of somebody stealing your private key, and then gaining access to your host from his own machine. Note however that if you do use a passphrase, you might want to avoid having to type it for each login, which kind of defeats part of the purpose of passwordless logins.</p>
<p>By providing your passphrase just once per session to the SSH agent program by way of ssh-add, you can both maintain control over your private keys, and simplify your login sessions.</p>
<p>You could also use DSA or not specify any standard at all, which would by default, create keys compliant with the SSH protocol version 1.</p>
<p>Specifying RSA or DSA will generate keys using the stronger protocol 2. Overall, the protocol 2 RSA is usually considered a more efficient and in some ways, stronger standard.</p>
<p>Notice how we don’t run keygen as sudo. Note that one file of each of these pairs has a .pub extension, which as you can guess, stands for public. Note also that the public keys permit other uses to read them, while the private keys are accessible only to their owner.</p>
<p>This is because you’re going to copy the contents of the public key to be stored in the authorized keys file in the hidden SSH directory on the host machine. By host, we mean the machine into which you plan to login from a remote location. But the private key will remain on your client machine and must be carefully protected as it effectively contains all the keys to your castle.</p>
<p>Now that we’ve got a new pair, we’ll have to copy the public key to the host server we want to access remotely.</p>
<p>There are all kinds of ways to do this, but the main thing is to be absolutely sure that you don’t make any changes to the file contents along the way.</p>
<p>We use SCP, Secure Copy, which works securely through the OpenSSH package. From the same directory that holds the file, run SCP, the filename, the login address, and the directory on the host machine where you’d like the file to go. SCP by the way, works on top of our OpenSSH infrastructure and takes advantage of both its encryption and connectivity.</p>
<p>Now you’ll need to ssh into the server, still using the less secure password access method just one last time.</p>
<p>Let’s view the key file we’ve just copied. CD to the &#x2F;.ssh directory. Confirm that an authorized keys file exists.</p>
<p>And add the contents of the key file to the authorized keys file. Now. just to make sure it’s set right, we’ll restrict permissions for the file to access only by its owner.</p>
<p>We’ll log out and try logging in again to make sure we’re not asked for a password. I’ll exit the host so we can take a look at the known host file in our &#x2F;.ssh directory where you can see a record of the machine we’ve just visited.</p>
<p>Should any of these details change in the future, and we try to log in again, we’ll be warned of the change, and advised to update this file if you want to proceed.</p>
<p>Let’s review. Key pairs to control passwordless remote shell sessions are usually kept in the &#x2F;.ssh directory in a user’s home directory.</p>
<p>Key pairs for passwordless access are created by ssh-keygen and if desired, defined using the -t argument.</p>
<p>If you create .ssh key pairs with the passphrase, you can pass the phrase just once to SSH agent using ssh-add.</p>
<p>The public key is added to the authorized keys files on the host machine while the private key is kept safely on the client. The known host file on the client machine contains references to each host machine that you’ve accessed using passwordless key pairs.</p>
<h1 id="SSH-Tunnels-and-File-Encryption"><a href="#SSH-Tunnels-and-File-Encryption" class="headerlink" title="SSH Tunnels and File Encryption"></a>SSH Tunnels and File Encryption</h1><p>Hi. This is going to be the very last video in our LPIC-1 Certification series so we’re going to wrap up just a few remaining encryption related details, and then say goodbye. We’ll talk about SSH tunnels, GPG file encryption, and using SSH key pairs on Amazon’s AWS. First of all, we’re going to use what we’ve learned about SSH connections to create and use an SSH tunnel, that is, once you’ve got a live SSH session between two machines, you can use the connection to carry other functions. For instance, suppose you need to securely open a GUI program on a remote computer. Perhaps someone you’re working with is having trouble configuring his or her own desktop and you’d like to help. To do this, we’ll have to make sure that two simple settings in the ssh_config files on both our host and client machines are set to allow X11 connections. On the host machine, or in other words, the machine into which we will be logging for our remote session, we’ll open up the etc&#x2F;ssh&#x2F;sshd_config file to make sure that X11 forwarding is set to yes, which happens to be true already. Now on the client machine, meaning the computer from which we’ll launch the SSH session, we’ll edit the etc&#x2F;ssh&#x2F;sshd_config file so that the value of the ForwardX11 option is yes.</p>
<p>Now let’s create a special XSSH session. We’re in. So let’s see if we can open a GUI program, say, gedit.</p>
<p>It works. Besides using encryption to protect the data transferred back and forth in the process of running remote sessions, we can also encrypt files and messages sent between systems. In this case, however, the tool of choice is GPG, which stands for GNU Privacy Guard. Here’s how it works. GPG will generate a random symmetric key that it uses to encrypt a message you’d like to transfer.</p>
<p>The symmetric key is itself then encrypted using the recipient’s public key, and then sent with the encrypted message. When the recipient gets the message, GPG will decrypt the symmetric key using his private key. GPG then uses that decrypted key to decrypt the actual message.</p>
<p>Let’s generate some GPG keys using gpg –gen-key. We’ll first be asked to select a key type. We’ll stick with the default value. The default of 2048 bits for the key length is also fine for us.</p>
<p>We are now asked to configure how long the key should be allowed to remain valid. Using 0 will allow it to remain indefinitely. Since it’s usually not a great idea to create a key without any limits, GPG will ask if you’re sure you want it done that way in this case.</p>
<p>We’ll add a username, email, and a comment; all of which will be used as part of the key creation process.</p>
<p>Next, we’ll add a passphrase, and of course, we’ll be very careful not to forget this phrase. Finally, we’ll be asked to generate as much random noise as possible.</p>
<p>I’ll open a second session on his virtual machine and create some serious but useless busywork using find and xargs.</p>
<p>Eventually that will satisfy GPG’s needs and we’ll have our new keys stored happily in the hidden .gnupg directory.</p>
<p>Now that we have our GPG keys, we can use them along with the username and password we created earlier to encrypt the file. As you can see, gnupg has created a new file with the gpg extension. We could now use any normal method to copy the file as an email attachment, for instance, without having to worry about security. Let’s see how we might decrypt our encrypted file.</p>
<p>We’ll run GPG with the –output argument, create an easily recognizable name for the output file, and use the name of our GPG file as a value for decrypt. We’ll enter the passphrase we specified when we created the keys, and we’ll have our new decrypted version of the file. Of course, since the original happens to be sitting in the same directory in our case, that’s not all that useful. But you can see how it would be if we’d received only the encrypted file through an Internet transfer. So that a real recipient can decrypt files you send them, we’ll have to know how to export and then import public keys.</p>
<p>To export your key, use gpg –export and the name you gave your key. Then pipe the key to a new file that should end with the .pub extension.</p>
<p>When he gets it, the recipient will have to import the key into his own GPG installation using gpg –import and the name of the file.</p>
<p>Of course, we’re not going to do that here since the key is already a part of our set. But this is how you would do it on a recipient system. We can view all of the public keys on a system using –list-keys.</p>
<p>Finally, there may be times when you’ll need to revoke existing GPG keys. Perhaps, for instance, a server where the public key has been compromised, and you can’t be sure that the key hasn’t fallen into unfriendly hands.</p>
<p>On a simple level, revoking is quite straightforward. You simply run –gen-revoke, followed by your key ID.</p>
<p>This will print some ASCII text which you should copy into a new file. This is something you can do at the time you create your keys in the first place.</p>
<p>In fact, considering that your own machine can be compromised, stolen or destroyed, it’s probably not a bad idea to keep your revoke text file somewhere safe. When you need to revoke the key, run gpg –import using the revoke text file as input.</p>
<p>Now, one last time, let’s review. To enable X11 connections, the value of the X11 forwarding setting in the host’s etc&#x2F;ssh&#x2F;sshd_config file must be yes, and the value of ForwardX11 in the client’s etc&#x2F;ssh&#x2F;ssh_config file must also be yes.</p>
<p>You open an xssh session using ssh -x. You generate GPG keys using gpg –gen-key supplying a username, a passphrase, and lots of noise in the background to provide food for the randomizing process.</p>
<p>You can decrypt files using gpg –output filename and –decrypt filename.gpg. You can export a key using gpg –export piping the output to a new file, and import a key to your system using gpg –import.</p>
<p>Gpg –list-keys will display the keys on your system. Gpg –gen-revoke followed by a key ID will output text that can then be used to revoke a key.</p>
<p>And gpg –import can be used to actually revoke a key. AWS has their own system for managing SSH key pairs.</p>
<p>From the EC2 dashboard, click on Key Pairs, then on Create Key Pair. Give your pair a name and click Create, and AWS will create the file with a .pem extension, and automatically offer you the option of opening or saving the file.</p>
<p>You might want to save it to your home directory so it will always be immediately available whenever you open your terminal.</p>
<p>You must edit the public key’s file permissions so that no one but the owner has access. If you don’t do this, you won’t be able to connect. Once you’re ready to access a resource, you use ssh followed by -i and the name of the .pem file, and then the resource address.</p>
<p>Bear in mind that AWS key pairs are tied to the region in which they are created. If you’d like to use a key pair that was created in one region to access, say, an EC2 instance that’s in a different region, it won’t work.</p>
<p>So that’s it. We really hope that this series of courses on Linux Server Administration has taught you a lot about the beauty and function of Linux, and has prepared you for both the LPIC-1 exams and for a career in Linux System Administration.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-102-LPIC-1-102-Linux-certification-Linux-Networking-5-of-6-8/" rel="prev" title="Linux-LPIC-102-LPIC-1-102-Linux-certification---Linux-Networking-5-of-6-8">
      <i class="fa fa-chevron-left"></i> Linux-LPIC-102-LPIC-1-102-Linux-certification---Linux-Networking-5-of-6-8
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-102-Linux-Terminal-Playground-Red-Hat-10/" rel="next" title="Linux-LPIC-102-Linux-Terminal-Playground-Red-Hat-10">
      Linux-LPIC-102-Linux-Terminal-Playground-Red-Hat-10 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Intro"><span class="nav-number">1.</span> <span class="nav-text">Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-Security"><span class="nav-number">2.</span> <span class="nav-text">System Security</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Network-Security"><span class="nav-number">3.</span> <span class="nav-text">Network Security</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Connection-Encryption"><span class="nav-number">4.</span> <span class="nav-text">Connection Encryption</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SSH-Tunnels-and-File-Encryption"><span class="nav-number">5.</span> <span class="nav-text">SSH Tunnels and File Encryption</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
