<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionGreetings, welcome to Cloud Academy’s course on managing Google Cloud Kubernetes and App Engine Resources. I’m delighted to have you join me in what is bound to be an educational and excit">
<meta property="og:type" content="article">
<meta property="og:title" content="GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16">
<meta property="og:url" content="https://example.com/2022/11/19/GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionGreetings, welcome to Cloud Academy’s course on managing Google Cloud Kubernetes and App Engine Resources. I’m delighted to have you join me in what is bound to be an educational and excit">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T04:02:57.000Z">
<meta property="article:modified_time" content="2022-11-23T00:50:50.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 00:02:57" itemprop="dateCreated datePublished" datetime="2022-11-19T00:02:57-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-22 20:50:50" itemprop="dateModified" datetime="2022-11-22T20:50:50-04:00">2022-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GCP-Cloud-Engineer/" itemprop="url" rel="index"><span itemprop="name">GCP-Cloud-Engineer</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/GCP-Cloud-Engineer-Managing-Google-Kubernetes-Engine-and-App-Engine-16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Greetings, welcome to Cloud Academy’s course on managing Google Cloud Kubernetes and App Engine Resources. I’m delighted to have you join me in what is bound to be an educational and exciting adventure into the world of Google Cloud development.</p>
<p>First, I’ll let you know a bit about myself, before I get into the course outline. My name is Jonathan. I’m one of the course developers with Cloud Academy. I’m a former high school teacher turned technical consultant specializing in DevOps and data engineering. It’s a pleasure to get back into the world of teaching, only now talking about technology.</p>
<p>This course is designed to be very practical. It is meant for technology professionals, developers, data architects, CTOs, etc. With the goal of helping them get a solid understanding of how to build infrastructure using Google Cloud services. This course will also help you to prepare for the Google Associate Cloud Engineer Certification exam.</p>
<p>So you may be wondering what the prerequisites are for a course like this. What do you need to already know to be successful in this class? Well a few things. For one, you should have some familiarity with Google Cloud Platform. This course assumes you know basically what GKE and App Engine and Compute Engine are. You should also be comfortable working with command line tools and in a web console. You don’t need to be an expert programmer you don’t need years of experience working with GCP or AWS or something similar, however, general knowledge of what cloud providers do is helpful as this course will not cover rudimentary concepts such as, “What is a VM?”</p>
<p>So now let’s talk learning objectives. In this course, there are two main takeaways related to Google Cloud Platform. Number one, the student will learn how to manage and configure GCP Kubernetes Engine resources. And number two, the student will learn how to manage and configure GCP App Engine resources.</p>
<p>In short, this course covers GCP compute services related to Kubernetes and serverless architectures, specifically GKE, and App Engine. This might seem familiar if you took an earlier course, Planning and Configuring a Cloud Solution, which also covers these topics but the difference here is that the learning objectives in that earlier course was just deploying and configuring, whereas the material was more of an overview because of that.</p>
<p>In this course, we’re going to go deeper. If you have zero familiarity with GCP we definitely recommend taking the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/planning-configuring-google-cloud-platform-solution/introduction/">Planning and Configuring</a> course first. That will more gently introduce you to these compute services. This course, by contrast, will assume that you have a basic understanding of the different services and will instead serve as a deep dive on how to actually manage these systems. By the end of this course, you should be truly ready to be responsible for a GCP environment, specifically App Engine and Kubernetes Engine. You’re not just clicking through a wizard and hoping for the best.</p>
<p>So, one last thing before we start, I want to encourage everyone to leave feedback. Email <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a> if you have any questions, comments, suggestions, concerns. We always appreciate people taking the time. And so now without further ado, let’s get started.</p>
<h1 id="Section-One-Introduction"><a href="#Section-One-Introduction" class="headerlink" title="Section One Introduction"></a>Section One Introduction</h1><p>Welcome to section one. In this quick introduction lesson, we’ll go over the learning outcomes for this first section of the course. Our focus will be on <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> Kubernetes Engine. So there are two high-level goals for this section. First, we wanna make sure you understand Kubernetes generally. Whether it is inside GCP or with another cloud provider, there are certain concepts you need to be familiar with to utilize Kubernetes effectively. Second, we will go over GCP Kubernetes Engine’s specific tools for implementing a Kubernetes application and we’ll do this in two lessons, the first focusing on creating a cluster and setting up an application container, and then, the second lesson, we’re focusing on more fine-grained Kubernetes configuration. We’ll drill down into topics like pods, nodes, services, deployments, and stateful applications, so on and so forth. Finally, we’ll end the section with a practical demonstration. We’ll do a video walkthrough on how to utilize GKE starting with nothing and ending with a running app in a GKE cluster. So if you’re ready, let’s dive in.</p>
<h1 id="Kubernetes-Concepts"><a href="#Kubernetes-Concepts" class="headerlink" title="Kubernetes Concepts"></a>Kubernetes Concepts</h1><p>Review of Kubernetes Concepts. If you’re coming from the more introductory, “Planning and Configuring” <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> course, then you recall its basic overview of GKE. The goal there was really to just show how it works with enough information to get you started. In this course, we want to get you ready to be responsible for maintaining a GKE cluster in a real production environment. So this will require a deeper dive into how GKE works, and before we do that, we want to ensure you have a deep understanding of Kubernetes concepts. If you’re already are a Kubernetes expert and you wanna just dive into GKE, feel free to skip this lesson.</p>
<p>So let’s start by talking about what Kubernetes is at a high level. Stated most succinctly, Kubernetes is a system for orchestrating containerized applications. So if you are packing your software application using something like Docker, and wish to deploy and manage those Docker containers, Kubernetes gives you the tools to abstract away most hardware and networking considerations to make managing your system much easier.</p>
<p>Consider the basic resources needed to deploy a Dockerized application. The Docker container needs a server to run on, so that means compute resources. It needs a certain amount of CPU and memory. It also needs network access, port configuration, firewalls, load balancing, DNS configs. The app may need to talk to other backend services, or it may be part of a larger system of microservices involving several other Docker apps. Managing all of this complexity manually is very difficult. We’d need to create all sorts of scripts and documentation for each server, each network setup, each application’s hardware needs, config files, etc., etc. Kubernetes, like other orchestration frameworks such as Docker Swarm or Mesos Marathon, it makes all of this work much easier.</p>
<p>It starts with the concept of a cluster. A Kubernetes cluster is a complete set of resources for an application environment. Hardware resources. So in general, this will be confined to a single data center and will comprise a number of servers and network interfaces. Storage is also a possible resource here as Kubernetes can create ephemeral and persistent volumes. The servers, whether physical machines, VMs running in EC2, or Google Cloud Compute, or somewhere else, they are referred to as nodes. Servers are nodes. A Kubernetes cluster may, for example, run on three nodes, three virtual servers, that will host your container-based applications. Having multiple nodes grants redundancy in case of hardware failure and it also makes scaling up or down easier. Each node will run a kubelet, a lightweight Kubernetes agent, that allows it to communicate with other nodes and stay in sync regarding cluster configuration and help.</p>
<p>A Kubernetes cluster with just nodes, however, is not really doing anything useful. In order to run a container, the cluster must have access to an image repository and it has to create pods. Now, a pod is a basic workload unit in Kubernetes. Often, a pod is an instance of a single container, however, it can also be comprised of multiple containers. A pod will also have a unique IP address within the network as well as storage resources based on its config. This is the smallest unit of what we might think of as a microservice in a software as a service architecture. So for example, you might have a simple stateless Python app run as a pod in your Kubernetes cluster. And we’ll dig in deeper on the container configuration and cluster setup in the next section.</p>
<p>So now, with a basic understanding of clusters, nodes, and pods, there are only two other core concepts of Kubernetes that you need to really get started working with GKE. And these two are Controllers and Services. Now, we’ll link to the <a target="_blank" rel="noopener" href="https://cloud.google.com/kubernetes-engine/docs/">Kubernetes documentation</a> if you wanna really go deeper on all the other terminology. That’s a bit out of scope for this class, we’re just doing a basic conceptual overview.</p>
<p>But let’s diagram there, let’s start with Controllers. You can think of a Kubernetes Controller as a <em>control loop</em>. This is a basic CS concept. It’s a tool for maintaining a certain desired state. In Kubernetes, this refers to an API that manages a pod or set of pods by preserving a pre-set configuration. So there are actually a few different types of Controllers. One of the most basic is the ReplicaSet, which simply guarantees that a certain number of copies of a given pod are kept running. So for example, let’s say we have our stateless Python app running as three pods across the nodes in our cluster. If they are running as a ReplicaSet, then Kubernetes will make sure that three pods are always running. If there is a failure, a crash, an error of some kind that causes a pod to die, the ReplicaSet controller will try to bring up a replacement.</p>
<p>Now, there are other Controller types for different purposes. There is the DaemonSet controller which is meant to guarantee a specific distribution of pods on each node. This controller is useful for hardware monitoring, logging applications that need a one-to-one mapping to servers for whatever reason. There’s also the StatefulSet controller designed for stateful applications. This controller provides guarantees about pod ordering, uniqueness, and stable storage. Finally, there is the Deployment Controller. This is designed to work with other Controllers, such as ReplicaSets. The Deployment Controller, as the name implies, is designed for declarative updates to a set of pods. It handles transitioning a set of pods from its current state to a defined desired state.</p>
<p>So there’s more we could add about Controllers but this is enough to get the basic idea. Again, don’t hesitate to dig through the Kubernetes documentation for more details about each specific Controller if you’re interested. But for now, let’s move on and talk about Services.</p>
<p>Services are very important. Services are Kubernetes’ way of exposing pods to external networks including the public internet. So if we wanna make our application reachable from a browser, we’re going to need a Service to set up the IP address and DNS name. The basic configuration needed is a network protocol, such as TCP as well as ports and some metadata such as a Service name. Now as with Controllers, there are a few different types of Services. There are ClusterIP services that only expose an internal IP address, suitable for apps that don’t need to be accessed from the public internet. Then you have NodePort services that expose the node’s IP address on a specific port. This might make sense depending on your firewall setup. You may not want your Kubernetes nodes, the actual VMs, to expose their IP addresses, even if its only on a specific port. And then, you also have LoadBalancer and ExternalName services, both of which work more closely with your cloud provider. The former, the LoadBalancer, it works with your provider’s LoadBalancer resources to expose a set of pods while the latter, the ExternalName type returns a CNAME record based a DNS name of your choosing.</p>
<p>So Controllers let us turn sets of running containers into resilient, updateable applications with predictable behavior. And Services let us control access to those applications by publishing them in various ways. Now, if you understand these five terms, cluster, node, pod, controller, service, then you now know enough Kubernetes to get your hands dirty. In the next short lesson, we’re gonna do just that. We’ll review setting up a cluster and preparing a container for deploy using GKE. It’s gonna be a blast. We’ll see you there.</p>
<h3 id="Lectures"><a href="#Lectures" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Cluster-and-Container-Configuration"><a href="#Cluster-and-Container-Configuration" class="headerlink" title="Cluster and Container Configuration"></a>Cluster and Container Configuration</h1><p>Welcome to part three. In this lesson, we’re gonna cover just two things; launching a cluster and setting up a Docker image for deploy as a pod in the cluster. We’ll go over both the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> console approach and the CLI, which can be used from your local computer or a remote shell environment or the GCP cloud shell tool from the browser, so let’s get right into it.</p>
<p>Now, recall that in order to have a cluster, we need to have nodes, which are just virtual machine instances. In the early days of Kubernetes, we would have to manually create those instances, install the Kubernetes agents, known as kubelets, and then, run some commands to wire it together. Now, with GKE, we can get a cluster up and running much faster. In the web console, it’s as simple as clicking on the Kubernetes Engine menu and then, selecting the blue Create Cluster to kick off the setup wizard. I recommend going through this sort of hand-holding wizard approach your first time to get a sense of what configuration is available. We can set a name, a number of nodes, a machine type, a geographic region, and some other config options. GKE has some really nice defaults and it has options for things like CPU-intensive or memory-intensive applications. Once you finish running through it, you’ll have a running Kubernetes cluster with some set of nodes.</p>
<p>Now, we should also take a moment to talk about node pools. Node pools are groups of nodes within a cluster that share the same configuration. This is a GKE-specific feature. It’s an extension of Kubernetes functionality essentially. When we create a cluster in GKE, it will by default create a set of nodes known as the default node pool. We can then just work with that node pool or we can add additional node pools with different configuration. So for example, we might want to have a set of nodes dedicated to in-memory caches, so we create some instances with lots of RAM and a particular network config, and that could be our cache node pool. Each node pool can use distinct virtual machine images, distinct instance type, and storage options.</p>
<p>So you can create node pools in the web console or using the CLI tools with the gcloud container node-pools command. With the console, you can also upgrade or delete node pools as well. So to do this with the console, simply go into the Kubernetes Engine menu and click Edit on the cluster you wanna change. There should be a node pools section with expandable menus. Click on the one you want to change, set the size value to the desired count, and click Save.</p>
<p>So that’s node pools. Now that we understand the makeup of clusters a little bit more, let’s go ahead and create one. The command to instantiate our basic cluster is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud container clusters create cluster-name</span><br></pre></td></tr></table></figure>

<p>Now, this will just spin up a minimal cluster with default values and a specified name. You’ll likely have to at least add a –zone argument if you don’t have a default geographic zone configured. The container clusters create command actually has a lot of optional flags to configure all of the things we saw in the web console, stuff like machine type and region, number of nodes, etc.</p>
<p>Now, after running this command, at this point, all we have is a Kubernetes cluster running with no actual application. Now, we can launch an application in container form by using the deployment controller, that is by creating a deployment with a command like so. We do:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment app --image=$ImageRepo:$Tag</span><br></pre></td></tr></table></figure>

<p>This will create a running application here, named app, using an image of our choosing. So before we can run this, we need to deal with that <code>--image</code> argument. Kubernetes needs the location of your container registry, as well as the tag. Now, the container registry, it doesn’t actually have to be in Google Cloud. It could be Docker Hub or AWS ECR or somewhere else. As long as we can provide GKE with the right URL and credentials, we can access our images from anywhere.</p>
<p>Google Cloud, however, it does have a container registry service. In the console, all you have to do is enable it. You enable the Container Registry API and you can use it. It’s just a couple of clicks. We’ll have a documentation link <a target="_blank" rel="noopener" href="https://cloud.google.com/container-registry/docs/quickstart">here</a>. And when you push Docker images to the registry, you should see them in the UI. You can click on the image’s button in the Container Registry section and then, select individual images to see details. This is a really convenient way to check names, tags, dates, other information about your images.</p>
<p>So in our video demo, we’ll run through the Docker commands for building images, logging in, and pushing them to the repo. For our purposes here, we can use one of GCP’s sample applications for the image argument and we can run it as so:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment hello-server --image=gcr.io/google-samples/hello-app:1.0</span><br></pre></td></tr></table></figure>

<p>So that’s the hello app, tag 1.0, we run this and with that, we have deployed a container application to our GKE cluster. We can see cluster health in the console or by running kubectl or gcloud commands, and congratulations, you’ve got something running. However, this is just the start of the fun. We need to go a bit deeper. We need to understand what we just did.</p>
<p>In our next lesson, we’ll learn more about controllers, services, and pods. It’ll be a blast. See you there.</p>
<h3 id="Lectures-1"><a href="#Lectures-1" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Working-with-Pods-Services-and-Controllers"><a href="#Working-with-Pods-Services-and-Controllers" class="headerlink" title="Working with Pods, Services, and Controllers"></a>Working with Pods, Services, and Controllers</h1><p>Working with pods, services, and controllers. In the last lesson, we reviewed how to spin up a cluster and execute a simple deployment. By the end of it you had a simple app running, however, it probably all seemed a bit magical if you’re not already very familiar with GKE and Kubernetes. In this lesson, we’re going to break things down further to ensure you know what is really going on under the hood.</p>
<p>So let’s start by talking about the pod we launched. Remember this is our workload, usually defined by a single container taken from an image repository. We used a sample image from a public <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> repository. We deployed it by running a create deployment command using kubectl, the Kubernetes command line tool. The deployment is the controller for a given pod or set of pods.</p>
<p>So why did we use a deployment controller at all? Why bother using a controller in the first place? Couldn’t we just generate pods without that construct as overhead to deal with? Well, technically yes, we could just create pods, but this is bad practice. In general, with Kubernetes, we always want to use controllers when creating pods. This is, as the name implies, meant to give us more control. It reduces our maintenance and monitoring workload considerably to have a controller responsible for the state of pods. It lets us ensure that pods are healthy, that we have the right number, that the right networking is there, the right configuration, etc., etc. In general, in Kubernetes, we want to work with the highest level of abstraction possible, so we prefer to work with controllers instead of individual nodes or pods.</p>
<p>So, for now, we can get a bit more information about the pods that are running, by running this command: <code>kubectl get pods</code>. This will spit out some basic information about pods running in a cluster. We should see 1&#x2F;1 running, meaning the cluster expects one pod and sees one pod. We see its age, we see its status, we see the number of restarts. We can now add more pods to this cluster a few different ways. We can use the web console by navigating to Kubernetes Engine UI. And there we just click on the Workloads button and from there we can click on Deploy to launch more pods. There is a default nginx pod we can do just to test that out. And by default, this will create three pods out of the same container. And again it will do this by using the deployment controller.</p>
<p>We can get information about our deployments by running this command: <code>kubectl get deployments</code>. This will show us our available deployment controllers. Here we aren’t seeing nodes or pods, but rather deployments, which are kind of an abstraction level higher. So we will see the hello-server deployment which you might recall was the name we gave the deployment in the command. And also remember that a deployment is a type of controller, and crucially it can work with other controller types to both execute updates and ensure that our apps are in a desired healthy state. In this example, our pods are also running using the ReplicaSet controller.</p>
<p>So we can actually see this by running a command: <code>run kubectl get replicasets</code>. And we should see both the hello-server and the optional nginx-1 application if you launched it. They should both pop up since they’re both ReplicaSets. Now if we were to run a similar get command for DaemonSets or StatefulSets, <code>kubectl get daemonsets</code>, or something like that, it will return nothing, because the pods we have launched so far do not use those controllers.</p>
<p>ReplicaSets work really great for stateless apps that are easily distributed across a set of nodes. Recall that DaemonSets are designed for scenarios when we want to ensure that all or a specified set of nodes run a copy of the pod. And when we need that mapping of pods to nodes. When we care about hardware-level mapping, basically, that’s when we use a DaemonSet, and when we care about state, pod deployment order and persistent storage, then we will want to use a StatefulSet.</p>
<p>So now let’s talk a little bit about services. If we run <code>kubectl get services</code>, the only thing that should come up is something named Kubernetes, initially. This is the default service for the cluster that is unrelated to the pods that we have created. So how do we go about exposing our pods running as ReplicaSets to the public internet? Well to do that we need to create services, and this will create generating some additional config. We can create that config as a YAML and run a <code>kubectl apply,</code> run that command to execute that config in the cluster. We could also run a <code>gcloud</code> or <code>kubectl</code> command with some arguments. Or, easiest of all, we can go into our GKE console and click on Workloads. And from there we just click on the pod we care about, for example hello-server, and then just click the blue Expose button to generate a service. Once we do this it will ask for a port mapping before assigning an external IP. Now by default GKE will create a load balancer type service, but recall that there are other options here such as a ClusterIP or a NodePort service. </p>
<p>So pat yourself on the back. You now know enough Kubernetes and GKE to really kick some butt. You should have a sufficient grasp of pods, services, controllers to not only spin up a cluster, but also to deploy resilient services using appropriate controllers. To really lock in our understanding though, we need to see all of this in action. That’s what the next section, the video demonstration, is designed to do. See you there.</p>
<h3 id="Lectures-2"><a href="#Lectures-2" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Kubernetes-Demo"><a href="#Kubernetes-Demo" class="headerlink" title="Kubernetes Demo"></a>Kubernetes Demo</h1><p>Welcome to our video demonstration on GKE in GCP. That’s Google Kubernetes Engine in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">Google Cloud Platform</a>. In this demo, we’re gonna do a few fun things. First, we’ll create a basic application package, using Docker, and then upload it to a registry. Second, we’ll create a GKE cluster and deploy our app into it and see it running. And then finally, we’ll expose the app to the internet before scaling it up and practicing deploying a new version of the app, an upgrade essentially. So we’ll do most of these things using the GCP Cloud Shell. And also, maybe occasionally the Web Console a bit. So feel free to follow along at home in your own account.</p>
<p>Now, this tutorial comes mostly from GKE’s own documentation. So we’ll <a target="_blank" rel="noopener" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app">link</a> that below. You’re welcome to just go and look at that. It’ll help if you have questions. If you do plan to follow along, be sure that the Kubernetes API is enabled. You can do this by just going into Kubernetes Engine on the console. Or you can do it if you’re running from your local laptop or something, you can run the command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud components install kubectl</span><br></pre></td></tr></table></figure>

<p>And it should just set it up for you. So make sure that’s ready to go. So let’s get started. Okay, so to start, we need a Docker image with our application code, we need to prepare that. So we could build our own Dockerfile from scratch and using our own app code and test everything, but we’re gonna be lazy. Instead, we’re just going to save some time by taking one of GCP’s test projects. So we can just clone that using git, like so. And once we have it cloned, we’ll just cd into the directories, we wanna use their hello-app, and what we need to do after that, so it’s actually four commands, we clone it, we cd into the directory, we’re gonna export a project ID environment variable, and then we’re gonna do the Docker build.</p>
<p>So we’re gonna do <code>export PROJECT_ID=[PROJECT_ID]</code>, which we can get right from the console. And then we’re gonna do a Docker build of that. So the only thing you might have to look up is the project ID. You can get it right from the console if you don’t know it. And there’s other ways to get it. We’ll have a <a target="_blank" rel="noopener" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">link</a> for that. But once that’s done, you’ll build your image and you’ll have it locally in your Cloud Shell environment. </p>
<p>Now what we have to do after that is, so you can see it building, just give it another sec. But what we have to do after it’s finished building, see it’s finished right here, is we have to push the image to a Docker registry. Because we can’t play from our shell environment, we need it in Google Cloud registry. And that we can do pretty quickly. We can do that with just two commands. We need to first run this. This is <code>gcloud auth configure-docker</code>, and what this will do is it will set the right credentials for a Docker push command, for Docker to push the image to our container registry. And then we just run the Docker push command, which will take the image that we just built, and it will push it to our Google Cloud container registry with the ID that we set, and with the tag that we set, we have hello-app tagged with the v1, it’s our version one. So just give this a sec, it needs to execute. And there you go. Well, it was already there, but it’ll go for the first time, you’ll see it. </p>
<p>Okay, so now that we have the image in the Docker in the container registry, we need to deploy it somewhere, right? We need a cluster to deploy it too. So how can we do that? How can we get a GKE cluster running? There are a few ways to do this. But the simplest way, if we don’t already have a cluster running, is to use the <code>gcloud container clusters create</code> command. Now before we run that, we’re going to set the project ID in our environment.</p>
<p>Okay. And so after that, we have to set our zone, our region where we’re going to actually deploy or create the cluster. So we’ll do US east1-b. And so these two configuration options, the project ID and the zone, this just tells Gcloud what project to associate the cluster with, and where geographically to create it.</p>
<p>So once we have that configuration set, we can run the <code>container clusters create</code> command. Now we see a couple of warnings here, just issue going on around this time, November 2019. But after a while, it’ll take a few minutes, we will see the cluster come up. And it takes a minute because it has to actually create the VM instances that will host the Kubernetes infrastructure and it has to set up some networking. But once it completes, you should be able to see the instances with a gcloud list command. So eventually the cluster will come up, it’ll be finished, it’ll be in a healthy state.</p>
<p>We can see the instances if we run a <code>compute instances list</code> command. So you can see these two here are the two instances we created for GKE hello-cluster. And we can also see it from running a container clusters list. So we should see our cluster come up, and we should see it’s in status running two nodes. So that should be good. So now that we have a cluster running, and we have an image that’s been uploaded, how do we go about deploying that image into our cluster, right? It must be pretty involved, we have to set up deployment configuration, we have to download the image, we have to run it, we have to sync everything, you know, probably requires a lot of work, right? Well, no, actually, it’s pretty simple. We can do the deployment with a single command. We run <code>kubectl create deployment</code> like so, we pass a couple of arguments. We’re gonna call it hello-web, that’s the name of our deployment. And we’re going to pass in the image we wanna use with –image. And that’s our gcr.io. That’s the cluster, the container repository for GCP. And we’ll put in our project ID and the name and tag we had.</p>
<p>So this literally does everything, this one command. We’re leaning on the deployment controller functionality to do most of the legwork. So we’re telling Kubernetes to create a pod using that image. So we can actually see if we do <code>kubectl get pods</code>. And we’ll see there’s our, the pod, the image running in the deployment. And it’s going to create the deployment controller. That’s what keeps everything running. And it’s what moves us from the empty cluster to the desired state. It’ll keep things that way until we make a change.</p>
<p>So now let’s have some fun. Let’s go ahead and make a service. Let’s expose our app to the public internet. We can do that also with a single command. We’re just gonna do <code>kubectl expose deployment hello-web</code>. So this is similar in that we are working with the deployment controller again. So please note that we use expose on the deployment, not on the pod. The deployment is responsible for the overall app configuration. And as far as best practices go, in general with Kubernetes, we wanna work at the highest level of abstraction possible.</p>
<p>So we wanna work with controllers instead of pods or nodes. So in this command, we tell Kubernetes to create a service, a load balancer type service, set to accept traffic on port 80. And that is going to target, it’s gonna be route trafficked to port 8080 for the container. So we can actually see that as well, we can do <code>kubectl get service</code>. And we should see there’s our service running. There’s actually two. There’s the Kubernetes kind of default service here. And then there’s the new one, the load balancer one right here. And we can see it has an external IP address. And we can see if we can hit that. And we can, there is our application. Hello world, version one, host, yada, yada, yada. So pretty cool. We’ve got a running service exposed to the internet.</p>
<p><a target="_blank" rel="noopener" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app">https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects</a></p>
<h3 id="Lectures-3"><a href="#Lectures-3" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Section-Two-Introduction"><a href="#Section-Two-Introduction" class="headerlink" title="Section Two Introduction"></a>Section Two Introduction</h1><p>Welcome to section two. In this second half of the course, we’ll be focusing on <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a>‘s App Engine service. Since this course assumes you already have some familiarity with App Engine, we won’t spend time explaining what App Engine is, and instead, we’ll dive right into spinning up a basic app in the very next lesson. After that, we’ll get into some of the critical management components. First with a lesson on configuring application traffic, and then after that with a lesson on autoscaling. As with the previous section, we will end with a video demonstration, walking through the entire setup and deployment process. So if you’re ready, let’s dive in.</p>
<h3 id="Lectures-4"><a href="#Lectures-4" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Creating-a-Basic-App-Engine-App"><a href="#Creating-a-Basic-App-Engine-App" class="headerlink" title="Creating a Basic App Engine App"></a>Creating a Basic App Engine App</h1><p>Creating a basic App Engine app. This lesson will be a walkthrough of how to create a simple Python service using App Engine. Our focus will be on using the command line tools instead of the web console. While the console is nice for beginners thanks to its setup wizards and friendly UI, the terminal is really where our understanding is properly crystallized, so without further ado, let’s dive in.</p>
<p>Now, first, we need a proper shell environment. As before, we can work from any computer that has the Google Cloud SDK installed. We could connect to a remote server using SSH and install the gcloud tools there or perhaps easiest of all, we could just use the GCP Cloud shell tool from the console, right from our browser.</p>
<p>Now, whichever you choose, the first thing you’ll need to do from the command line is create your App Engine project. This is basically the highest level abstraction for your app. App Engine apps are tied to a project in your <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> account, so you will need your project ID to run the app create command. You can get your project ID from the web console or from running <code>gcloud projects list</code>. So the command for creating your App Engine project will be <code>gcloud app create --project=$PROJECT_ID</code>, so this will create the project.</p>
<p>Now, to verify, you run <code>gcloud app describe</code>. So congratulations, we’re done, right? Well, not quite yet. We don’t just want some empty App Engine framework with no actual service running. We want to deploy something, so for this lesson, we’re going to just use the sample Python app from GCloud’s own documentation. Now, if you’re not very familiar with Python development, I recommend using the GCP Cloud shell, as it is a standardized environment, so you won’t have to worry about Python version or library dependencies. To set up the needed gcloud components, we start by just running this command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud components install app-engine-python</span><br></pre></td></tr></table></figure>

<p>That will take care of the environment configuration for Python, and then, after that, we need to actually get the code. We need to clone that from GitHub, so we’ll do a Git clone. The <a target="_blank" rel="noopener" href="https://github.com/googlecloudplatform/python-docs-samples/">URL</a> will be posted below. And so, now, we have the code that we intend to deploy. The actual hello world app we want is in the following directory <a target="_blank" rel="noopener" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/appengine/standard/hello_world">here</a>, it’s under python-docs-samples&#x2F;appengine&#x2F;standard&#x2F;hello_world. And then, if you wanna try it out and see what it does, you can actually run this command here, <code>dev_appserver.py app.yaml</code>.</p>
<p>Now, this will start the app server and run the service. Now, if you’re doing this from the GCP Cloud shell, all that you’re gonna see is some output showing that it’s running. This is a decent test, but it’s not really what we want. What we’d really like is to see is the app running in a browser and we can’t do that from running it on localhost in Cloud Shell, at least not trivially. If you happen to be doing this from your laptop or desktop, you can browse to the app. Using a browser, you can go to <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> and you should see your output.</p>
<p>Now, either way, we still need to actually deploy this thing, right? We need to make it into a real web service reachable from the public internet. Now, fortunately, this is pretty easy to do since it’s a completed project. All we have to do is, in that same hello_world directory, we run <code>gcloud app deploy</code>. This will use the app.yaml file in that directory for instructions, and then, actually deploy it to the public internet.</p>
<p>So to actually see it from the browser, you run <code>gcloud app browse</code>, and this will give us the URL that we can navigate to to see the app running. Now, for more fun, go ahead and look at the main.py code to see what the app actually does. Feel free to edit it. You can make it output a different message if you’d like. So with that, we can end our first lesson. You now know the basics of deploying an app in App Engine using the shell. This is, of course, a very simple case. We’ll need to go a bit deeper on the actual App Engine configuration, so that you can build confidence for using it in different scenarios. We’ll start on that in our next lesson. See you there.</p>
<h3 id="Lectures-5"><a href="#Lectures-5" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Configuring-Application-Traffic"><a href="#Configuring-Application-Traffic" class="headerlink" title="Configuring Application Traffic"></a>Configuring Application Traffic</h1><p>Section Two Part Three: Configuring Application Traffic. Welcome to Part Three. Now that we’ve gotten our feet wet with App Engine and actually deployed a basic app using the command line, let’s go a bit deeper by looking at how configuration works. Our goal in this lesson is to understand how to configure traffic to different parts of our App Engine environment. However, before we do that, we should review a bit about App Engine generally just to set the foundation.</p>
<p>So recall that there are two types of App Engine environments, Standard and Flexible. The core difference between the two is that the Flexible environment gives you direct control over your application runtime via docker files. You can enable root access to the underlying VM instances. So overall, this is a better option if you have a more unique environment use case, hence the name Flexible. Now the main trade off is that the Flexible environment is slower and it’s less resilient. Instances take minutes to deploy and start up and the instances are automatically restarted more frequently by GCP. You also don’t get access to all the same App Engine API, such as the users and images APIs, which are useful for scripting an environment automation. Another difference is that the Standard environment has a bit more flexibility with its autoscaling options. Now we’ll go into that in the next lesson.</p>
<p>But generally speaking, if you’re using App Engine to go serverless, you’re probably gonna wanna use the Standard environment for its greater speed, reliability, and feature richness. The Flexible environment is more for niche use cases. For most of the remaining lesson and demo content, we’ll be making use of the Standard environment. But keep in mind these differences with the Flexible environment in case you have need of it.</p>
<p>Now whichever environment you use, you’re going to configure your app with YAML files. Only one YAML file is absolutely required, and that is the app.yaml file. This is for application level settings. An application may be made up of multiple services. And these are configured in service.yaml files. You can have more than one service.yaml file in your applications root directory. Now for a fairly simple app, this is okay. But for something more complex, it is better practice to have separate subdirectories for each service.</p>
<p>So here’s a sample app.yaml file. This is the one for the Python app we launched in the last lesson. One line, “r<code>untime: python 37</code>“. As you can see, our app.yaml file is pretty simple. The only thing app.yaml really needs is runtime, is to specify a runtime and potentially a version parameter.</p>
<p>Now if we wanted to, we could break this out into a separate service by using a service.yaml file. And it would look pretty similar, with the only difference being that the service.yaml file generally starts with a field called “service”. So it would look something like this.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service: python-service</span><br><span class="line">runtime: python37</span><br><span class="line">api_version: 1</span><br><span class="line">threadsafe: true</span><br></pre></td></tr></table></figure>

<p>We have a service name, runtime. And we can also put in an API version, and some other config. Now a more complex app might have several of these service.yaml files to create microservices, to create a microservices architecture within App Engine. Now aside from this, there are five other optional configuration files that can help you to extend your app’s overall functionality. And these are dispatch.yaml, queue.yaml, index.yaml, cron.yaml, and dos.yaml.</p>
<p>So real quick, let’s go through them. Dispatch.yaml is for overriding routing rules. You set this file in your application root directory and you use it to route incoming requests to specific services based on specific paths or host names in the URL.</p>
<p>Queue.yaml is for configuring push and pull task queues. This lets us define retry parameters, such as minimum back off time in seconds or, and a maximum task age, for example. We won’t be doing any queue-based services in this course. But we’ll link to the documentation. If it’s relevant to your use case, definitely take a look at this, queue.yaml.</p>
<p>Now dos.yaml is a security feature that lets you blacklist IP addresses or subnets to protect your application from DOS attacks.</p>
<p>And then cron.yaml lets you define scheduled tasks. You set a schedule, such as every 24 hours, or every Monday at six p.m. and then give it a URL for a task definition, much like a typical cron job. The task definitions should live in the specified path. Now, this is very handy for maintenance, monitoring, and other standard automated tasks that you might want to configure and have in one easy to work with location.</p>
<p>And then finally, there is the index.yaml. Now you may have noticed that in our simple Python app from last lesson, an index.yaml file was automatically generated. This file is a reference of properties on various application entities. For simple applications, you will not have to manually edit this file at all. App Engine will automatically update it for you.</p>
<p>So, now that we have some strong background on App Engine configuration and environments, let’s talk about traffic management. There are a few use cases that we need to consider. As mentioned above, we know that we can control service routing by using the dispatch.yaml file. But what about running multiple versions of a service for A&#x2F;B testing or migrating traffic to a single specified version?</p>
<p>To do these two things, we need to talk about traffic splitting and traffic migration. Splitting refers to taking a percentage of our traffic and directing it to one or more distinct versions of a service within our app. Migration refers to the opposite process, moving traffic that’s split among different versions to a single specified new version. So let’s start by talking about splitting. The first thing to know is that traffic splitting is automatically applied if the URLs in your service do not specify an app version. So if you have multiple service.yaml files with different versions of the same service and the URL in your app.yaml file do not have version parameters at all, then traffic will be split automatically and randomly. If you wish to be more precise, you can explicitly enable traffic splitting in the console or by using G Cloud CLI tools or the GCP API.</p>
<p>So for example, if we did this in the console, we would just go to the application page in App Engine and select the versions we want to split. Click on Split Traffic, and then just put in the percentage each service should receive.</p>
<p>Now we could do the same thing with the G Cloud CLI tool with a command like this. Here we have “<code>gcloud app services set-traffic</code>“ and a number of flags here. Now if you look at these flags here, there’s one option you really need to note. It’s the one that says “IP_OR_COOKIE” options in the dash dash split by flag. We have to tell App Engine whether to split traffic using IP address splitting or cookies.</p>
<p>IP address splitting is easier to do. It will just make App Engine hash the request’s IP address from zero to 999 and then route based on whatever random value it gets. This isn’t as precise as cookie routing, though, because of how IP addresses tend to be somewhat ephemeral, particularly from cellphone traffic and from the public internet. IP address splitting is also bad for traffic coming from internal <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> services because those services tend to utilize a small set of internal IP addresses. That will get stuck to the same version of your app.</p>
<p>So for better precision, you should use Cookie-based splitting. The trade-off here is that it will take a bit more setup because the application will look for a specific HTTP request header. So you may need to make a code change in your app to deal with this, but it will help ensure you get a precise split for traffic.</p>
<p>And then finally, let’s talk a little bit about traffic migration. In the Standard App Engine environment, we can choose to migrate traffic either immediately or gradually. In the Flexible environment, we can only do it immediately. There’s no option for gradual migration. When we do an immediate migration, you’ll generally see a spike in latency, as it causes all instances of the older version of your service or services to shut down. For a latency-sensitive application, this could be a deal-breaker, as you could see requests hang or it can drop as the traffic is rerouted.</p>
<p>For the Standard environment, the solution is to use gradual migration. This is configured in your app.yaml file with this one setting here, “<code>inbound_services: - warmup</code>“. And with that, you are informed and ready to deal with migration, splitting, and deployment in the App Engine world.</p>
<p>Phew, okay, so we made it through a deep dive into App Engine environments and configuration and traffic. You’re almost ready to really do some damage. In the next short lesson, we’ll talk about autoscaling and deployment. If you’re ready, let’s get going. Cheers.</p>
<h3 id="Lectures-6"><a href="#Lectures-6" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Autoscaling-App-Engine-Resources"><a href="#Autoscaling-App-Engine-Resources" class="headerlink" title="Autoscaling App Engine Resources"></a>Autoscaling App Engine Resources</h1><p>Autoscaling App Engine resources. To understand how scaling works in App Engine, it’s important to first remember that even though we think of App Engine as serverless, in reality, all of our code must run on virtual instances somewhere within <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a>. So when we talk about scaling, we’re talking about scaling that underlying hardware, the virtual instances of GCP.</p>
<p>Now, first and foremost, we have to be aware of instance types. From App Engine’s perspective, there are two types of instances: dynamic and resident. Dynamic instances automatically shut down based on usage, while resident instances will run all the time, no matter what. The former is better for cost optimization, while the latter can improve app performance since you won’t have to wait for instances to restart.</p>
<p>Next, we should talk about scaling types. There are actually three types of scaling in App Engine: Automatic, Basic, and Manual. Automatic scaling is the most common type. It will create dynamic instances based on specific metrics, such as response latencies or request rate, and you can also specify a minimum number of idle instances that will run as resident instances to maintain a baseline.</p>
<p>So next, there’s manual scaling. As you can guess, this is done manually. This uses resident instances only. When set, App Engine will continuously run these instances irrespective of load. You can use manual scaling for temporary load spikes or performance tests.</p>
<p>And then, finally, there is what is known as basic scaling. When your application receives requests, dynamic instances come up. When the app becomes idle, all dynamic instances shut down, so, obviously, this is not suitable for latency-sensitive continuously running services. It is great, however, for intermittent work that is not latency-sensitive, such as the occasional user-initiated script or batch job or service. Basic scaling is not available in the flexible App Engine environment, so do keep that in mind.</p>
<p>And congratulations, that’s it, you’ve made it through all three of our rigorous lessons on App Engine. You have enough theory to launch a billion-dollar startup. Now, let’s go and put that theory into practice. Let’s have some fun. We’re gonna do a video demonstration where we will take our Hello World app to the next level. See you there.</p>
<h3 id="Lectures-7"><a href="#Lectures-7" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="App-Engine-Demo"><a href="#App-Engine-Demo" class="headerlink" title="App Engine Demo"></a>App Engine Demo</h1><p>Okay, welcome to our video demonstration for GCP App Engine. Now we’re gonna have some real fun in this little section here. We’re gonna actually play around a bit with a real app in the standard App Engine environment. Now, if you made it through the earlier four parts without too much trouble, you should have no problem following along with this demo, though, we do encourage students to actually try things out in their own <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> account, if possible.</p>
<p>So, there are gonna be basically three parts to this demo. First, we’ll quickly spin up a sample app in the standard environment. This will be identical to what we showed in part two, very quick. And then secondly, we will practice traffic splitting and migration by creating a second version of the service. So, that we’ll walk through how to configure traffic basically. And then finally, we’ll check out some scaling functionality, we’re gonna manually scale the app up and we’ll also go through the automatic and basic scaling system. We’ll just show how those are configured and that’s basically it.</p>
<p>So let’s get started. Welcome to our video demonstration of App Engine on GCP. We’re gonna have some real fun now. We’re gonna actually play around with a real app in App Engine using the standard environment. Now, if you made it through the earlier four parts without too much trouble, you should have no problem following along with this demo, we are going to encourage students to actually try things out in their own GCP account, if possible, but of course, feel free to just watch along. So, this demo has basically three parts.</p>
<p>First, we’ll review the how to spin up a sample app in the standard environment. This will be identical to what we showed in part two, we already have an app up and running for that. Secondly, we’ll practice traffic splitting and migration by creating a second version of the service. So, we’ll see the traffic shift. And then finally, we will check out some of the scaling functionality by manually scaling the app and walking through the automatic and basic scaling configuration systems. So that’s the basic plan.</p>
<p>So, now, let’s just review how we deploy a basic app. We start by ensuring that we have our project ID set in the environment. So, you’re gonna do an export project ID equals whatever your project name is. Here, it’s Test Project CA555. You can get your project ID and organization ID all from the dashboard pretty easily. So we’ll export that and what we need to do is get the actual App Engine code. We’ll just clone the sample project and that is from Google’s GitHub <a target="_blank" rel="noopener" href="https://github.com/googlecloudplatform/python-docs-samples/">directory</a>. So I do a git clone of that and then we will need to go into the directory with the App Engine configuration. So we’ll do this and that’ll take us into the Hello World app in standard App Engine, Python 3.7. Be sure to do the Python 3.7 version, there’s also a Python 2 version, but that’s pretty deprecated now.</p>
<p>So, once you’re there, you should see in the directory that it has the app.yaml, the main.py. That’s the actual Python code that we’re gonna run and a requirements file and a test file there. The app.yaml is what we’re interested in. That’s gonna, you know, be the actual configuration for App Engine. The only thing here now is the runtime definition, Python 3.7. And then the actual… The deployment command is pretty straightforward. We’re just gonna do gcloud app deploy to launch our app.</p>
<p>Now this one is already up. So it’ll go through it pretty quickly, but the very first time that you do this deploy, it might take a little while. You know, once it finishes, we should be able to go to the URL and see the code actually running. So, let’s just give this a second to complete. Okay and once that has completed, we can run this command, gcloud app browse to actually see the application in the browser. Sometimes you might see this error, did not detect your browser, go to this link instead, we can click on it and we can see it return “Hello world,’ which is really all the code is doing, we go into the main.py and we can see that it’s really just a server returning “Hello world.” That’s all it is.</p>
<p>So our app is up and running. Just like that, we have a basic app running in GCP using App Engine. So next, what we wanna do is to test how to do traffic splitting and migration and in order to do this, we’ll need a second version of our service and doing this is gonna require a little bit of file manipulation. Specifically, we’re gonna need to create two directories with the same service.yaml file and we’ll make a minor change in the Python code so that we can see that there are in fact, two different versions of the service running.</p>
<p>So, let’s go about creating those two versions of the service. The way we’re gonna do that is we’re going to create two directories. We’re gonna create a v1 and a v2 directory and then we’re, you know, we’ll see that we have them in the same directory as all of our code right now. So what we wanna do is copy all of our code into those directories. So we have a v1 and we will have everything in v2.</p>
<p>Now, it is important to copy everything. If you try to copy only the yaml and the Python code, it will fail. The requirements that TXT file is very important. If you look at it, you’ll see that it is what tells App Engine to install Flask and what version of it. So if you forget that, it’ll try to deploy an app, but it will be broken because it won’t have Flask. So make sure you do that. So, if we go into, let’s say, v2. and we look at our code here, what we’re gonna need to do is change the app.yaml file into a service.yaml file. So we can just change it to service.yaml. And then to make it its own… To make it a little bit more unique… Oh, so yeah, we keep the same configuration here, but to make the code different, we’re gonna go into the main.py and we’re gonna have it return something different. So instead of “Hello world,” we’ll say this is the other version. Keep it very clear.</p>
<p>So, now we can actually deploy this as another version of the service by doing a similar command, we’ll do gcloud app deploy and this time we’ll pass in service.yaml. And, again, it’ll use the same… It’s the same basic default service, but now it’ll have another version with this different code. So hit the deploy, we confirm, it’ll take a minute to come up. So let’s just wait for that.</p>
<p>Okay, so now that that has finished deploying, we can see again, gcloud app browse if we wanna get the URL for the service, but before we do that, just to verify that we have two versions running, in the console, we can check and see this. We can see it in two places, in the services page, there should be a two under the number of versions there. So we can click on that or we can click on versions and we can reload this. Sorry, here. We can see that if we refresh it, there are two versions here. One of them is getting 100% of the traffic, the other is not.</p>
<p>Now, if we do check the versions here, this is the one getting 100% of the traffic. If we click on it, it’ll return the service output, which is the other version, the new one instead of “Hello world.” If we click on this one, this is the older one that outputs “Hello world.” Now, this is not the official service URL. This is not the app URL. This is just for those individual versions of the service. If we look at the app URL, gcloud app browse, we will get this app URL, testprojectca555.appspot.com and it’ll give us this is the other version. It’ll do that because 100% of the traffic is going to the new version that we just deployed. You can see it has a more recent timestamp. So, the console gives us these two URLs to see the two versions of the service, but the service itself, remember the traffic allocation is what determines what a user will see.</p>
<p>So now we have to think about splitting the traffic and migration. So that’s gonna take a little bit of work, but nothing too tricky. So, let’s start by talking about traffic splitting. If we wanna do traffic splitting, we can do that from the command line, but it’s a little bit clearer in demo if we use the console. So, what we’re gonna do is click on traffic split here and remember that there are IP address and cookies splitting types. For when you need a very precise split, you use the cookie type, though it takes a little more configuration. The IP address one is a little bit simpler. There’s also this random option here, you can see. So we’re gonna pick that and we’re gonna click on, you know, the other version of the service here, these are the two versions running and we can decide what percentage we want. Let’s say we want 50&#x2F;50. So half the time, it should randomly choose the “Hello world” output and half the time it should choose the other one.</p>
<p>So we click save, it’ll update our traffic settings, just give it a moment to execute. Okay, that should be done. Now we go back to our Services page. Still, there are two versions there. Go to the versions page, we can see there’s a 50&#x2F;50 split. So, if that’s the case, we can test this pretty clearly by going to the app URL and half the time we should get hello world, half the time we should get this is the other version. So let’s click on it. There’s “Hello world.” Reload. This is the other version. Reload. “Hello world.” Reload. Well, there’s “Hello world” again, but as you can see, it’s randomly choosing 50&#x2F;50 between the two versions of the app. So we have the two versions of the service. So we have successfully split our traffic and the nice thing is that migrating back to a single version is similarly very easy.</p>
<p>We can do it through the web console with just a few clicks. What we do is we click on the version that we wanna migrate to, let’s say the newer one, we wanna get that back to 100% of the traffic, all you do is click migrate traffic and confirm. And then in a matter of seconds, 100% of the traffic will go to the newest version of the service. Executed, now we’re back at 100%. We should only get this is the other version now. If we reload it, we can see that that’s what’s happening. Right, there’s three times, so. So there you go, splitting and migration, pretty straight forward.</p>
<p>So let’s do some scaling. Scaling, there’s a few different versions of scaling within App Engine. In the standard environment, the easiest one to test since it won’t require any traffic manipulation, it would be manual scaling and manual scaling, we can configure at the level of individual services by just going to our service.yaml and what we’re gonna do is add a little bit of configuration.</p>
<p>Now one thing to note, another reason we’re showing manual scaling is that automatic scaling is enabled by default in the standard environment. There’s also the basic scaling option, but for demonstration purposes, this is actually much neater, much cooler. So how do we add scaling? Well, what we do is we add the manual scaling config to our yaml here, and we’re gonna set that to instance count of, let’s say five. Let’s say we want five instances backing our app. So what we do is we edit that and we redeploy it and we should see it. Oh. Actually, we have a light slight error there. We wanna make that into instances. Sorry. And then that should come up with five instances behind our app. So let’s just give that a sec to run and of course, be careful about the name of your configuration, instances not instance.</p>
<p>Okay, so the deploy completed and as we can see, a third version of the service came up because we did the app deploy again and this version will have five instances of traffic behind it, five instances behind it to manage the traffic. We can see here, they all just came up around the same time. So, the scaling is actually pretty fast. You’ll recall from the lesson that there is an option for more gradual scaling if you want or gradual migrations, but we’re doing just immediate changes here with the deploy command.</p>
<p>Now we can also migrate back with the same method by just deleting that configuration. We can go into service.yaml and just kill that and then just deploy it again. And again, by default, you know, we create a new service and all traffic goes to that… A new version of the service and all traffic will be split toward that new version. Now that’s a default that you can override by changing the splitting options or by migration.</p>
<p>So, let’s see if the instances go away for this new version. We’re doing our update, let’s give that a second to run. Okay, so the update completed. So now, again, if we go to our versions here, we’ll refresh, we’ll see there’s a fourth version now. It’s getting all the traffic and if we look at our instance count, there are no instances. They’re all gone because the scaling config was deleted.</p>
<p>So we can see, it’s really that simple to manually adjust the scaling with your App Engine services. So that’s basically it, congrats. That’s it for our App Engine demo. We’ve done quite a bit in just a few minutes. We spun up a basic app, we created multiple versions, we split traffic, we ran a migration, we scaled everything up and down, pretty cool stuff. You should have a good basic understanding. Thanks for toughing it out and cheers.</p>
<h3 id="Lectures-8"><a href="#Lectures-8" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>So congratulations! You made it! Give yourself a pat on the back because it has been a long and tough ride. We went through a lot of material so before we start celebrating let’s take a minute to briefly review what we’ve learned.</p>
<p>By completing this course you should have a very thorough understanding of how to configure and manage GCP’s App Engine and Kubernetes Engine services. You should be ready to spin up a cluster in GKE, create a Kubernetes deployment, and set up an autoscaling in App Engine with a basic app. Basically you should be ready to set up or take over administration of a <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/google/">GCP</a> compute environment. For clarity’s sake, let’s review the two learning objectives.</p>
<p>Number one: Learn how to manage and configure GCP Kubernetes Engine resources. We did this in section one. We not only covered how to manipulate cluster configuration using the web console and SDK, but we also reviewed basic Kubernetes concepts just in case you aren’t familiar with them.</p>
<p>Number two: learn how to manage and configure GCP App Engine resources. This was done in section two. We focused on setting up App Engine standing environment and autoscaling to help you establish that truly serverless experience.</p>
<p>With these two learning outcomes solidified in your mind, you should now be ready to dig in and build your own applications from scratch. You should also have the conceptual foundation necessary to branch out to other infrastructure platforms if you’d like. Go you!</p>
<p>Now that you are done I’d like to end by inviting you to send feedback about the course to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>. We really appreciate your comments, questions, suggestions, really anything. Congratulations again on fighting through the whole course and good luck in your future endeavors.</p>
<h3 id="Lectures-9"><a href="#Lectures-9" class="headerlink" title="Lectures"></a>Lectures</h3><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/introduction/">Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-one-introduction/">Section One Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-concepts/">Kubernetes Concepts</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/cluster-and-container-configuration/">Cluster and Container Configuration</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/working-with-pods-services-and-controllers/">Working with Pods, Services, and Controllers</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/kubernetes-demo/">Kubernetes Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/section-two-introduction/">Section Two Introduction</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/creating-a-basic-app-engine-app/">Creating a Basic App Engine App</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/configuring-application-traffic/">Configuring Application Traffic</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/autoscaling-app-engine-resources/">Autoscaling App Engine Resources</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/app-engine-demo/">App Engine Demo</a> - <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/managing-google-kubernetes-engine-app-engine/conclusion/">Conclusion</a></p>
<h1 id="3Kubernetes-Concepts"><a href="#3Kubernetes-Concepts" class="headerlink" title="3Kubernetes Concepts"></a>3<strong>Kubernetes Concepts</strong></h1><p><a target="_blank" rel="noopener" href="https://cloud.google.com/kubernetes-engine/docs/">Kubernetes documentation</a></p>
<h1 id="4Cluster-and-Container-Configuration"><a href="#4Cluster-and-Container-Configuration" class="headerlink" title="4Cluster and Container Configuration"></a>4<strong>Cluster and Container Configuration</strong></h1><p><a target="_blank" rel="noopener" href="https://cloud.google.com/container-registry/docs/quickstart">Container Registry documentation</a></p>
<h1 id="6Kubernetes-Demo"><a href="#6Kubernetes-Demo" class="headerlink" title="6Kubernetes Demo"></a>6<strong>Kubernetes Demo</strong></h1><p><a target="_blank" rel="noopener" href="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app">GKE Documentation</a></p>
<h1 id="8Creating-a-Basic-App-Engine-App"><a href="#8Creating-a-Basic-App-Engine-App" class="headerlink" title="8Creating a Basic App Engine App"></a>8<strong>Creating a Basic App Engine App</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/googlecloudplatform/python-docs-samples/">Python Docs samples</a></p>
<h1 id="11App-Engine-Demo"><a href="#11App-Engine-Demo" class="headerlink" title="11App Engine Demo"></a>11<strong>App Engine Demo</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/googlecloudplatform/python-docs-samples/">Google GitHub directory</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/GCP-Cloud-Engineer-Managing-Networking-and-Compute-Resources-on-Google-Cloud-Platform-15/" rel="prev" title="GCP-Cloud-Engineer-Managing-Networking-and-Compute-Resources-on-Google-Cloud-Platform-15">
      <i class="fa fa-chevron-left"></i> GCP-Cloud-Engineer-Managing-Networking-and-Compute-Resources-on-Google-Cloud-Platform-15
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/GCP-Cloud-Engineer-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-17/" rel="next" title="GCP-Cloud-Engineer-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-17">
      GCP-Cloud-Engineer-Deploying-Containerized-Applications-on-Google-Kubernetes-Engine-GKE-17 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Section-One-Introduction"><span class="nav-number">2.</span> <span class="nav-text">Section One Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes-Concepts"><span class="nav-number">3.</span> <span class="nav-text">Kubernetes Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures"><span class="nav-number">3.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cluster-and-Container-Configuration"><span class="nav-number">4.</span> <span class="nav-text">Cluster and Container Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-1"><span class="nav-number">4.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Working-with-Pods-Services-and-Controllers"><span class="nav-number">5.</span> <span class="nav-text">Working with Pods, Services, and Controllers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-2"><span class="nav-number">5.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes-Demo"><span class="nav-number">6.</span> <span class="nav-text">Kubernetes Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-3"><span class="nav-number">6.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Section-Two-Introduction"><span class="nav-number">7.</span> <span class="nav-text">Section Two Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-4"><span class="nav-number">7.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Creating-a-Basic-App-Engine-App"><span class="nav-number">8.</span> <span class="nav-text">Creating a Basic App Engine App</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-5"><span class="nav-number">8.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Configuring-Application-Traffic"><span class="nav-number">9.</span> <span class="nav-text">Configuring Application Traffic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-6"><span class="nav-number">9.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Autoscaling-App-Engine-Resources"><span class="nav-number">10.</span> <span class="nav-text">Autoscaling App Engine Resources</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-7"><span class="nav-number">10.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#App-Engine-Demo"><span class="nav-number">11.</span> <span class="nav-text">App Engine Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-8"><span class="nav-number">11.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">12.</span> <span class="nav-text">Conclusion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lectures-9"><span class="nav-number">12.0.1.</span> <span class="nav-text">Lectures</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3Kubernetes-Concepts"><span class="nav-number">13.</span> <span class="nav-text">3Kubernetes Concepts</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4Cluster-and-Container-Configuration"><span class="nav-number">14.</span> <span class="nav-text">4Cluster and Container Configuration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6Kubernetes-Demo"><span class="nav-number">15.</span> <span class="nav-text">6Kubernetes Demo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8Creating-a-Basic-App-Engine-App"><span class="nav-number">16.</span> <span class="nav-text">8Creating a Basic App Engine App</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11App-Engine-Demo"><span class="nav-number">17.</span> <span class="nav-text">11App Engine Demo</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
