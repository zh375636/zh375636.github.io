<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to this, the second, course in Cloud Academy’s LPIC 1 certification prep series. This course will focus on understanding Linux system architecture, how Linux identifies and manag">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-LPIC-101-LPIC-1-101-Linux-certification---System-Architecture-2-of-5-2">
<meta property="og:url" content="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to this, the second, course in Cloud Academy’s LPIC 1 certification prep series. This course will focus on understanding Linux system architecture, how Linux identifies and manag">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T05:08:44.000Z">
<meta property="article:modified_time" content="2022-11-21T00:16:50.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux-LPIC-101-LPIC-1-101-Linux-certification---System-Architecture-2-of-5-2 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-LPIC-101-LPIC-1-101-Linux-certification---System-Architecture-2-of-5-2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-19 01:08:44" itemprop="dateCreated datePublished" datetime="2022-11-19T01:08:44-04:00">2022-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 20:16:50" itemprop="dateModified" datetime="2022-11-20T20:16:50-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LPIC-1-101/" itemprop="url" rel="index"><span itemprop="name">LPIC-1-101</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-System-Architecture-2-of-5-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to this, the second, course in Cloud Academy’s LPIC 1 certification prep series. This course will focus on understanding Linux system architecture, how Linux identifies and manages its hardware environment and how you can control and direct that process to achieve the results hereafter.</p>
<p>Through the videos of this course, we’ll learn how to identify existing hardware peripherals and how to use Linux file systems and kernel modules to find, add or remove device drivers. We’ll learn about the Linux boot process and each of the three historically significant process managers, Init, Upstart and System D.</p>
<p>We’ll explore how to use system tools to ensure that computers boot properly and to figure out what’s going on when they don’t. We’ll learn about changing the system states through run levels and process management.</p>
<h1 id="Identifying-hardware-peripherals"><a href="#Identifying-hardware-peripherals" class="headerlink" title="Identifying hardware peripherals"></a>Identifying hardware peripherals</h1><p>If you want to really understand how an operating system works, you’ll need to have a good sense of how it connects, tracks, and controls its hardware environment. Linux, when it boots, or experiences some change to its host hardware profile, will maintain a system of virtual - or pseudo - files describing the devices and drivers it can see. By “virtual files” I mean regular text files that are saved to volatile memory rather than to a disk drive. Their contents will be lost whenever the system is shut down, but that’s no big deal: because the boot process will create appropriately updated versions when it starts up the next time.</p>
<h3 id="Linux-virtual-filesystems-and-hardware-peripherals"><a href="#Linux-virtual-filesystems-and-hardware-peripherals" class="headerlink" title="Linux virtual filesystems and hardware peripherals"></a>Linux virtual filesystems and hardware peripherals</h3><p>The Linux kernel writes hardware and driver data to virtual files in two separate directory hierarchies. Everything under &#x2F;proc (for “process”) is part of the sysctl system, and the &#x2F;sys directory contains the sysfs - fs, by the way, stands for filesystem. What’s the difference between the two? Apparently sysfs - being a bit more recent in design - is built using a more sophisticated structure. So, for instance, many files under &#x2F;sys are actually nothing more than symbolic links (symlinks) pointing to the devices themselves. We’ll learn more about symlinks and how they work in a later video.</p>
<p>Let’s take a quick look at the &#x2F;sys directory tree. Most of the files that will be of interest to us live beneath &#x2F;sys&#x2F;class where you’ll find all devices organized by type (or, class).</p>
<p>So if we drill down through &#x2F;printer&#x2F;lp0 - which is the designation Linux has given my Brother laser printer - and then down further through &#x2F;subsystem &#x2F;lp0 and &#x2F;device, we’ll be able to take a look at details of my printer configuration by reading - using cat - the id, resources, and options files.</p>
<p>To explore my hard drive configuration, you would go to &#x2F;sys&#x2F;class&#x2F;block - which is where block devices are described. Since my primary drive is designated as sda1, we’ll follow through to &#x2F;sda and then &#x2F;sda1. From here we could examine details like partition, size, and status.</p>
<p>The &#x2F;proc system has a somewhat different design. To learn about some system drives, for instance, we could move to &#x2F;proc&#x2F;sys&#x2F;dev [ls] and then down to cdrom. Reading the contents of the info file tells us that our CDRom drive - it’s actually an RW DVD - is called SR0 and runs at 12x speed.</p>
<p>But if we head back up to the &#x2F;proc top directory, we’ll also see files like cpuinfo - which, using the text reader program less, identifies the type of processor we’re running: in my case, since I’m using a quad core processor, each of the four cores is listed separately. Similarly, the devices file contains information about block devices like my hard drives.</p>
<p>Beyond the files in &#x2F;sys and &#x2F;proc, the &#x2F;dev directory contains another pseudo file system created during the boot process. As you can probably tell from their filenames, each of these files represents a specific hardware device. We’ll spend more time with the files in &#x2F;dev when we learn about mounting and unmounting devices in later videos.</p>
<p>Just to quickly review what we’ve seen: Linux populates three pseudo filesystems with configuration data defining your hardware environment. Information about physical devices and their drivers can be easily found beneath the &#x2F;sys directory - and especially beneath &#x2F;sys&#x2F;class - and beneath &#x2F;proc…&#x2F;sys…&#x2F;dev. The &#x2F;dev directory contains symbolic links to actual devices through which you can control their use and accessibility.</p>
<h3 id="Using-Linux-command-line-tools-and-modules-to-manage-hardware"><a href="#Using-Linux-command-line-tools-and-modules-to-manage-hardware" class="headerlink" title="Using Linux command line tools and modules to manage hardware"></a>Using Linux command line tools and modules to manage hardware</h3><p>Besides those virtual files, you can access the same system hardware and driver information using some command line utilities. So, for instance, if you wanted to list all the PCI devices currently known to your system, you could simply run lspci - where “ls” stands for list. Here, for instance, you can see my Radeon video controller and, down at the end of the list, my two network cards. Running lspci with the -vvxxx argument will display a great deal more information and can be very useful for diagnosing missing or misbehaving devices. V stands for verbose, and xxx will show a hexadecimal dump.</p>
<p>Running lsusb will display all the registered usb devices, including my keyboard and mouse.</p>
<p>lsmod will display all the kernel modules that are currently loaded. In fact, lsmod is really nothing more than a nicely formatted output of the &#x2F;proc&#x2F;modules file.</p>
<p>I should take a moment right now to explain what a module is. The Linux kernel is, as you might imagine, the core of the operating system, containing many of the basic instructions for managing processes and system resources. But, in order to extend the kernel’s control over peripheral devices, individual modules can be added or removed without directly effecting the kernel or its operations. We’ll learn more about actually loading and removing modules in the next video. While details shouldn’t concern us right now, you should at least be aware of the D-bus message bus system that permits integration and proper coordination between processes running desktop - rather than server - applications</p>
<p>To review: lspci will list all devices connected to the PCI bus, lspci -vvxxx will include more detailed information in its output, and lsmod will display currently loaded kernel modules. By the way, it can be worth knowing that running lshw - preferably with sudo - will output all your hardware specs at once.</p>
<p>Until now, we’ve discussed the way that Linux manages devices. But you must also be aware of the various tools employed by Linux to handle processes: that is, how access is given to individual programs so they can play nicely with each other and share system resources.</p>
<p>In the beginning there was init. Init acted like an air traffic controller, waving processes through busy air space and determining the order by which waiting programs would be permitted to take off. Init’s greatest weakness was that it could only process actions synchronously, which proved very inefficient.</p>
<p>Somewhere around 2006, the developers behind Ubuntu released an asynchronous replacement for init called Upstart, which has been the mainstay of some of the biggest distributions in the business. Most. But not all. Over the past year, after some rather excited debate and more than a few spoiled friendships, Upstart’s competition, systemd, won over so many hearts and minds, that even Ubuntu has now agreed to make the switch. The final move took place with the release of Ubuntu 15.04. We’ll talk about some systemd tools later in this series.</p>
<h1 id="Managing-hardware-peripherals"><a href="#Managing-hardware-peripherals" class="headerlink" title="Managing hardware peripherals"></a>Managing hardware peripherals</h1><p>Many of the most painful memories I have of those dark days before I discovered Linux, involved trying to figure out why I sometimes couldn’t get even integrated sound cards or network interfaces to work. It’s possible that the way Microsoft handles such things has improved over the years, but creating an operating system that can anticipate and successfully identify a very wide range of peripheral devices is no small accomplishment. In my experience, Linux, by shipping with large module libraries and by separating the kernel from the device modules - which, by the way, has always allowed most changes to complete without the need for a reboot - has always been ahead of the game.</p>
<h3 id="Understanding-and-managing-Linux-system-modules"><a href="#Understanding-and-managing-Linux-system-modules" class="headerlink" title="Understanding and managing Linux system modules"></a>Understanding and managing Linux system modules</h3><p>For a device to work with Linux, it must have a defining module that’s been loaded into the kernel. Modules for the vast majority of devices on the market today are already installed on Linux distributions by default. For those modules that aren’t already installed, there are excellent management tools we’ll see in a moment.</p>
<p>First of all, though, you can list all the modules currently loaded into the kernel using lsmod, but Linux installations will usually also keep all kinds of modules that you might one day need under &#x2F;lib&#x2F;modules. For some reason, many systems now no longer support the really handy modprobe -l tool - which listed all modules that were potentially available. Instead, you’ll have to use something like this: where “find” will search the specified directories for files containing the ko extension. Let’s take a look at &#x2F;lib&#x2F;modules so we can better understand what uname -r does. Each of the directories that we can see here is named after a specific Linux kernel release. 3.13.0-49 is, right now, the most recent kernel I’ve got installed on the machine. Wisely, Linux will save older versions of the kernel on the system - along with their device modules - in case something should ever go wrong with an upgrade and we should ever need to take a step back to a previous point in time.</p>
<p>Uname, as you can see, is a Linux command that outputs the current system which, predictably, is Linux. Uname -r will output the current kernel version. Therefore, if you want to use find to display all the available modules associated with our current kernel, you would use uname -r to insert the kernel name into our directory location.</p>
<p>This ability to combine system information with basic commands is part of the power - and the fun - of Linux. So while getting rid of the simple and straighforward modprobe -l function seems to have been just a little bit odd, we’re certainly not left without other perfectly usable options.</p>
<p>Now that we’ve learned how to find modules - both loaded and available - we should also know how to add or remove modules. This can be really useful when you’re working with very new hardware whose drivers haven’t yet made it into standard Linux installations and need to be added manually. It can also save the day when you’re working with hardware that’s so old it’s no longer supported. Some time ago, I found myself working with modules while trying to get a mini-pci WiFi radio working with some development boards running a very minimal Debian installation. Downloading and adding the right module to the kernel worked nicely - although I should warn you that kernel upgrades will ignore the module and you’ll need to do it all over to get your device running again.</p>
<p>So let’s try it out by installing the lp module. Of course, since it happens to be installed already, We’ll have to remove it first. We’ll begin with lsmod and grep, to confirm that lp is currently loaded. Then, as the sudo admin, we’ll run modprobe -r to remove the module. Another round of lsmod should convince us that that worked. And now we’ll reload it…run lsmod once more, and everything is once again just as it should be.</p>
<p>Let’s review. You can use lsmod to list all the modules currently loaded on the kernel. A clever use of the “find” command will list all available modules. Modprobe followed by the module name (without its .ko extention) will load a module and modprobe -r will remove it. By the way, insmod is another command you can use to load a module, and rmmod will, like modprobe -r, remove a module. udev, Linux dynamic device management, is the system tool that, you guessed it, manages devices. You can manually change some udev settings through .rules files kept in one of three directories: Udev will read files from these three directories in that order, with precedence given to the one read earliest. Since &#x2F;run is a pseudo filesystem that’s re-written whenever the computer is rebooted, you can use rules files in &#x2F;run for changes you want to stay in effect only for this session.</p>
<p>Let’s take a look at &#x2F;etc&#x2F;udev on my system. You can see my printer’s scanner rule - which was provided by Brother itself to allow their all-in-one to run on Linux. This rule has the number 40 - meaning it will be executed by udev before the other two rules with higher numbers. If, for some reason, you ever wanted to make sure that this rule was executed later, you could simply change the number in the filename to, say 90.</p>
<p>Let’s use cat to actually read the 70-persistent-net.rules file. The file points to my two network interface cards, identifying their MAC addresses and, significantly, assigning them system designations: eth0 and eth1. If you like, you can edit either of these entries to give them new values, say eth3 or em0. As I discovered some time ago, replacing a failed network card might cause udev to give it a designation that’s not the same as the one used by the original card. That could cause services to break if you have software that’s expecting to find the network through eth0, but that’s now been moved to eth3. Editing this rule can return your system to its original, happy working state.</p>
<p>Since we’ve mentioned default device designation (like eth0), it’s probably a very good time to review the way that Linux assigns names to all its devices. As we’ve seen, network interfaces are given eth names, beginning with eth0 and moving up. Recently, some systems have changed that to em0, em1 and so on.</p>
<p>Hard disk drives (including solid state drives) are usually named sda, sdb, etc. However, individual partitions on a disk might be named sda1, sda2, sda3, etc. Floppy drives - if you can still find any - are usually called fd0 and fd1. And CDRom or DVD drives will usually be designated sr0 and sr1.</p>
<p>Again, all of these designations are controlled and managed by udev, and have symbolic links that you can find in the &#x2F;dev directory. If you’re unsure how, say, Linux has named a USB data drive you’ve just inserted, you can view the dmesg log (by running dmesg from the command prompt) and look for recent entries. In this case, we can easily see the the USB drive that I just plugged in. lsusb will also list all your USB devices and hubs. The drive I just plugged in is mentioned here.</p>
<h3 id="Accessing-environment-data-on-AWS-instances"><a href="#Accessing-environment-data-on-AWS-instances" class="headerlink" title="Accessing environment data on AWS instances"></a>Accessing environment data on AWS instances</h3><p>Most of what we’ve seen regarding system hardware in these first two videos of this course will have little connection to the cloud computing world because managing system hardware on an Amazon Web Services virtual machine is largely the responsibility of our host, Amazon. Still, AWS does give you access to a great deal of system information through Instance Metadata, which you can access from a shell session inside the instance using the curl tool and the special IP address, 169.254.169.254.<br>This request, for instance, will return a list of available metadata categories. Amazon documentation provides plently of guidance for finding and making use of metadata. And don’t worry, we’ll learn much more about using ssh to access AWS instances - and other resources - later in this series.</p>
<h1 id="How-Linux-boots-your-computer"><a href="#How-Linux-boots-your-computer" class="headerlink" title="How Linux boots your computer"></a>How Linux boots your computer</h1><p>Familiarity with the boot process can be hugely important for properly managing your systems - and particularly for troubleshooting when something doesn’t work the way you expect. It just makes sense: a user complains that his PC isn’t booting. But that can mean all kinds of things. If you’re not getting any display on your monitor, it’s likely a hardware problem and you should consider replacing failed components - or maybe just properly plugging in a cable. If you’re stuck at a later stage, the kinds of intervention you’ll require to correct a bootloader configuration issue will be quite different from what you might do to fix a corrupted filesystem. But if you have no idea how the system is supposed to work, how will you ever know the difference?</p>
<p>This video is meant to cover the basic process of booting a computer running Linux, introducing you to your firmware (BIOS) bootloader (GRUB), and filesystem. We’ll go into greater detail for each of these in future videos, both in this course, and in future courses in this series.</p>
<h3 id="Understanding-the-Linux-boot-process"><a href="#Understanding-the-Linux-boot-process" class="headerlink" title="Understanding the Linux boot process"></a>Understanding the Linux boot process</h3><p>For our purposes, the very first thing that happens when you push your computer’s power button is that your motherboard’s build-in firmware BIOS (Basic Input&#x2F;Output System) takes an inventory of all the hardware that’s currently running on the computer, identifies which drive contains the boot software, and loads the Master Boot Record (MBR) of that drive. The MBR makes up only the first 512 bytes of its drive and uses that space to describe the disk partitions and how to start loading the operating system.</p>
<p>When you originally installed Linux on your computer, the installation process automatically created all necessary partition tables, along with the MBR.</p>
<p>BIOS (or UEFI) will execute GRUB (the GRand Unified Bootloader) Stage 1 from the MBR, which reads the details of the boot drive filesystem and launches either GRUB stage 1.5 (which would itself load GRUB stage 2) or GRUB stage 2 directly. GRUB stage 2 loads into memory, presents the user with menu choices if so configured, and executes the kernel and loads either the initrd or initramfs images.<br>The kernel will mount the root filesystem specified by GRUB and execute the &#x2F;sbin&#x2F;init program (giving init the process ID (PID) of 1). The kernel will use initramfs (or initrd) until the real filesystem is fully booted.</p>
<p>I should mention that SysVinit manager’s &#x2F;sbin&#x2F;init file continues to exist even on distributions using the newer Upstart or systemd process managers although, at least in the case of systemd, only as a symlink to systemd itself.</p>
<p>Once the operating system has been mounted and loaded into memory, the environment run level specified by boot parameter is executed. Linux allows you to choose between seven - well, actually six - running modes: run level 0 - which instructs the machine to shutdown - could hardly be called a “running” mode.</p>
<p>Each run level is defined by files found within appropriately named directories, like &#x2F;etc&#x2F;rc0.d - which obviously controls run level 0, or &#x2F;etc&#x2F;rc1.d - which controls run level 1. We’re going to discuss run levels and how to manage them in a coming video. As far as we’re concerned right now, it’s your startup configuration that determines the run level you’ll eventually be given once the boot process is complete.</p>
<p>You probably noticed that I mentioned UEFI - Intel’s Unified Extended Firmware Interface - just before. While you don’t have to know anything about this for the LPIC exam, at some point, you’ll probably run into machines built with UEFI - a replacement for BIOS. Because of incompatibilities between UEFI and BIOS, many PCs shipped with more recent Windows releases will not make it easy for you to load Linux without first destroying the Windows install. While that has caused many serious headaches, I can say that the developers for a growing number of Linux distributions have adapted nicely, and configuring a dual-boot, Linux-Windows computer is becoming easier all the time.</p>
<h1 id="Managing-and-troubleshooting-the-boot-process"><a href="#Managing-and-troubleshooting-the-boot-process" class="headerlink" title="Managing and troubleshooting the boot process"></a>Managing and troubleshooting the boot process</h1><p>In the previous video we explored the Linux start up process and the roles played by various resources. In particular, we mentioned the contributions of the GRUB bootloader and the kernel. Now we’re going to learn how to manage the process as it moves through the GRUB stage, and also how to listen to the kernel when it tries to tell us about problems it encounters along its journey.</p>
<h3 id="Understanding-and-managing-the-GRUB-bootloader"><a href="#Understanding-and-managing-the-GRUB-bootloader" class="headerlink" title="Understanding and managing the GRUB bootloader"></a>Understanding and managing the GRUB bootloader</h3><p>Depending on your boot settings, the GRUB menu may or may not be visible for a few seconds as your computer starts up. If it’s not visible, you can manually cause it to display by repeatedly clicking on the right Shift key during the early boot stages. If that doesn’t work, then you can always manually abort the startup while it’s in progress (by pressing the power button for five seconds) and the GRUB menu should appear the next time you boot.</p>
<p>Once you’re in, you will be presented with a number of boot options. The default will be a full, normal boot of the latest version of your main operating system. There might also be alternate operating systems and a couple of memory tests - for troubleshooting RAM. </p>
<p>Pressing the “e” key will allow you to edit the boot parameters of your default option. We’ll come back to that in a minute. Highlighting the Advanced Options item with your arrow key and then pressing enter will reveal a number of further options, including booting to older kernels - something that can be especially useful if a recent upgrade has gone wrong. These kernel files, by the way, actually live in the &#x2F;boot directory.</p>
<p>There are also recovery mode options for each kernel version that provides a menu of troubleshooting tools to rescue a damaged installation. Pressing “c” or ctrl-c, by the way, will give a limited command line interface.</p>
<p>But let’s get back to the main GRUB menu and press “e” for edit. Feel free to edit any of the parameters you see here. Just remember: anything you do may well render your computer unbootable. Fortunately, as Linux system administrators, you can easily access the tools you’ll need to edit yourself out of any trouble you’ve caused.</p>
<p>Here are a couple of examples. Look at the Linux line towards the bottom. The vmlinuz-3.13 value points to the latest Linux kernel available on the system. The value of root is the identifier for my hard drive. Either of these values can be changed.</p>
<p>You could also add a line like rw init&#x3D;&#x2F;bin&#x2F;bash to boot into a root shell session that will allow you full write access to the whole filesystem. This is one way to restore key system files and recover from a non-bootable condition. If you’re uncomfortable leaving your computer open to such access, you might consider protecting it with a BIOS password.</p>
<p>To review, you can force access to the GRUB boot menu by hitting the right shift repeatedly during start up. “e” will send you to a simple text editor where you can edit the boot parameters of a particular GRUB item. “c” will send you to a limited command line (from which esc will send you back to the main GRUB menu). And selecting a recovery mode option from the Advanced Options menu will provide a list of utilities suited for recovering from some system problem.</p>
<h3 id="Diagnosing-boot-problems-in-Linux"><a href="#Diagnosing-boot-problems-in-Linux" class="headerlink" title="Diagnosing boot problems in Linux"></a>Diagnosing boot problems in Linux</h3><p>If something does fail to load properly during the boot process, you’ve got lots of good options. I’m not sure if there’s anything that happens on a Linux system that doesn’t leave behind some kind of record in the logs - most of which live happily in &#x2F;var&#x2F;log. Now I can hear some of you complaining that if the system won’t properly boot, then what good are inaccessible log files? To which the answer is: but they ARE accessible. You will often be able to get in using one of the recovery mode options we described before. But, assuming you didn’t encrypt your filesystem when you installed it, you can also boot your PC to a Live Linux session using a DVD or USB stick containing ISO images of any of the popular Linux distributions, or using a super lightweight purpose-built utility distribution like SystemRescueCD or PuppyLinux. Once that’s running, you can mount your main hard drive and set about exploring the log files to find out what went wrong, and then repairing your broken files.</p>
<p>The logs that most closely relate to boot problems are kern.log, boot.log, and dmesg. The problem with any of these is that a single boot will generate so many hundreds of lines of messages that they become nearly unreadable. So now’s a great time to properly introduce you to your new best friend, grep. </p>
<p>Let’s output the contents of the dmesg logfile using cat, but rather than writing directly to the screen as we normally would, we’ll pipe it using the pipe character (which you get by pressing shift and backslash together) and then type grep followed by the string we’d like to search for. Let’s say that we were alarmed during boot by a serious-sounding warning message about power&#x2F;level that appeared during boot. We can simply enclose the entire string in quotation marks and see what comes up.</p>
<p>That’s a whole lot easier to read! But it might not provide enough context to help. So we could also simply open dmesg within a text processing tool like “less” and then search for our string to see it in its full context. We can enter a search string by pressing the forward slash key, and then type in our string. We now have the warning’s full context. In this particular case that might not be all that helpful, but I’m sure you can see how it could.</p>
<p>If the dmesg, kern, and boot log files proved unhelpful, you should next turn to your favorite Internet search engine or perhaps the user forum associated with your Linux distribution…or even the ServerFault.com user forum. I am constantly amazed at how much genuinely useful information is readily available online.</p>
<p>While the range of hardware issues that should concern system administrators of virtual machines like Amazon EC2 instances is narrower than for physical deployments, they still matter. An Ubuntu virtual machine on Amazon Web Services will, by default, include most of the regular log files like boot.log, dmesg, and kern.log. However, AWS provides a more direct method for troubleshooting system issues. In the Instances dashboard of the AWS console, right click on the instance that concerns you, select Instance Settings, and then Get System Log. When you find a suspicious-looking entry, you can copy it and go to AWS’s “Troubleshooting Instances with Failed Status Checks” to see if there’s anything helpful there. Naturally you can also draw on all your usual troubleshooting resources in your search for a solution.</p>
<h1 id="Linux-run-levels-and-boot-targets"><a href="#Linux-run-levels-and-boot-targets" class="headerlink" title="Linux run levels and boot targets"></a>Linux run levels and boot targets</h1><p>A few videos back, when we were talking about managing the boot process, we briefly explored the history of Linux process management through init (SysVinit), Ubuntu’s Upstart, and the now dominant systemd. In this video, we’re going to see all three in action through the way they control system runlevels.</p>
<h3 id="Controlling-Linux-system-runlevels"><a href="#Controlling-Linux-system-runlevels" class="headerlink" title="Controlling Linux system runlevels"></a>Controlling Linux system runlevels</h3><p>A runlevel defines the operating system resources and access that are made available at a given time. Runlevel 0 will remove all access by shutting down the system altogether, while runlevel 3 will provide full access to all resources - depending of authorization, of course.</p>
<p>In the old init system, the default system runlevel was defined by an entry in the &#x2F;etc&#x2F;inittab file. The first line in this snippet - id:3:initdefault - sets the runlevel to 3.</p>
<p>Most Linux distributions no longer rely on the inittab file - something that’s a source of great confusion considering the wealth of older documentation that can still be found around the Internet and in book stores. Ubuntu’s Upstart hides its default runlevel definition in the rc-sysinit.conf file within the &#x2F;etc&#x2F;init&#x2F; directory. The entry that interests us will look something like env DEFAULT_RUNLEVEL&#x3D;2.</p>
<p>Upstart also uses scripts that, when run, control the behavior of specific services. Scripts compatible with older SysVinit processes can be found in &#x2F;etc&#x2F;init.d, while scripts used by Upstart processes are found in &#x2F;etc&#x2F;init&#x2F;</p>
<h3 id="How-systemd-controls-the-Linux-environment"><a href="#How-systemd-controls-the-Linux-environment" class="headerlink" title="How systemd controls the Linux environment"></a>How systemd controls the Linux environment</h3><p>While you have to know all these details for the LPIC exam - and in case you’re called on to work with older systems, as we’ve already meantioned, the clock is ticking on the relevance of init and Upstart, as the world is moving to systemd.</p>
<p>So let’s talk about systemd. For this shell session, we’ve left Ubuntu behind and are now enjoying Fedora - the earliest major distribution to adopt systemd. We’ll begin by noting that systemd itself doesn’t focus directly on overall system runlevels, but on the status of specific processes. Systemd works with files called Units, each of which describes in plain text a service, device, socket, or mountpoint.</p>
<p>We can manually manage units in the &#x2F;etc&#x2F;systemd&#x2F;system directory, while packages install their unit files in &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system. As an example, let’s take a look at &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tmp.mount which points to an available temporary directory created as a virtual tmpfs where other processes can safely dump their short-term data. The location of this directory is &#x2F;tmp - a common directory that most Linux processes expect to be able to access.</p>
<p>Systemd comes with a couple of really useful tools to help diagnose boot problems: systemd-analyze tells you how long - in seconds - each part of the startup process took. You can obviously use this to narrow down your search for whatever it might be that’s taking more time than it should. Systemd-analyze blame will show you now long - in miliseconds - each specific unit - whether a service, mount, or socket - took to load.</p>
<p>However, the command line utility that does most of the heavy lifting for systemd is systemctl. To give you an idea how this works, we’ll play with just a few examples here. systemctl list-units will, as you might expect, list key information about all the units that are currently running. Since the list is quite long, you might want to narrow down your search using your old friend grep:</p>
<p>Let’s try activating a service. We’ll use the Apache webserver, known in the Fedora world as httpd. Since Apache is a service, we’ll identify it by appending .service to its name. First, let’s see if it’s running already. It’s not. Next we’ll use the enable command to instruct systemd to run Apache each time the system boots. But that won’t get it going until we actually restart the system. If we just can’t wait, we’ll use start to launch Apache right away. And just to confirm that it is actually functional, we’ll run list-units once more, again grepping for httpd</p>
<p>It looks good.</p>
<p>That’s pretty much what you’ll need to know about systemd for the LPIC exam. Let’s review. systemd manages services, mountpoints, devices, and sockets through text files kept in either &#x2F;etc&#x2F;systemd&#x2F;system or &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;. systemd-analyze will display each part of the startup process took, and systemd-analyze blame breaks that down further to the service level. systemctl list-units will display all running processes, systemctl enable will force a process to load at start-up, systemctl start will start a specified process immediately and, while we’re on the topic, systemctl stop will stop a specified service.</p>
<p>Now we can return to Ubuntu to describe the ways you can control system wide runlevels that are universal to all process managers. In a previous video we showed how, by pressing “e” from the GRUB menu, we would be able to edit the boot parameters. So, to illustrate, by adding the word “single” to the end of the kernel command line, Linux will start up in single-user mode rather than multi-user. Single-user mode is often helpful for emergency recovery efforts. You can achieve the same result from the command line of a running session with telinit 1 - for which you’ll need admin powers. You can power down the system using telinit 0, or sudo shutdown -h now - where “h” stands for “halt” and “now” tells Linux to close up shop immediately.</p>
<p>The only runlevel-related topic left to cover is communications. It’s all very nice to have the power to control processes and to shutdown powerful servers, but you’re not going to make a lot of friends if you don’t warn all the other users who happen to be logged in from their own terminal sessions and doing their work.</p>
<p>Assuming that all logged in users are actually looking at their terminals when you run a telinit or shutdown command - and, considering how many windows most people can have open at a given time, that’s not necessarily a particularly strong assumption - Linux will automatically send a warning for you.</p>
<p>I’ll demonstrate how this works while logged in to two separate user accounts on a single LXC container. The larger window in the background is logged in as the normal user Tony, and the smaller window in the foreground is an admin user. This way we can simultaneously watch the terminals of both. As admin, I’ll run sudo shutdown -h 2 …which will halt the system in two minutes. Notice how the shutdown message is displayed for both accounts. Because I don’t really want to shutdown in two mintues, I’ll hit ctrl-c to cancel the action.</p>
<p>Now, besides messages that will automatically accompany shutdown (or telinit) commands, Linux also provides “wall” to permit communication between users. In truth, while the LPIC exam is mostly interested in wall as a tool to keep your users up to date on your nefarious plans to change their work environment, it can also be used for more general communications. I’ve created a text file that I will read using cat but, instead of displaying it to the screen, I’ll pipe it to wall, which will send it to the screen of every user currently logged in. I guess you can think of “wall” as kind of a prehistoric social networking tool.</p>
<p>To review, adding an argument (like single) to the kernel command line in GRUB will control its startup mode. telinit and shutdown offer similar control from the command line of a running machine. You can schedule a shutdown or reboot using something like sudo shutdown -r 5 - which will cause a reboot in five minutes. And piping a text file to wall will display text to all logged in users.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Introduction-1-of-5-1/" rel="prev" title="Linux-LPIC-101-LPIC-1-101-Linux-certification---Introduction-1-of-5-1">
      <i class="fa fa-chevron-left"></i> Linux-LPIC-101-LPIC-1-101-Linux-certification---Introduction-1-of-5-1
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/19/Linux-LPIC-101-LPIC-1-101-Linux-certification-Boot-and-Package-Management-3-of-5-3/" rel="next" title="Linux-LPIC-101-LPIC-1-101-Linux-certification---Boot-and-Package-Management-3-of-5-3">
      Linux-LPIC-101-LPIC-1-101-Linux-certification---Boot-and-Package-Management-3-of-5-3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Identifying-hardware-peripherals"><span class="nav-number">2.</span> <span class="nav-text">Identifying hardware peripherals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-virtual-filesystems-and-hardware-peripherals"><span class="nav-number">2.0.1.</span> <span class="nav-text">Linux virtual filesystems and hardware peripherals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Linux-command-line-tools-and-modules-to-manage-hardware"><span class="nav-number">2.0.2.</span> <span class="nav-text">Using Linux command line tools and modules to manage hardware</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Managing-hardware-peripherals"><span class="nav-number">3.</span> <span class="nav-text">Managing hardware peripherals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Understanding-and-managing-Linux-system-modules"><span class="nav-number">3.0.1.</span> <span class="nav-text">Understanding and managing Linux system modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-environment-data-on-AWS-instances"><span class="nav-number">3.0.2.</span> <span class="nav-text">Accessing environment data on AWS instances</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-Linux-boots-your-computer"><span class="nav-number">4.</span> <span class="nav-text">How Linux boots your computer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Understanding-the-Linux-boot-process"><span class="nav-number">4.0.1.</span> <span class="nav-text">Understanding the Linux boot process</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Managing-and-troubleshooting-the-boot-process"><span class="nav-number">5.</span> <span class="nav-text">Managing and troubleshooting the boot process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Understanding-and-managing-the-GRUB-bootloader"><span class="nav-number">5.0.1.</span> <span class="nav-text">Understanding and managing the GRUB bootloader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diagnosing-boot-problems-in-Linux"><span class="nav-number">5.0.2.</span> <span class="nav-text">Diagnosing boot problems in Linux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-run-levels-and-boot-targets"><span class="nav-number">6.</span> <span class="nav-text">Linux run levels and boot targets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Controlling-Linux-system-runlevels"><span class="nav-number">6.0.1.</span> <span class="nav-text">Controlling Linux system runlevels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-systemd-controls-the-Linux-environment"><span class="nav-number">6.0.2.</span> <span class="nav-text">How systemd controls the Linux environment</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
