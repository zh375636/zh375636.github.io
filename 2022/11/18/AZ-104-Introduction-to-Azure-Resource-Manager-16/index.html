<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course IntroductionHi, and welcome to this introduction to this Azure Resource Manager course. My name is Hallam Webber and I will be your instructor for this course. This is a beginner’s course that’">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-104-Introduction-to-Azure-Resource-Manager-16">
<meta property="og:url" content="https://example.com/2022/11/18/AZ-104-Introduction-to-Azure-Resource-Manager-16/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course IntroductionHi, and welcome to this introduction to this Azure Resource Manager course. My name is Hallam Webber and I will be your instructor for this course. This is a beginner’s course that’">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T00:22:05.000Z">
<meta property="article:modified_time" content="2022-11-22T15:41:14.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AZ-104-Introduction-to-Azure-Resource-Manager-16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-104-Introduction-to-Azure-Resource-Manager-16 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AZ-104-Introduction-to-Azure-Resource-Manager-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-104-Introduction-to-Azure-Resource-Manager-16
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 20:22:05" itemprop="dateCreated datePublished" datetime="2022-11-18T20:22:05-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-22 11:41:14" itemprop="dateModified" datetime="2022-11-22T11:41:14-04:00">2022-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-104/" itemprop="url" rel="index"><span itemprop="name">AZ-104</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AZ-104-Introduction-to-Azure-Resource-Manager-16/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AZ-104-Introduction-to-Azure-Resource-Manager-16/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Hi, and welcome to this introduction to this Azure Resource Manager course. My name is Hallam Webber and I will be your instructor for this course. This is a beginner’s course that’s aimed at those who want to know more about managing and configuring their Azure environment. So whether you’re in DevOps, IT support, or a developer that wants to get a better understanding of fast-tracking deployments, there is something in this course for you.</p>
<p>In this course, we will start with an overview of what Azure Resource Manager is and where it fits into the overall Azure picture. Then, we’ll get an understanding of why it’s important. and then, we will delve into some hands-on demonstrations of how you can use it to simplify what would otherwise be quite labor-intensive tasks. </p>
<p>As an introductory course, we will be learning by doing, to give you a basic “how-to” foundation in ARM templates. When we’re not in the Azure portal I’ll be using Visual Code with the ARM template extension which provides IntelliSense for Azure Resource Manager syntax. This is a very helpful tool if you’re not familiar with ARM instructions.</p>
<p>We welcome all comments and feedback, so please feel free to reach out to us at <a href="mailto:&#115;&#117;&#x70;&#x70;&#111;&#114;&#x74;&#64;&#x63;&#108;&#x6f;&#x75;&#100;&#x61;&#x63;&#97;&#100;&#101;&#109;&#x79;&#46;&#x63;&#x6f;&#x6d;">&#115;&#117;&#x70;&#x70;&#111;&#114;&#x74;&#64;&#x63;&#108;&#x6f;&#x75;&#100;&#x61;&#x63;&#97;&#100;&#101;&#109;&#x79;&#46;&#x63;&#x6f;&#x6d;</a> with any questions or comments. Let’s get started.</p>
<h1 id="Azure-ARM-Intro-Overview"><a href="#Azure-ARM-Intro-Overview" class="headerlink" title="Azure ARM Intro Overview"></a>Azure ARM Intro Overview</h1><p>So, what is Azure resource manager? Well, it is what it says it is. For a lot of people when they think of Azure they think of the complete Microsoft cloud product and all that it entails. But in reality, Azure is a collection of services or resources. When you sign up to Azure for the very first time as an organization with a new subscription and you log in to the portal there is nothing there. As you require services whether that’s a virtual machine, a web app, or database server you create instances of those resources. Azure resource manager is the glue behind-the-scenes that makes it substantially easier for you to deploy and manage all those different resources. </p>
<p>ARM in Context</p>
<p>You might think that the portal is Azure, but the portal is one of several interfaces to Azure resource manager. The portal is merely a graphical interface over the resource manager, which in itself is an interface to the various resources, especially in terms of deployment, and managing the order and dependencies involved in deploying various resources. Apart from the portal, there is also an API interface to Azure resource manager and more importantly for us, an SDK interface.</p>
<p>Command Line Interface</p>
<p>PowerShell for Windows and the Azure command-line interface are the preferred methods for interacting with Azure resource manager when it comes to large, complex, and repeated deployments. One thing I want you to take notice of on the slide is where authentication fits into the scheme. Because there are multiple ways to interact with resource manager authentication is handled directly by it. This is demonstrated by the fact that when you log into Azure through PowerShell or the Azure CLI a browser window will pop up and you can authenticate through that when using two-step authentication or a Microsoft account.</p>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>As we can see here Azure resource manager is mostly used when managing resources within a resource group. All resources are created within a group even if they are spread over multiple geographical regions. By grouping resources, you can perform actions on all the resources in that group at one time. A simple example would be creating a database server with databases and a web app service for some testing and then deleting all of them at one time by deleting the resource group that contains them. Having said that depending on the type of billing account you have with Microsoft you can also create subscriptions and management groups through resource manager.</p>
<p>Why You Need to Know ARM</p>
<p>But why do you need to know about Azure resource manager? After all, the portal works just fine and is easy enough to use. Infrastructure as code is the reason. In the cloud, hardware does not exist; everything is virtual and can be defined by code. It’s fine for you to deploy a simple resource or even a couple of simple resources using the portal in a one-off situation. But having to set up by hand multiple and complex resources, perhaps several times for different environments, like development test and production, would not only be tedious and time-consuming but also prone to error. You can create resource deployments with scripts and run them through the Azure CLI or PowerShell. As resource creation and deployment are so important Azure has developed templates for defining your resources.</p>
<p>A template is a JSON formatted text specification of a resource. The JSON template file contains all the information about a resource necessary for Azure to create it. It contains vital information like the type of resource, for example, virtual machine, database or storage, and the resource’s name. What resource group, and where the resource should be deployed, as in the geographic region are other configurable attributes in the JSON definition. The template specifies the size of the resource, whether that is disk space for a database or compute power for a virtual machine. As I said, every detail about the resource you want to create, including other resources that the target resource will depend on. A template won’t be that useful if it just specifies exactly the same resource. What I mean by that, is you can’t have resources with identical names. The template architecture allows you to use input parameters to reuse a template to deploy the same type of resource, with a different name and attributes. We will see that all the attributes we choose from drop-down lists, radio buttons, and checkboxes as well as text we enter during the resource creation process in the portal become template parameters.</p>
<p>I’m going to introduce you to templates by creating a virtual machine resource in the portal and then saving the template. We will look at the elements of the template like how a resource is defined and how parameters are used to modify a resource deployment. Creating a VM will also demonstrate how one resource is dependent on other resources. A virtual machine doesn’t exist in isolation, it requires a network and storage in the form of a disk. Don’t worry if you don’t get resource templates after the first demonstration. I will examine the different elements of a template in more detail later. The first demo is to show you the relationship between a resource created in the portal and the corresponding template that gets produced.</p>
<h1 id="DEMO-Modifying-Existing-Templates"><a href="#DEMO-Modifying-Existing-Templates" class="headerlink" title="DEMO: Modifying Existing Templates"></a>DEMO: Modifying Existing Templates</h1><p>Without a doubt, the easiest way to get started with templates is to go to a current resource and download the deployment as an ARM template. This process can be likened to recording an Excel macro and then inspecting the code to see how it works. </p>
<p>I’ll start by creating a virtual machine resource. Let’s just fast forward through the portal process by going with most of the defaults. It’s not important what we choose here as template creation will work for any resource. I’ll go with premium SSD and the standard networking setup. I will turn on OS guest diagnostics, take the advanced defaults, and not bother with tags. We can see before we hit the create button, we have the opportunity to download the template before getting the portal to deploy the VM. I’m going to download the template now for use later on.</p>
<p>Having a look at the template we can see it is made up of 22 input parameters that can be changed or substituted to alter how the resources are created. The parameters have a name and a data type. There are 3 variables that are used within the template, and of course, there are the 6 resources being created in the deployment. The parameters file contains the values that are currently used for the resource deployments. These are default values, or values manually entered in the portal when creating the VM resource, like location, machine name, and resource group. Scripts just links you to Azure documentation. The same information is accessible while the deployment is happening. For an existing resource, you can download the template or deploy from the Export Template page. Some of you might be thinking, “hang on, now there are only 3 parameters and 1 resource”. That’s because this template is just the virtual machine component and doesn’t include the supporting network infrastructure resources. If you need to get the templates for all resources in a deployment after the fact, you can go to the resource group and select the resources and click export template.</p>
<p>Back at our VM resource, Azure lets you save templates to an online library, which is what I’ll do now by giving the template a name and simple description. You can view templates saved to the library through More Services, then All Services, and then select Templates. With a template, you can redeploy the resource or make a similar resource with different attributes by changing some of the input parameters.</p>
<p>We’ve got the template what now? The usual method for deploying resources using templates is to use a command-line interface, either PowerShell or Azure CLI. We will look at both of these later, but initially let’s create the VM resource through the portal using the downloaded template.</p>
<p>Search for deploy on the home page of the portal and select Deploy a custom template. Under common templates, there are templates for creating common resources that you can adapt and modify. We want to build our own template in the editor. Here we have a blank boilerplate template, which I’m going to replace with the template I previously downloaded. I’ll upload the file and save it. Once that’s been loaded, we can see that there are 6 resources in our template – correct. Now we have an interface for entering the parameters for the resource creation. Typing in all those values does seem a bit painful, but if I click edit parameters, I can upload the associated parameters.json file with all the values in it and click save. Boom, and there we go, the values that are entered as part of the resource creation wizard are filled in as parameters. We can do a side by side comparison of the parameters as they relate to the manual portal process Resource Group, virtual machine name, region, VM size, user name, disk type, and networking. I’ll fill in the password and agree to the terms and conditions. The purchase button is a bit misleading, and I assume I won’t be charged for my own template. Anyway, the template validates correctly as I would expect, and the deployment successfully completes.</p>
<p>As with most things Azure, there is a marketplace for templates where you can browse or search for a template that meets, or closely meets your requirements at Azure quick-start templates. I’ll search for something a little bit interesting involving Cosmos, like Create an Azure Cosmos account for MongoDB API autoscale. Clicking on the link takes us to a description of the template and its parameters, along with instructions on how to deploy the template using either PowerShell or Azure command-line interface. Browse on GitHub will take you to the template’s repo where you can download the template JSON files.</p>
<p>Clicking Deploy to Azure takes back to the same Deploy Custom Template page where you can enter the missing parameters using the GUI interface.</p>
<h1 id="ARM-Templates"><a href="#ARM-Templates" class="headerlink" title="ARM Templates"></a>ARM Templates</h1><p>An ARM template is a JSON file describing the resources or services that you want to deploy and it has many advantages. Templates are idempotent. This means changes are applied only once, which is exactly what we want. Associated with this is repeatability, and that each time we apply the template we get the same result. Unlike a procedural script where the order of commands is crucial, the template is submitted as one object and Azure Resource Manager works out the order that resources should be created in. So dependency management and orchestration of deployment operations are carried out correctly. That JSON format also allows for nested and hierarchical resources and you can divide up a deployment into multiple linked files to make complex deployments modular and easier to manage. Azure Resource Manager includes commands for testing templates, and Azure DevOps has a task for including ARM templates in pipelines.</p>
<p>A template file is made up of five sections. There are parameters that can be passed into the template. A parameter has a name and a type, for example, string or int for integer, so like programming data types. There is a functions section, this is where you define your own functions. This is in addition to the ARM template built-in functions. Any values you want to use within the template are defined in the variables section. So not variables in the traditional programming sense, but more like constants. Of course, we have a resources section which is obviously the most important part of the template as this is where we define the resources or services we want to deploy. Finally, we have an outputs section that could be used for displaying information or daisy-chaining templates. Also at the root of the template, we have the JSON schema, which we shall see is very important when building a template and also the content version.</p>
<p>Parameters allow you to pass variables into the template to make its functionality more dynamic. Each parameter object starts with its name. A parameter has a type that can be an int, bool, array, object, string, secure object, or secure string. You can also define a default value, allowed values and minimum and maximum lengths or values. Within the metadata section, you can give your parameter a description.</p>
<p>Before I move on to the function section, I just briefly want to touch on the built-in functions that are available within ARM templates. As you can see from this table, there are quite an extensive array of built-in functions, ranging from array functions through to string, although not all of the string functions have been listed here. Many of the functions are what you would expect to find in most programming languages and definitely in the .NET environment. Resource functions are there to provide access to your Azure resources and account settings, while the deployment value functions allow you to access different sections of the template.</p>
<p>User-defined functions are more like formulas or expressions rather than functions that you might find in a procedural programming language. They do take parameters that are defined with a name and a data type and the return type called output also has a defined data type. Template variables and parameters are global and can be used within user-defined functions. While you can use built-in logical functions within your user-defined function, there is no facility for iterations or for-loops. Essentially user-defined functions are a way of separating out complex or compound functionality that you want to use more than once into a separate piece of template code.</p>
<p>Variables are key-value pairs that are defined once and can be used throughout the template. As I said earlier, they are more like constant values as they can’t be assigned to once defined. Variables don’t have to be simple data types, they can be nested and complex JSON objects. The resource section is the main event, if you will. This is where we define the resources or services that we want to deploy. For obvious reasons, different resources will have different properties but there are some properties that all resources must contain. Every resource needs a name and every resource is of a type and is located somewhere. The resource shown here is an app service and depends on another resource of the type app service plan.</p>
<p>Output values are essentially the inverse of parameters. They enable you to output values from your template for either informational purposes or as inputs to linked templates, that we shall look at later, or to be used in scripts that executing the template.</p>
<h1 id="DEMO-Virtual-Machine-Template"><a href="#DEMO-Virtual-Machine-Template" class="headerlink" title="DEMO: Virtual Machine Template"></a>DEMO: Virtual Machine Template</h1><p>Let’s look at how the template structure relates to the virtual machine template we previously downloaded. I’m using Visual Studio Code to view the JSON files. Here we have those 22 parameters, followed by the three variables, and then the 6 resources. A virtual machine deployment involves more than just the machine. There is all the supporting network and security infrastructure that allows you to safely connect to and use the VM. Here we have a resource name which is one of the parameters that we input to this template. That’s the parameter definition specifying its data type. If I go over to parameters.json I can see the value that is being inserted for network interface name. Going back to template.json we can see each resource has a type, that is what resource is created. This is a network interface which is defined in the region specified by the location parameter. We have a security group name, virtual network resource, a public IP address resource, the actual virtual machine itself with the various nested properties that define that machine like its size, which is also retrieved from the machine size parameter. Here we have the virtual machine’s dependsOn section specifying that the VM requires the network interface and storage resources.</p>
<h1 id="DEMO-Simple-Template"><a href="#DEMO-Simple-Template" class="headerlink" title="DEMO: Simple Template"></a>DEMO: Simple Template</h1><p>I know what you’re thinking, this is very complex, and where do I start? Well, as luck would have it, Visual Studio has some fantastic features for creating and editing ARM templates. To access the ARM template intellisense, you need to have the Azure Resource Manager Tools extension installed in VS Code.</p>
<p>First thing I’m going to do is create a new file, and save it with the JSON extension. Straightaway, we can see that VS Code recognizes this as a JSON file. This is where the magic starts, or more correctly intellisense, when I type ARM for Azure Resource Management. We can see I have code auto-complete here with some prompts. I’m just going to select the top one, which is a resource group template and there we have all the sections that we have talked about earlier. So if I want to create a simple web app deployment, all I have to do is go into resources and once again type ARM, and we can see here we have a lot of resources to choose from.</p>
<p>Now this is all context-based, and I’m going to select web app, and there we have all the properties that we need to create a web app deployment. Obviously, I don’t want my app to be called webApp1. So I’m going to create a parameter of type string, called appname. We can see here with the yellow squiggly line that part of the template functionality is that it recognizes that I haven’t used that parameter yet. So, I’ll go down here and type open square bracket P and you see the auto-complete prompts with parameters. I’ll pick parameters and type open bracket and I’m prompted with the parameter appname. I can then go and I can just replace all the instances of webApp1 with my appname parameter. Every resource has a type and in this case it’s a web site and it’s already put in the ARM tags and properties for us.</p>
<p>In the dependsOn section, we can see a service plan. But before I define that I’m going to show you how we can test our template before deploying it. If I go to my PowerShell window, which I’ve already logged into Azure and enter Test AzResourceGroupDeployment, I’m prompted for the parameter appname, which I’ll supply, called howdeploywebapp. It’s returned with an invalid template error. It’s complaining that it doesn’t have an appServicePlan1.</p>
<p>Okay, so I need to back in the resources section and I will add a service plan and I will also add another parameter called planname. I can use that parameter everywhere I’ve got appServicePlan1, and that is even within the app service itself, like in this concat function. As you can see, functions, parameters and variables are used within square brackets. The error in the concat function indicates a missing comma. Right, so I’ll save that. Just notice here that the location is picked up from the resource group.</p>
<p>So when we are testing, we are testing it with AzResourceGroupDeployment, and that relies on the fact that it belongs to an existing resource group as opposed to using the Test-AzDeployment command. I’ll go back here and re-run this, howdeploywebbapp and the plan name is howdeployplan and we can see that has been successful. So let’s go ahead and deploy that. I’ll just go back here and change my test to new. Now we can go over to the portal and see what’s happening. If I refresh deployments, we can see we’ve got a deployment happening. Let’s click on that and go into it, and it’s complete. I’ll navigate back to the resource group home page so we can see the newly created resources.</p>
<p>Right, so here we have the plan and the app, and as you would expect. Clicking on the app service resource takes us to the app service, where we can click on the app service URL to see it deployed.</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;$schema&quot;: &quot;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#&quot;,</span><br><span class="line">  &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,</span><br><span class="line">  &quot;parameters&quot;: &#123;</span><br><span class="line">    &quot;appname&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;description&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;planname&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;metadata&quot;: &#123;</span><br><span class="line">        &quot;description&quot;: &quot;description&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;functions&quot;: [],</span><br><span class="line">  &quot;variables&quot;: &#123;&#125;,</span><br><span class="line">  &quot;resources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;[parameters(&#x27;planname&#x27;)]&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;Microsoft.Web/serverfarms&quot;,</span><br><span class="line">      &quot;apiVersion&quot;: &quot;2018-02-01&quot;,</span><br><span class="line">      &quot;location&quot;: &quot;[resourceGroup().location]&quot;,</span><br><span class="line">      &quot;sku&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;F1&quot;,</span><br><span class="line">        &quot;capacity&quot;: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;tags&quot;: &#123;</span><br><span class="line">        &quot;displayName&quot;: &quot;[parameters(&#x27;planname&#x27;)]&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;[parameters(&#x27;planname&#x27;)]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;[parameters(&#x27;appname&#x27;)]&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;Microsoft.Web/sites&quot;,</span><br><span class="line">      &quot;apiVersion&quot;: &quot;2018-11-01&quot;,</span><br><span class="line">      &quot;location&quot;: &quot;[resourceGroup().location]&quot;,</span><br><span class="line">      &quot;tags&quot;: &#123;</span><br><span class="line">        &quot;[concat(&#x27;hidden-related:&#x27;, resourceGroup().id, &#x27;/providers/Microsoft.Web/serverfarms/&#x27;, parameters(&#x27;planname&#x27;))]&quot;: &quot;Resource&quot;,</span><br><span class="line">        &quot;displayName&quot;: &quot;[parameters(&#x27;appname&#x27;)]&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;dependsOn&quot;: [</span><br><span class="line">        &quot;[resourceId(&#x27;Microsoft.Web/serverfarms&#x27;, parameters(&#x27;planname&#x27;))]&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;[parameters(&#x27;appname&#x27;)]&quot;,</span><br><span class="line">        &quot;serverFarmId&quot;: &quot;[resourceId(&#x27;Microsoft.Web/serverfarms&#x27;, parameters(&#x27;planname&#x27;))]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outputs&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="DEMO-Linked-Template"><a href="#DEMO-Linked-Template" class="headerlink" title="DEMO: Linked Template"></a>DEMO: Linked Template</h1><p>In this demonstration, I want to show you how to use linked templates. That’s how you can separate resources into separate template files to make management easier and to reuse resources and deployments. This is a little bit of a contrived example but what I’m going to do is separate out the app plan resource from the app service deployment. </p>
<p>First of all, create a new file that I will save as appsplandeploy.json and start with the ARM template boilerplate structure. Then move the plan name parameter along with the plan resource from the existing template file to the new one. </p>
<p>In the appsplandeploy template, I will need to define an output parameter that will pass the planname to the parent or calling template. That output parameter will be the plan name and will be of type String and the value is simply going to be the parameter planname that is being passed in. </p>
<p>I’m going to create a new file for my web app deployment called websitedeploy. This will be the parent or master template. It will just be the content from the original template, so yes I could have just renamed the file.</p>
<p>We can see here that we already have some issues with our missing parameter and service plan, so I will need to add a link to the appsplandeploy template, and I will do that by creating a nested resource. </p>
<p>While link and nested might not be intuitive, I guess that is exactly what we are doing; we are nesting this linked resource within our main resource template. One thing to be aware of is that the template file cannot be accessed locally, you must have that file accessible by HTTP, which means storing it somewhere on the Internet, and in my case, I’ve created container storage where I will upload that template file to. I’ll just upload that file to my storage container templates inside the howarmtemplate storage account. I’ll grab the link to the file and I will paste it into the URI property of the template link section. Obviously the other issue we need to address is the now redundant planname parameter and we do that by using a reference function to reference the output value from our linked template. So the reference name is the name of my linked template resource. I’ll just change the name of that resource from nested deployment to linkedTemplate. </p>
<p>We reference our outputs with the word outputs, then it picks up the name of the output, which is planname, and then we want to use the keyword value to get its value.</p>
<p>We no longer need the dependsOn section, so I will get rid of that. Another thing you need to be aware of is that the reference function does not work as a parameter within another function, that is, you cannot nest it with another function. Replacing the planname parameters within the linked template reference inside the concat function will throw a template error.</p>
<p>One thing I forgot to mention was that in the app service plan template as it is being linked from our website deploy template we will not be prompted for our plan name parameter. Just for the purposes of demonstration, and it is definitely not best practice, I will use the default parameter to specify a plan name. Later on we will look at a much better option. I’ll just save appsplandeploy and refresh it to my blob storage. Before we continue I’ll demonstrate how that reference function within the concat function will give an invalid template error by running a Test-Az- ResourceGroupDeployment. Here we have the invalid template error’s telling us there is a problem at line 30 column 9 and the function reference is not expected at this location. Line 30 column 9 isn’t really accurate but the closest reference we have to that is within the tags property, but I know this to be the case and I will change it and we will retest. Having changed that tag property it passes the test deployment so I can now deploy for real using the new-azresourcegroupdeployment command. Going back to the portal and into deployments of the resource group, we can see the link template and the website deploy are both in action. If we go and have a look at the link template deployment and in outputs we can see the plan name output value and obviously that is also the input for the website deploy deployment.</p>
<p>Let’s recap what’s gone on here. We started with a resource template that had an app service plan and a website. Then we took the app service plan and we put it in another template file; this is called a linked or nested template. The app service plan template file is linked to the master template using a deployments resource. Values are passed from the master into the linked template with parameters, and values generated in the linked template can be passed back to the master with outputs. Input parameters take the same format as we’ve already seen, while outputs are analogous to return values of a programming function. Linked or nested templates must be stored on-line and referenced with a URL. Template deployments can be tested with the Azure CLI test-azresourcegroupdeployment command, taking the resource group and template file as parameters. Once successfully tested a template can be deployed to Azure with the new-azresourcegroupdeployment command.</p>
<h1 id="DEMO-Parameter-Template"><a href="#DEMO-Parameter-Template" class="headerlink" title="DEMO: Parameter Template"></a>DEMO: Parameter Template</h1><p>Obviously, using a default parameter in our linked template, which is essentially the same as hard coding, the value is completely unacceptable and almost pointless. Before I show you how to use a parameter file to dynamically change parameters, I’ll just delete the web app and plan. Let’s go back to visual studio code and create a new JSON file called deploy parameters, and from the autocomplete, I will choose the parameter template. We just need the app name and plan name parameters with values inside the parameter template and add the plan name parameter to the website deploy template. </p>
<p>With the parameters set up I’ll save and close the the template file, and go back to appsplandeploy.json and add the plan name parameter to the website deploy template. The plan name parameter in this template, website deploy is where the plan name comes in from externally. Then we will pass it to the linked or nested template via a parameter within the linked template resource below.</p>
<p>Now in the parameters section of the linked template resource I will just add the plan name parameter and pass it the parameters planname value. This is a completely ridiculous and circular scenario in reality as the plan name parameter is being passed to the link template and then subsequently retrieved through the outputs value. But this is just to give you an idea of how to use parameters in linked templates using the previous example. Now, to deploy the resources, we’ve got the parameters in a file. That file will be passed as a parameter to the new-azresourcegroupdeployment command. The parameter values get pulled out of the JSON file and matched by name to the parameters defined in the ARM template file. Those parameters, can in turn be passed to linked or nested templates, by matching on name.</p>
<p>Let’s switch over to the PowerShell command prompt. First I’ll test the deployment, specifying the resource group name, the ARM template file, and the parameters file. Okay having successfully tested that I will now redeploy by executing the new resource group deployment command with the template parameter. We can see in the PowerShell CLI and the portal that it has successfully executed.</p>
<h1 id="DEMO-Database-Deployment"><a href="#DEMO-Database-Deployment" class="headerlink" title="DEMO: Database Deployment"></a>DEMO: Database Deployment</h1><p>As I’ve said the demos so far have been a little contrived. Now I want to show you a few of the more advanced features of ARM templates like the use of user-defined functions and how to create multiple instances of a resource type using something that could be called a looping mechanism. We will then deploy that template via a PowerShell script which will involve creating a new resource group and then submitting the template parameters using a template object. Let’s begin by creating a new template. I’m going to call it arm deploy and once again that will be a resource group template. In terms of resources, we are going to need a database server and then obviously some databases to run on that server. From the ARM template autocomplete I’ll select arm-sql-server and then arm-sql-db for my resources.</p>
<p>For parameters, I will need a server name and because I am creating more than one database I’m going to need a parameter that lets me tell the template how I databases I want. I will call that dbcount. Because we are accessing Azure SQL I will also need to provide an IP address for the database firewall. That will be startip and endip to define the IP address range. In terms of naming the databases, I’m going to call them test_db and that name will have a number appended to it, and also define an admin name and password. I’m defining these as variables to demonstrate the variable use, but you could just as well pass them in as parameters. I’ll replace SqlServer1 with the servername parameter, which will have to be changed in several places. I’ll also replace the administrator login and password with my variables. Next, I’ll replace the firewall start IP and end IP addresses with the corresponding parameters.</p>
<p>When it comes to the database name this is where it all gets a little bit interesting. So the database name is made up of the server name&#x2F;followed by the database name so the first thing I’m going to have to do is concatenate my server name parameter with the database name. But of course, the database name is a compound of the DB prefix variable plus the database number. To make up this compound name I’m going to define a function that will return the name. Let’s go into the functions section and we’ll look for arm-user, which is for user-defined function. I’ll give my function a name of databasename, and like all functions it takes parameters. This is where the auto complete doesn’t fully meet expectations. The function section has to have a namespace property and all functions have to be defined within a members section of the functions section. I’ll need a parameter for my database name prefix and I will need an integer parameter for the number that will be appended to the name. The return value or output is a string and it is a concatenation of name prefix and index, which I’ll join together with the built-in conact function. Going back to the database name I will use the databasename function firstly by starting with the namespace and the function name. Then I will use the DB prefix variable as my first parameter and then a built-in function called copy index. I guess you could say copyindex is a little bit like the index of a for loop, although we have yet to tell the database template to make copies. I’ll just replace the SqlServer1 text with the server name parameter in the depends on section for my database, as obviously, a database does depend on a database server. Now I’ll add the copy section. So it has a name and it has a count and that count is the number of copies to make and I will get that from my dbcount parameter. I’ll just replace the display name and tags with my compound database name.</p>
<p>Now that we are done with the template let’s move on to the PowerShell script. So this is going to be called dbarmdeploy.ps1 and Visual Studio Code recognizes the file extension and that I’m working with a PowerShell script and it is doing a nice job of syntax highlighting for me. So I’ll start by declaring a resource group variable and I will give it a name and a location. The location is the Azure abbreviation for the West US region. Next, I want to issue the command to create a new resource group. So that’s New-AzResourceGroup with a name and the location, which is the location element of the resource group variable. Next, I’m going to create a compound template variable which will have the name of my template as file name and nested within it the parameters that I want to submit. So that will be server name dbcount, startip and endip. I’ll create a new deployment with New-AzResourceGroupDeployment and use the resource group variable to get the ResourceGroupName parameter. Then the template variable to get the file name for -TemplateFile and then the template parameters object will be for the -TemplateParameterObject parameter, my word that’s a mouthful of parameters. Just in case that wasn’t clear, the TemplateParameterObject is a compound parameter, whereas the other parameters are strings. Right, let’s save that and go to the PowerShell command prompt, and run the script. Straightaway we can see the resource group has been created so that’s a good start, and if we pop over to the portal we can see that the deployment is running. If I open up an Azure SDK command prompt I can issue a deployment group list command to see which deployments are running for my resource group. At the top, I can see the name of the deployment is armdeploy so using that I can issue and az deployment group show command with my resource group and then the name of the deployment. This will also return all the details of the deployment plus the provisioning state at the bottom which is currently showing it as running.</p>
<p>Okay, the server has been deployed and Azure resource manager has accepted the database deployments. Going back to the PowerShell window we can see that the whole deployment has finished successfully and it returns our input parameters. I’ll just open up SQL Server management and log into the database server and check out my to test databases. Finally, I will remove the resource group with the force parameter so I’m not prompted.</p>
<h1 id="Deploying-with-a-Script"><a href="#Deploying-with-a-Script" class="headerlink" title="Deploying with a Script"></a>Deploying with a Script</h1><p>As I said at the beginning of this course in the architecture section, Azure Resource Manager accepts commands from PowerShell and the Azure CLI. In a way, templates are a little bit like the portal in terms of providing an alternative interface. Everything that you can do with a template you can do with a script. Here is an example of what a script might look like for creating a resource group in an Azure SQL server with firewall rules and a database. In some ways, this does seem more concise and easy to understand what exactly is going on here, but in one crucial respect, templates have an advantage over scripts when it comes to deployment mode.</p>
<p>Azure Resource Manager has two deployment modes; the default, which is incremental, means that whatever is in your deployment is added to your resource group, whereas complete says the resource group will become whatever is in your deployment. This essentially means that the resource group is cleaned out before the deployment is applied or all resources that are not in your deployment are removed from the resource group.</p>
<h1 id="Course-Summary"><a href="#Course-Summary" class="headerlink" title="Course Summary"></a>Course Summary</h1><p>Let’s recap what we have learned about Azure Resource Manager. It’s not the Azure portal. It’s the behind-the-scenes process that’s mostly involved with managing the deployment of resources in the Azure cloud. There are multiple interfaces for interacting with Azure Resource Manager apart from the graphical interface of the portal.</p>
<p>You can issue commands through PowerShell and the Azure CLI, but the preferred method is to use ARM templates. Azure Resource Manager templates are JSON files with sections that allow you to specify parameters, variables, functions, and resources. There is also an outputs section so you can pass values from one template to another.</p>
<p>A template can specify multiple resources, and multiple resources can be specified in multiple template files that are linked to a master template deployment file. Visual Studio Code has an IntelliSense extension for creating ARM templates. This extension has auto-complete and syntax checking and greatly simplifies the creation of templates.</p>
<p>As well as defining your own functions, there are many built-in functions to work with strings, arrays, logical comparisons, and Azure resources. Once a template has been defined, it can be tested with the Test-AzResourceGroupDeployment command. The template can then be deployed to Azure using the New-AzResourceGroupDeployment command. Both of these commands can be actioned either through PowerShell or the Azure CLI.</p>
<p>When a deployment is in progress you can monitor it through the portal or by using the Az group deployment list and show commands. You don’t have to create your template from scratch. You can download deployments as templates that you have created previously through the portal. This reaffirms the architecture of the portal as an interface to the Azure Resource Manager.</p>
<p>There is also a marketplace of Quickstart templates that you can use as-is, or download and modify. ARM templates simplify deployment by taking care of dependency management and orchestration. Unlike deploying resources with a script, you don’t have to worry about the order you define your resources in. Testing a deployment will let you know if dependencies are missing, and if you deploy without testing either the whole template is successful or none of it succeeds. You won’t end up in a situation with half of your resources deployed due to missing dependencies.</p>
<p>When a new resource or service becomes available on Azure often deploying an instance is only available using ARM templates and commands. Quite often a resource is released and there may be some time before the portal is updated to support it. But the main reason to become familiar and experienced with Azure Resource Manager is that it is by far the easiest method to ensure that your deployments are consistent and repeatable. This is of particular importance when deploying infrastructure as code through a DevOps pipeline.</p>
<h1 id="1Course-Introduction"><a href="#1Course-Introduction" class="headerlink" title="1Course Introduction"></a>1<strong>Course Introduction</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/cloudacademy/intro-to-arm">Github Repo</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-104-Azure-Virtual-Machine-Basic-Challenge-15/" rel="prev" title="AZ-104-Azure-Virtual-Machine-Basic-Challenge-15">
      <i class="fa fa-chevron-left"></i> AZ-104-Azure-Virtual-Machine-Basic-Challenge-15
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-104-Azure-Resource-Manager-Templates-In-Depth-17/" rel="next" title="AZ-104-Azure-Resource-Manager-Templates-In-Depth-17">
      AZ-104-Azure-Resource-Manager-Templates-In-Depth-17 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Azure-ARM-Intro-Overview"><span class="nav-number">2.</span> <span class="nav-text">Azure ARM Intro Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Scope"><span class="nav-number">2.1.</span> <span class="nav-text">Scope</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Modifying-Existing-Templates"><span class="nav-number">3.</span> <span class="nav-text">DEMO: Modifying Existing Templates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARM-Templates"><span class="nav-number">4.</span> <span class="nav-text">ARM Templates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Virtual-Machine-Template"><span class="nav-number">5.</span> <span class="nav-text">DEMO: Virtual Machine Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Simple-Template"><span class="nav-number">6.</span> <span class="nav-text">DEMO: Simple Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Linked-Template"><span class="nav-number">7.</span> <span class="nav-text">DEMO: Linked Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Parameter-Template"><span class="nav-number">8.</span> <span class="nav-text">DEMO: Parameter Template</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Database-Deployment"><span class="nav-number">9.</span> <span class="nav-text">DEMO: Database Deployment</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Deploying-with-a-Script"><span class="nav-number">10.</span> <span class="nav-text">Deploying with a Script</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Summary"><span class="nav-number">11.</span> <span class="nav-text">Course Summary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1Course-Introduction"><span class="nav-number">12.</span> <span class="nav-text">1Course Introduction</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
