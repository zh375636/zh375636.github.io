<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course IntroductionHi and welcome to this Implementing Version Control on Azure Repos course. My name is Hallam Webber and I’ll be your instructor for this course. We welcome all comments and feedback">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-400-Implementing-Version-Control-on-Azure-Repos-4">
<meta property="og:url" content="https://example.com/2022/11/18/AZ-400-Implementing-Version-Control-on-Azure-Repos-4/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course IntroductionHi and welcome to this Implementing Version Control on Azure Repos course. My name is Hallam Webber and I’ll be your instructor for this course. We welcome all comments and feedback">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T00:37:33.000Z">
<meta property="article:modified_time" content="2022-11-27T05:20:00.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AZ-400-Implementing-Version-Control-on-Azure-Repos-4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-400-Implementing-Version-Control-on-Azure-Repos-4 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AZ-400-Implementing-Version-Control-on-Azure-Repos-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-400-Implementing-Version-Control-on-Azure-Repos-4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 20:37:33" itemprop="dateCreated datePublished" datetime="2022-11-18T20:37:33-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-27 01:20:00" itemprop="dateModified" datetime="2022-11-27T01:20:00-04:00">2022-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-400/" itemprop="url" rel="index"><span itemprop="name">AZ-400</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AZ-400-Implementing-Version-Control-on-Azure-Repos-4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AZ-400-Implementing-Version-Control-on-Azure-Repos-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Hi and welcome to this Implementing <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/what-is-version-control/">Version Control</a> on Azure Repos course. My name is Hallam Webber and I’ll be your instructor for this course. We welcome all comments and feedback, so please feel free to reach out to us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a> with any questions or comments.</p>
<p>This is an intermediate level course suited to developers, engineers, and project managers. Having a basic understanding of the software development lifecycle and what’s involved in deploying software to a production environment would be helpful. While most of what I’ll be talking about is theoretical, there will be some demonstrations, so if you want to follow along, you’ll need to have an Azure DevOps account.</p>
<p>I’ll start with an overview of what source control is and the different types of source control. Then, we’ll look at the key elements of branching, different branching strategies, and how they impact the development process. Pull requests and merging is arguably one of the most important repository functions and we will investigate the different merging scenarios available to us. Finally, I’ll take a look at using third-party systems in conjunction with <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps.</p>
<p>We welcome all comments and feedback, so please feel free to reach out to us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a> with any questions or comments. Let’s get started.</p>
<h1 id="What-is-Version-Control"><a href="#What-is-Version-Control" class="headerlink" title="What is Version Control?"></a>What is Version Control?</h1><p>What is Version Control? <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/what-is-version-control/">Version Control</a>, as the name suggests, is a means to manage different versions of your source code, and is also commonly referred to as Source Control. These code versions might be explicit versions of the application, like 1.9 and 2.0, or might be work-in-progress versions, or customized versions for different customers. Managing multiple developers is another key component of Version Control, especially as software teams get bigger, become more numerous as applications become more complex, and those teams are geographically distributed. Implicit in Version Control is maintaining a record of changes to the source code, who made the change, when they made it, and a summary of what the change was. While not an explicit element of Version Control, online code repositories have become synonymous with it and serve as a backup vehicle for source code. As will become apparent, the tree analogy is often used when talking about Version Control. The main thread of the code development is called the trunk, often referred to as the master trunk, while deviations or splits from that are called branches. Because developers aren’t arborists, the master trunk is often called the main branch. This technology isn’t new and falls under two main types, centralized and distributed.</p>
<p>Centralized Version Control systems are modeled on client-server architecture, where developers check out files to work on, much like taking a book out from the library. While the file is checked out, it is locked within the Version Control system, preventing anyone else from making changes to it. This type of Version Control was very much in vogue at the beginning of the century and is represented by well known, if you are of a certain age, products, like CVS, Concurrent Versions Systems, Subversion, and Team Foundation Server, which morphed into Team Foundation Version Control, abbreviated to TFVC. One side-effect of the check-out&#x2F;check-in model is behavioral. Developers tend to put off checking in until their body of work is totally complete as they don’t want to break the build. This leads to large check-ins with associated conflict issues, and makes reverting or unwinding changes more difficult.</p>
<p>Moving forward, distributed systems are very much the flavor of the month now, and if we were to be completely honest when we talk about distributed systems, we are invariably talking about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/lets-git-to-the-point/">Git</a>. Instead of checking out and locking files from the master trunk, a developer takes a copy, called a clone, typically of the whole code base, and has it locally, where they can work on any part of it. Obviously, this is a significant advantage over the check-out&#x2F;check-in model when it comes to having multiple developers working on the same code base, especially with remote workers who don’t have to be connected all the time. Changes in the form of branches are typically merged back to the master trunk with what’s called pull requests, which I’ll get into later.</p>
<h1 id="Let’s-Git-to-the-Point"><a href="#Let’s-Git-to-the-Point" class="headerlink" title="Let’s Git to the Point"></a>Let’s Git to the Point</h1><p>Here we see a graphical representation of a typical <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/what-is-version-control/">version control</a> setup with remote <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">repositories</a>. <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps, GitHub, and Bitbucket Cloud are all examples of cloud Git-based remote repositories. A developer with Git installed locally uses Git commands, even if that is via a graphical interface to clone, fetch, fork or pull code from the repository to their local hard drive. They work on the code making changes and saving those changes with accompanying descriptions as commits to their local Git repo. Those commits are then pushed back to the Git structure in the remote repository where they remain until they are merged back into the main trunk through a process called a pull request. A pull request is a process of code review by other developers, preferably two or more followed by a merge operation.</p>
<p>Now I wanna talk about two things that are very closely related, code flow and <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/branching-strategy-overview/">branching strategies</a>. It’s a little bit of a chicken or egg situation, but suffice to say that they are interdependent and one impacts the other. Having said that, there are a number of best practices that should be followed no matter what strategy you adopt.</p>
<p>The master trunk should always be bug-free and a facsimile of what is in production. Branches, be they new features, versions, or bug fixes should have meaningful names and be related to a piece of work like new functionality, a work item, or a sprint. Commits should be frequent, relate to one code change and have an accurate and full description.</p>
<p>Now I want to illustrate with a simple and contrived example of why these best practices should be followed. Remember developers are people and have to read, interpret and review code changes before they are released. We want to add a customer search function to our software. First off, we need to add a branch from our known and good and stable master trunk code with a name describing what the branch is about. It’s a new feature called customer search. We could just leave it at that, but in reality, the search is made up of three distinct pieces of functionality.</p>
<p>So we will split that into three branches off the customer search branch. This serves two purposes, firstly keeping each piece of work smaller and more manageable for testing, progress tracking and merging, and secondly if you want different people to work on the pieces simultaneously. Within each of these sub-branches we want work to be committed frequently and often, and I would say that what is illustrated would be the bare minimum. Committing after each piece of logic is completed helps with tracking changes, locating bugs and unwinding code changes if necessary. Each sub-branch is merged back to the customer search branch with a pull request where the code is reviewed.</p>
<p>Not to state the obvious, but reviewing a relatively small piece of code in one or a small handful of files is a relatively simple task as compared with code spread over potentially dozens of files. We’ve ended up with our code reviewed and successfully merged into the customer branch. This is where some of the branching strategies diverge, and I will look at why in the next section. But for simplicity sake, we can now merge our customer search branch back into the master trunk.</p>
<p>What if we didn’t follow these best practices and we created a branch called customer update and assigned the work to a developer? That developer did the work we’ve just talked about and committed all of it to the update branch with the description, customer changes. Then they submitted a pull request to have their code reviewed and merged. Apart from the already mentioned issue of reviewing a larger chunk of code, where’s the history of code changes? If those assigned to review the code don’t have an intimate knowledge of this particular piece of work, they have little in the way of description clues to help them. As I’ve already said, developers are human, so reviewing and merging a relatively large amount of code will greatly increase the possibility of errors. Now, think about that one update branch spread across several developers and then have them merge their work back into the master trunk. In the real world, this scenario would be orders of magnitude bigger in scale and complexity. I really want to hammer home the importance of these simple conventions and how not using them will negate any cleverness you may adopt in your branching strategies.</p>
<h1 id="Branching-Strategy-Overview"><a href="#Branching-Strategy-Overview" class="headerlink" title="Branching Strategy Overview"></a>Branching Strategy Overview</h1><p>One of the criticisms of TFVC, a centralized <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">repository</a> system, is that branching is expensive. What does this actually mean? Well, the cost of branching can be viewed in two ways. There is the cost of performing the branching process and there is the cost of merging the branch back into the master trunk. Creating a branch in TFVC isn’t as easy as with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/lets-git-to-the-point/">Git</a>, and this is mainly due to the fact that TFVC creates a physical copy of the original branch as the starting point of the new branch, whereas Git uses the most recent commit from the parent branch. It’s the difference between making a physical copy of a variable, as opposed to creating a new pointer to it. The other crucial difference is that TFVC branches are always created on the server, so you have to be connected and be cognizant of branch naming and potential naming conflicts. As Git is distributed, a developer can create branches at will on their own repository and only have to be concerned when merging back to the remote branch.</p>
<p>Merging brings us to the second cost of branching, which significantly outweighs the first. Everyone involved in software development will have their own horror story of branch merging, which typically revolves around sorting out code differences between two or more versions of the same file, or files. Sure, there are tools that can help with this, but it is essentially a manual process similar to untangling string. The process is how long and how many pieces of string are there? This leads to the often quoted refrain “Branch less, merge more,” and is the main underlying conundrum of branching strategies.</p>
<p>Having said that, let’s look at some generic branching scenarios starting with Main Only, which is essentially a branchless strategy, that is just the master trunk. This means all work is committed back to the main trunk or branch. The Main Only strategy has limited application. It is not suited to maintaining multiple versions and would be very difficult to manage with many developers working on multiple features. Labels can be used to mark development and release events. The irony is that Trunk-based branching, that we’ll look at later, is closely related to Main Only and is gaining substantial traction as a strategy.</p>
<p>Development isolation is one of the strategies most people think of when talking about branching. The central tenet of branching is to maintain a stable and pristine main branch, and development isolation does this by explicitly separating all development into its own dev branch. You end up with two branches running in parallel. When a feature in the dev branch is complete, it is merged back into the main branch. When a bug is discovered in production code, it is fixed in the main branch and merged into the dev branch. It seems like a good strategy, but you’ve essentially ended up with two versions of the software truth, and quite some effort is required to maintain concurrency. It’s definitely not unheard of for bug fixes in the main branch not to be merged into dev and then for the bug to reappear after a new dev feature is merged into main.</p>
<p>Feature isolation is a variant or evolution of development isolation. Basically, its short-lived development branches that are dedicated to one feature. This addresses a couple of issues. Firstly, “The branch only exists, “or should only exist for a short time “before it’s merged back into its parent.” A feature can be branched off a development branch. Secondly, there can be multiple feature branches running concurrently. When it comes to bug fixes in production, there is still the same issue of fixing them in the master and merging them into the feature branch so they aren’t lost when merging features back.</p>
<p>Release isolation is geared towards creating multiple production versions of your software as each release branch is a snapshot of the code when the branch is created. Release branches can coexist with development or feature branches. When you want to release a new version of your software because the required features have been completed, tested and merged back into master, you create a release branch. The release branch is read-only, with one exception. If a bug is found in production code, it is fixed in the release branch and merged back into the main branch. This is a simplistic depiction, as there can be multiple concurrent releases in existence and being supported. In terms of applying hotfixes to past releases, it really boils down to how long you want to support old versions before retiring them. This is probably a good place to remind ourselves of how different software platforms have different requirements. In the world of web or mobile apps, it’s very rare to have more than one version of your software in the wild. Everyone runs the latest version. This is certainly not the case for desktop or server-based applications and will definitely influence your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/the-strategies/">branching strategy</a> choice.</p>
<h1 id="The-Strategies"><a href="#The-Strategies" class="headerlink" title="The Strategies"></a>The Strategies</h1><p>Okay, now on to the strategies. As you may have guessed, these strategies have more in common than their differences, but while differences are subtle, they are important especially when it comes to how your organization manages code flow and the development process.</p>
<p>GitHub Flow is the archetypal <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/branching-strategy-overview/">branching strategy</a>, and pretty much what I described in the Got commitment, or should be committed slide. In GitHub flow, the master branch is always deployable and should reflect what is in production. Any new work is created in a branch off master. Regularly commit to that branch locally and push to that branch on the server. When the branch is ready or finished, open a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/pull-requests-and-merging/">pull request</a> for the code to be reviewed. This can also be done when you need help, feedback, or a second opinion on the code. Once the branch has been reviewed and tested, it can be deployed into production. If the deployed branch causes issues or has bugs, it can be rolled back by deploying the existing master. Otherwise, the branch can be merged with master.</p>
<p>Next, we have Gitflow, which has, for all intents and purposes, two main branches. The master branch is stable code that reflects what is deployed in production. The development branch is the parent branch of most code changes. When a change is required, a branch is created from the development branch. These branches can be categorized as feature branches, branched from development merged to development, release branches, branched from development merged to master and development, and hotfix branches, branched from master merged to master and development. A development branch becomes like a master branch for a set of features. When a feature is finished, it is merged back to the development branch. To deploy the new functionality, a release branch is created from the development branch. The release branch, typically named as the release <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">version</a> number, including any bug fixes and tweaks, is merged back into development and master branches after the release is deployed. If a critical bug is discovered in the live application that can’t wait for the next release, a hotfix is required. A hotfix is branched off master and merged back into master as well as development, so both code threads get the fix.</p>
<p>Forking, or fork and pull. This strategy is typically found in public projects where you want to use an existing code base as the starting point for your project. A developer will clone the original repository to their own remote repository, creating a new origin master branch. When forking a project, it is implied that you won’t be trying to merge your changes back to the original.</p>
<p>Now for something completely different. Well, maybe not completely, but significantly. Release flow is <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps’ internal take on Trunk Based Development, and where the line between branching strategies and code flow blurs. As the name implies, all branches, be they features, bugs or hotfixes, are branched directly off the master trunk. Where Release Flow diverges from traditional trunk-based models is how and when the code is deployed. This strategy puts emphasis on the release schedule, which is tied to deploying at the end of each sprint. The strategy is designed around workflow, adhering to continuous integration and deployment processes, and projects at scale. In terms of workflow, it fits with the sprint schedule, but the main reason to do this, as the sprints usually don’t correspond to any one feature branch, is the time taken to do the actual deployment. There are literally hundreds of developers working on hundreds of branches at any one time. It is totally impractical to have deployments dictated by feature branch completion, as developers would spend too much time waiting for their queued release to be deployed before continuing with the next feature.</p>
<p>The first issue that comes to mind when looking at this graphic is how does it deal with half-completed features at the time of release deployment? Well, they use feature flags to turn off incomplete functionality within the code. If you are unfamiliar with feature flags, in its most elementary form, it is conditional branching around some code. That is, if the feature is enabled, show it, else don’t. It can be a lot more sophisticated in terms of conditions to be evaluated, but that’s it in a nutshell. The other issue is hotfixes. These are done on the main branch and then cherry-picked into the release branch.</p>
<p>The release flow strategy follows some strict conventions due to scale and working directly off the master trunk. Branch naming follows the convention of user name, then branch type, followed by description, although this has more to do with the number of developers. The development or topic branches need to be as small as possible, so work is broken down into its smallest logical functional units. This serves two purposes. It makes reviewing and testing much easier and quicker, while limiting damage if something does go wrong. And it’s no surprise that testing is very important when merging straight back to the master trunk. Each feature branch is tested as if it was going into production before merging back to master, because in essence, it is.</p>
<h1 id="Pull-Requests-and-Merging"><a href="#Pull-Requests-and-Merging" class="headerlink" title="Pull Requests and Merging"></a>Pull Requests and Merging</h1><p>You can’t talk about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">version control</a> and <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/the-strategies/">branching</a> without talking about pull requests and merging. This is where the branching rubber meets the road and <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps supports several merging strategies; basic merge, squash merge, rebase and fast-forward, and rebase with merge commit.</p>
<p>Your basic merge command is for integrating changes from one branch to another, and by default, Azure DevOps uses the git merge command with the no fast-forward option. No fast-forward creates a commit on the target branch of the merge, let’s say the main branch when merging a feature branch, and that commit contains the history of commits up to that point, so very helpful in terms of seeing how the development evolved. In contrast, a fast-forward merge is only possible when there is no divergence between the branches. This means there is nothing in the main branch code that isn’t in the feature branch.</p>
<p>A squash merge takes the commits of the branch in question, say a feature branch with three commits, and condenses or squashes the contents of those commits into one commit on the target branch of the merge. In general, commit messages should clearly define the intent of the change and make sense when viewed in isolation, but too often, this isn’t the case. The squash merge commit is a way to summarize the intent and function of a branch without all of its commit baggage. As the branch being merged is essentially discarded, the commit history is linear.</p>
<p>Rebasing is taking your branch and repositioning it at the end of its parent branch. Doing this effectively eliminates any divergence between the two branches, so a fast-forward merge can be performed to make the tip of the child branch now the tip of the parent, that is the child becomes an extension of the parent including its commit history. Like squash merge, this keeps the commit history linear, but also preserves individual commits.</p>
<p>Finally, we have rebase with a no fast-forward merge commit. The pull request commits are rebased to the end of the parent branch, then a no fast-forward merge is performed. Fundamentally, this is the same as the rebase with fast-forward merge, except branching and merging are immediately obvious when viewing the development history.</p>
<h1 id="DEMO-Work-Items-and-Branching-in-Azure-DevOps"><a href="#DEMO-Work-Items-and-Branching-in-Azure-DevOps" class="headerlink" title="DEMO: Work Items and Branching in Azure DevOps"></a>DEMO: Work Items and Branching in Azure DevOps</h1><p>Let’s see how <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps can help to integrate workflow with branching. I’m gonna go from my Repo to Work Items under the Board’s menu and create a new feature work item. I’ll give it a descriptive name and assign it to myself. Next, I’ll link it to another work item as a child. This involves adding a link to related work. The link relationship is apparent and the item is the user story list, service, and DBs. Now I’ll save the work item. And what I should’ve done was linked the work item to a branch. Let’s go back and do that. Under Add Link in the Development on the right, click on Create a Branch link and link an <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">Azure Repo</a>. Give the branch a meaningful name and select which branch you want to branch off. Click Create Branch, and you’ll be taken to the branch in the Repo. As I’ve mentioned, code reviews as part of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/pull-requests-and-merging/">pull requests</a> are an important aspect of the merge process. Azure DevOps lets you enforce some conditions of code approval through branch policies. Research has shown that the minimum number of approvers should be at least two, and of course, that should be excluding the pull requester. We can prevent the requester from approving their own changes and stipulate that all reviewers must approve the change and all comments be resolved. We can also specify that a pull request must be associated with at least one work item to aid project management and traceability. Limit merge types, lets us specify which type of branch merging we will allow with pull requests. I want to make sure there’s absolutely no loss of historical fidelity, and all merge actions are clearly identifiable. So, I will not allow squash or rebase and fast-forward mergers. After saving the policy, we can see the branch’s small badge icon next to it indicating a policy has been set.</p>
<h1 id="Setting-Access-Permissions-on-Repositories"><a href="#Setting-Access-Permissions-on-Repositories" class="headerlink" title="Setting Access Permissions on Repositories"></a>Setting Access Permissions on Repositories</h1><p>When it comes to managing access to or setting permissions on a <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">version control</a> system, the granularity of permissions is split down centralized versus distributed lines. In a nutshell, centralized systems let you, with differing degrees of ease, set permissions right down to the file level, while distributed systems typically only go as far as the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-work-items-and-branching-in-azure-devops/">branch</a>. When I say differing degrees of ease, I’m not joking. Team Foundation Version Control has a graphical interface, while Subversion uses a combination of configuration files and specialized authentication modules. Apache Subversion requires you to load the mod_auth_svn module and use the AuthsSVNAccessFile directive, specifying a file with the required access rules. The <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-setting-permissions-in-azure-devops-tvfc/">access permission</a> file can have sections with the repository name followed by the branch and path, and of course, the path can be a file name followed by users or groups and whether they can read and or write to the path.</p>
<h1 id="DEMO-Setting-Permissions-in-Azure-DevOps-TFVC"><a href="#DEMO-Setting-Permissions-in-Azure-DevOps-TFVC" class="headerlink" title="DEMO: Setting Permissions in Azure DevOps TFVC"></a>DEMO: Setting Permissions in Azure DevOps TFVC</h1><p>If I go into this TFVC project on <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps and go into project settings, I can select <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">Repositories</a> under Repos. The first thing that becomes apparent is the number of actions on which <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/setting-access-permissions-on-repositories/">permissions</a> can be set. This is not just read and write permissions. In the right-hand security pane, we can see the groups and users listed. If you can’t find a particular group or user just start typing their name in the search box. I’ve brought up the user Hallam Sql and can see he has inherited the ability to perform all the actions on the DAL folder from the main branch. I’ll deny him check-in and merge on the folder. Now if I go to the ICostCentres file I can see the inherited permissions, but I’m going to allow him to check-in and merge just this file. I can see the other files still have the inherited permissions.</p>
<h1 id="Distributed-Repository-Permissions"><a href="#Distributed-Repository-Permissions" class="headerlink" title="Distributed Repository Permissions"></a>Distributed Repository Permissions</h1><p>If we look at Distributed Repository Permissions, and by distributed, I really mean Git-based systems, we don’t have any ability to specify actions at the file level. The default <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-setting-permissions-in-azure-devops-tvfc/">permissions</a> for these systems is allow access that has access is either allowed or not specified. <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps actions have two effective permissions, allow and deny, plus not set, Bitbucket Cloud and GitHub Enterprise, both have read, write, and admin in common. GitHub Enterprise also adds triaged permissions for managing issues and pull requests without write access and maintain permission for managing <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">repositories</a> without the ability to access destructive or sensitive actions. The <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-setting-permissions-in-azure-devops-git/">GitHub</a> Enterprise Actions presented here are by no means exhaustive, but represent those most applicable to repositories. It’s clear looking at the wording of Bitbucket Cloud and GitHub Enterprise branch actions that they are restrictions on the default project and repository permissions.</p>
<h1 id="DEMO-Setting-Permissions-in-Azure-DevOps-Git"><a href="#DEMO-Setting-Permissions-in-Azure-DevOps-Git" class="headerlink" title="DEMO: Setting Permissions in Azure DevOps Git"></a>DEMO: Setting Permissions in Azure DevOps Git</h1><p>Let’s see how the Git variant of <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">repo</a> permissions work. As with the earlier TFVC repo, go to project settings and click repositories under repos. I’ll go to the repository and allow Hallam Sql to bypass policies when pushing to the repo. We can see that permission has been propagated down to the branches. Now for some inexplicable sadistic reason, I will deny him the ability on the list server DBs, and DB select with tree view branches while leaving that permission intact for the master branch. Whatever your motivation, these <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/distributed-repository-permissions/">permissions</a> at repo or branch level will allow you to bypass for individuals or groups, any branch policies you have implemented.</p>
<h1 id="DEMO-Not-Using-an-Azure-Repo"><a href="#DEMO-Not-Using-an-Azure-Repo" class="headerlink" title="DEMO: Not Using an Azure Repo?"></a>DEMO: Not Using an Azure Repo?</h1><p>Before there were <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-setting-permissions-in-azure-devops-git/">Azure DevOps Git</a> <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">repos</a>, there were just Git repos. And as you would expect, they function identically. So it’s very easy to integrate a non-Azure Repository with an <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> Pipeline. When you create your pipeline, just select the appropriate provider from where is your code. Next, select your repository and supply your credentials. Once the pipeline is configured, you’ll be able to run it, pulling the code from the Vanilla GitHub repository. As we set this up using the Wizard, we’re still none the wiser about the mechanism for connecting to the GitHub repo. If I go into project settings and then into service connections, I can see the connection to github.com. Drilling down into it, we can see the authentication details. Alternatively, you may want to import a GitHub repo to your Azure DevOps project. This is easily done by going to your projects repo and under files, select import repository from the repo drop-down list. As I’ve already authenticated with GitHub, I’m not asked to provide my credentials and the import goes ahead.</p>
<h1 id="DEMO-Third-Party-Pipeline"><a href="#DEMO-Third-Party-Pipeline" class="headerlink" title="DEMO: Third-Party Pipeline"></a>DEMO: Third-Party Pipeline</h1><p>What if you’re using or want to use <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">Azure DevOps</a> but you have all your build pipelines set up on another platform like Jenkins? This scenario is easy enough to set up from the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps point of view. We can create a service hook trigger that will initiate the build process in a Jenkins pipeline.</p>
<p>First, let’s see the process in action. I’ve got a .NET Core web app with source code in an Azure DevOps repo, and I’ve set up a service hook connection to a Jenkins instance running on an Azure VM. Azure has a pre-configured Jenkins VM service that is easy to spin up and comes preloaded with the necessary Azure plugins. You can go directly to Jenkins and download the software, but you will have to install the Azure plugins yourself, which isn’t a big deal. When I commit a change, a build will be kicked off. We can see that in action over on the Jenkins pipeline view.</p>
<p>Now that the deployment is completed we can see my commit comment is listed under changes and if we drill down into the details it shows what files have been changed. Going back to Azure DevOps, we can see the commit that triggered the build process. To set up the service hook, go to Project Settings under General and click service hooks and click the new service hook plus button. Select the service, in this case Jenkins. Just for ease of demonstration, I’ll select code pushed as the trigger in this repository.</p>
<p>Next, I’ll fill in the Jenkins detail section. With the Azure end set up, let’s go back to Jenkins and see how the integration looks from there. This is a pipeline build with parameters, with the most important parameter being the Azure Service Principal credentials. The actual pipeline code is pretty straight forward, We check out the code from the Azure DevOps repository. If the repository is private we need to supply credentials and wrap the Git command in with credentials using Azure Service Principal.</p>
<p>Next is the publish stage, which is a script calling .net. This is running on a Linux Box so it is called with a shell script command. On Windows, this would be a batch command. Finally, we deploy with azureWebAppPublish using our service principal credential parameter, resource group parameter, and an app name parameter. The source directory is where the built code can be found. The key to this process is the service principal credentials, so let’s have a look at that under Jenkins credentials. Subscription, client, and tenant IDs are those of the registered app under Azure Active Directory, and the client secret is the secret associated with that app registration.</p>
<p>Remember to give permissions to access Azure DevOps under API permissions so you can pull code from a private repository. If you have all of these details correctly entered into Jenkins but are getting an invalid subscription message, the chances are you haven’t set up the correct role assignments for your service principal.</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>In this <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/course-introduction/">course</a>, we’ve seen how the differences between centralized version control systems like <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/demo-setting-permissions-in-azure-devops-tvfc/">TFVC</a> in distributed Git-based systems impacts multiple and remote teams, and how these different architectures deal with access permissions. I think it’s fair to say that Git and its derivatives are the preeminent systems at this time, and the main reason for this is <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/branching-strategy-overview/">branching</a>.</p>
<p>Branching is technically easy and often referred to as cheap in comparison with centralized systems equivalence. While branching may be quick and easy, as with everything in life, there are no free lunches and all branches must end up being merged back into the main or master trunk in the end. This merge date must be repaid through the pull request mechanism. This is where we see how our different branching strategies evolved to lighten this burden.</p>
<p>Obviously, not all software projects organizations are the same and they have different needs, but what I find interesting is how branching models proliferated, became more complex, and convoluted, but we’re always hamstrung by the same basic issue; merging. In this new automated DevOps world, this very important, but potentially manually intensive task is a real fly in the ointment. I like how the release flow strategy goes back to basics, which is trunk-based development off the master branch, but with a twist of using feature flags to isolate incomplete work. This method addresses one of the key pain points by keeping branches as short as possible and related to just one feature or function. Of course, no branching strategy is a silver bullet and the release flow only fulfills its promise with a rigorous testing on branches before the pull request.</p>
<p>There are always going to be situations where you need to revert changes and this is sometimes referred to in complex situations like trying to get the sugar out of your coffee. Smaller branches merged more often can definitely minimize the associated grief in this situation. The bottom line is that all strategies are conventions using the same tools and is up to you to settle on a strategy that best works for you. Having said that, repository systems do offer mechanisms to enforce best practices or the strategy you have decided to adopt.</p>
<p>In <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps, branch policies can enforce proper behavior within <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-version-control-on-azure-repos-1049/pull-requests-and-merging/">pull requests</a> by requiring a minimum number of approvers, for example. Branch policies also allow you to enforce particular merging strategies. Finally, we took a look at integrating third-party repositories with Azure DevOps pipelines and how to integrate Azure DevOps repos with a Jenkin build pipeline. It turns out we’re spoiled for choice with version control systems and it’s just a case of finding which one is most easily adapted to your situation.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Designing-for-Quality-and-Security-With-Azure-DevOps-3/" rel="prev" title="AZ-400-Designing-for-Quality-and-Security-With-Azure-DevOps-3">
      <i class="fa fa-chevron-left"></i> AZ-400-Designing-for-Quality-and-Security-With-Azure-DevOps-3
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Implementing-and-Managing-Azure-Build-Infrastructure-5/" rel="next" title="AZ-400-Implementing-and-Managing-Azure-Build-Infrastructure-5">
      AZ-400-Implementing-and-Managing-Azure-Build-Infrastructure-5 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-Version-Control"><span class="nav-number">2.</span> <span class="nav-text">What is Version Control?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Let%E2%80%99s-Git-to-the-Point"><span class="nav-number">3.</span> <span class="nav-text">Let’s Git to the Point</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Branching-Strategy-Overview"><span class="nav-number">4.</span> <span class="nav-text">Branching Strategy Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Strategies"><span class="nav-number">5.</span> <span class="nav-text">The Strategies</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pull-Requests-and-Merging"><span class="nav-number">6.</span> <span class="nav-text">Pull Requests and Merging</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Work-Items-and-Branching-in-Azure-DevOps"><span class="nav-number">7.</span> <span class="nav-text">DEMO: Work Items and Branching in Azure DevOps</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Setting-Access-Permissions-on-Repositories"><span class="nav-number">8.</span> <span class="nav-text">Setting Access Permissions on Repositories</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Setting-Permissions-in-Azure-DevOps-TFVC"><span class="nav-number">9.</span> <span class="nav-text">DEMO: Setting Permissions in Azure DevOps TFVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Distributed-Repository-Permissions"><span class="nav-number">10.</span> <span class="nav-text">Distributed Repository Permissions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Setting-Permissions-in-Azure-DevOps-Git"><span class="nav-number">11.</span> <span class="nav-text">DEMO: Setting Permissions in Azure DevOps Git</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Not-Using-an-Azure-Repo"><span class="nav-number">12.</span> <span class="nav-text">DEMO: Not Using an Azure Repo?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Third-Party-Pipeline"><span class="nav-number">13.</span> <span class="nav-text">DEMO: Third-Party Pipeline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Summary"><span class="nav-number">14.</span> <span class="nav-text">Summary</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
