<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionHello, and welcome to this course on Decoupled and Serverless Architectures in AWS, where we’re here to help you on your journey to prepare for the AWS Certified Cloud Practitioner certi">
<meta property="og:type" content="article">
<meta property="og:title" content="AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18">
<meta property="og:url" content="https://example.com/2022/11/18/AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionHello, and welcome to this course on Decoupled and Serverless Architectures in AWS, where we’re here to help you on your journey to prepare for the AWS Certified Cloud Practitioner certi">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T02:03:44.000Z">
<meta property="article:modified_time" content="2022-11-20T23:00:10.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 22:03:44" itemprop="dateCreated datePublished" datetime="2022-11-18T22:03:44-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:00:10" itemprop="dateModified" datetime="2022-11-20T19:00:10-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS-Practitioner/" itemprop="url" rel="index"><span itemprop="name">AWS-Practitioner</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AWS-Cloud-Practitioner-Decoupled-and-Serverless-Architectures-CLF-C01-18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Hello, and welcome to this course on Decoupled and Serverless Architectures in AWS, where we’re here to help you on your journey to prepare for the AWS Certified Cloud Practitioner certification.</p>
<p>Before we get started, I’d like to introduce myself. My name is Danny Jessee, and I am one of the trainers here at Cloud Academy, specializing in AWS – Amazon Web Services – and AWS certifications. In this course, the AWS team will be presenting a series of lectures that introduce the concepts of decoupled and event-driven architectures, as well as some serverless services currently available in AWS that may be covered on the exam. Feel free to contact me with any questions using the details shown on the screen, or you can always get in touch with us here at Cloud Academy by sending an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>, where one of our Cloud experts will reply to your question.</p>
<p>This course has been specifically curated to help you pass the AWS Certified Cloud Practitioner exam and is ideal for anyone who is looking to learn more about decoupled and serverless architectures in AWS in preparation for the exam. Passing the AWS Certified Cloud Practitioner exam is a great first step for anyone looking to grow within their current career, or transition to a new career entirely.</p>
<p>The objective of this course is to provide a high-level introduction to decoupled and event-driven architectures in AWS. We’ll see how services such as the Amazon Simple Queue Service, or SQS; the Amazon Simple Notification Service, or SNS; and Amazon Kinesis can be used within these architectures. And finally, we’ll provide a survey-level overview of serverless services in AWS.</p>
<p>These topics and services are covered by Domains 1 and 3 in the official AWS Certified Cloud Practitioner exam blueprint: Cloud Concepts and Technology. The other courses in this learning path cover the remaining exam content and will ensure that you are fully prepared to sit this exam.</p>
<p>This course is designed for anyone who is new to cloud computing, so no prior experience with AWS is necessary. While it may be helpful to have a basic understanding of AWS and its services, as well as some exposure to AWS Cloud design, implementation, and operations, this is not required as all of the concepts we will introduce in this course will be explained and reinforced from the ground up.</p>
<p>Here at Cloud Academy, we strive to keep our content current to provide the best training available. If you have any feedback, positive or negative, or if you notice anything that needs to be updated or corrected for the next release cycle, please reach out to us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>. Thank you!</p>
<h1 id="What-is-a-Decoupled-and-Event-Driven-Architecture"><a href="#What-is-a-Decoupled-and-Event-Driven-Architecture" class="headerlink" title="What is a Decoupled and Event-Driven Architecture?"></a>What is a Decoupled and Event-Driven Architecture?</h1><p>Hello and welcome to this lecture where I want to explain what we mean by decoupled and event-driven architectures.</p>
<p>Firstly, let me focus on decoupled architecture, and to understand decoupling, we first need to address monolithic architectures which is how applications have been done in the past. Monolithic applications were built with a close and tight-knit relationship to each other, for example, between the front end and back end of an application. If a change was made the back end, it could easily disrupt services and operation in the front end, and that’s because they were very tightly coupled together and had a lot of built-in dependencies against each other. Although this had some advantages, it wasn’t able to offer what a decoupled architecture could.</p>
<p>When you implement and design a solution using a decoupled architecture you are building a solution put together using different components and services that can operate and execute independently of one another, instead of being closely coupled to each of its connecting components to operate and function. Each component in a decoupled solution is effectively unaware of any other changes to other components due to the segregation of boundaries applied.</p>
<p>Each service within a decoupled environment communicates with others using specific interfaces which remain constant throughout its development regardless of what configurations are made. By having this layered and independent approach, you are able to design, develop and configure each component without worrying about any dependencies within your solution. This allows your development teams to work faster and more efficiently as their scope of operation is refined on a particular service or component. They can make changes to a specific area of the application without having to worry about affecting other components, this helps to drive innovation and progress at a far greater rate.</p>
<p>As you go through this course, I will introduce you to an AWS service that is commonly used in a decoupled architecture, this being Amazon SQS, the Simple Queue Service.</p>
<p>Let me now look at Event-Driven Architectures.</p>
<p>Event-driven architectures closely relate and interact with decoupled architectures, however, services in an event-driven architecture are triggered by events that occur within the infrastructure. So what is an event? Well, an event can be a number of things, for example, a change of state, so a resource such as an EC2 instance changing from ‘running’ to ‘stopped’—that is a change of state, or perhaps an order has been placed on your website and an item has been moved from for sale to sold, that could be a change of state within your application.</p>
<p>When utilizing and implementing event-driven architectures in AWS, they will typically have three components: a producer, an event router, and consumers.</p>
<p>A producer is the element within the infrastructure that will push an event to the event router. The event router then processes the event and takes the necessary action in pushing the outcome to the consumers. By having the event router sat between both the producer and consumers, each of these two components are decoupled from each other and carry the benefits of a decoupled architecture that I discussed previously.</p>
<p>As we go through this course, I will introduce you to a number of different event-driven services, which act as the event routers, and these include Amazon SNS (the Simple Notification Service), Amazon Kinesis, and AWS Lambda.</p>
<h1 id="Introduction-to-the-Simple-Queue-Service"><a href="#Introduction-to-the-Simple-Queue-Service" class="headerlink" title="Introduction to the Simple Queue Service"></a>Introduction to the Simple Queue Service</h1><p>Hello and welcome to this lecture, which will cover the SQS Service, Simple Queue Service. With the continuing growth of microservices and the cloud best practice of designing decoupled systems, it’s imperative that developers have the ability to utilize a service, or system, that handles the delivery of messages between components. And this is where SQS comes in. SQS is a fully managed service offered by AWS that works seamlessly with serverless systems, mock services, and any distributed architecture. Although it’s simply a queueing service for messages between components, it does much more than that. It has the capability of sending, storing, and receiving these messages at scale without dropping message data, as well as utilizing different queue types depending on requirements. And it includes additional features, such as dead-letter queues. It is also possible to configure the service using the AWS Management Console, the AWS Sarli, or using the AWS SDKs. Let me focus on some of the components to allow to understand how the service is put together. The service itself uses three different elements. Two of which are a part of your distributed system, these being the producers and the consumers, and the third part is the actual queue, which is managed by SQS and is managed across a number of SQS servers for resiliency. Let me explain how these components work together.</p>
<p> The producer component of your architecture is responsible for sending messages to your queue. At this point, the SQS service stores the message across a number of SQS servers for resiliency within the specified queue. This ensures that the message remains in the queue should a failure occur with one of the SQS servers. Consumers are responsible for processing the messages within your queue. As a result, when the consumer element of your architecture is ready to process the massage from the queue, the message is retrieved and is then marked as being processed by activating the visibility timeout on the message. This timeout ensures that the same message will not be read and processed by another consumer. When the message has been processed, the consumer then deletes the message from the queue. Before moving on, I just want to point out a little more relating to the visibility timeout. As I said, when a message is retrieved by a consumer, the visibility timeout is started. The default time is 30 seconds, but it can be set up to as long as 12 hours. During this period, the consumer processes the message. If it fails to process a message, perhaps due to a communication error, the consumer will not send a delete message request back to SQS. As a result, if the visibility timeout expires and it doesn’t receive the request to delete the message, the message will become available again in the queue for other consumers to process. This message will then appear as a new message to the queue. The value of your visibility timeout should be longer than it takes for your consumers to process your messages. I mentioned earlier that there were different types of queues. </p>
<p>These being standard queues, first-in, first-out queues, and dead-letter queues. Standard queues, which are the default queue type upon configuration, support at-least-once delivery of messages. This means that the message might actually be delivered to the queue more than once, which is largely down to the highly distributive volume of SQS servers, which would make the message appear out of its original order or delivery. As a result, the standard queue will only offer a best-effort on trying to preserve the message ordering from when the message are sent by the producers. Standard queues also offer an almost unlimited number of transactions per second, TPS, making this queue highly scalable. If message ordering is critical to your solution, then standard queues might not be the right choice for you. Instead, you would need to use first-in, first-out queues. This queue is able to ensure the order of messages is maintained, and that there are no duplication of messages within the queue. Unlike standard queues, FIFO queues do have a limited number of transactions per second. These are defaulted to 300 per second for all send and receive and delete operations. If you use batching with SQS, then this changes to 3,000. Batching essentially allows you to perform actions against 10 messages at once within a single action. So, the key takeaways between the two queues are for standard queues, you have unlimited throughput, at-least-once delivery, and best-effort ordering. And for first-in, first-out queues, you have high throughput, first-in, first-out delivery, and exactly-once processing. For both queues, it is also possible to enable encryption using server-side encryption via KMS. A dead-letter queue differs to the standard and FIFA queues as this dead-letter queue is not used as a source queue to hold messages submitted by producers. Instead, the dead-letter queue is used by the source queue to send messages that fail processing for one reason or another. This could be the result of cloud enabling your application, corruption within the message, or simply missing information within a database that no message data relates to.</p>
<p>By the way, if the message can’t be processed by a consumer after a maximum number of tries specified, the queue will send the message to a dead-letter queue. This allows engineers to assess why the message failed, to identify where the issue is, to help prevent further messages from falling into the dead-letter queue. By viewing and analyzing the content of these messages, it might be possible to identify the problem and ascertain if the issue exists from the producer or consumer perspective. A couple of points to make with a dead-letter queue is that is must be configured as the same queue type as the source is used against. For example, if the source queue is a standard queue, the dead-letter queue must also be a standard queue type. And similarly, for FIFA queues, the dead-letter queue must also be configured as a FIFA queue. Before I end this lecture, I just want to show a quick demonstration on how to set up a queue and some of the configuration options available during this process. That now brings me to the end of this lecture which covered an introduction to the Simple Queue Service.</p>
<h1 id="Introduction-to-the-Simple-Notification-Service"><a href="#Introduction-to-the-Simple-Notification-Service" class="headerlink" title="Introduction to the Simple Notification Service"></a>Introduction to the Simple Notification Service</h1><p>Hello, and welcome to this lecture, covering the SNS service. It’s likely that out of the free services covered within this course, this is a service you may have come across the most, simply due to its integration with a number of other AWS services. The Simple Notification Service is used as a publish and subscribe messaging service. But what does this mean? SNS is centered around topics, and you can think of a topic as a group for collecting messages. Users or endpoints can then subscribe to this topic, and messages or events are then published to that particular topic. When a message is published, all subscribers to that topic receive a notification of that message. This helps to implement event-driven architectures within a decoupled environment.</p>
<p>Again, much like SQS, SNS is a managed service and highly scalable, allowing you to distribute messages automatically to all subscribers across your environment, including mobile devices. It can be configured with the AWS management console, the CLI, or the AWS SDK. As mentioned, SNS uses a concept of publishers and subscribers, which can also be classed as consumers and producers, and works in the same principle as SQS, from this perspective. The producers or publishers send messages to a topic, which is used as the central communication control point. Consumers or subscribers of the topic are then notified of this message by one of the following methods, HTTP, HTTPS, email, email JSON, Amazon SQS, application, AWS Lambda, or SMS.</p>
<p>Subscribers don’t just have to be users. For example, it could be a web server, and they may be notified of the message via the HTTP protocol. Or if it was a user, you could use the email notification method and enter their email address. SNS offers methods of controlling specific access to your topics through a topic policy. For example, you might want to restrict which protocols subscribers can use, such as SMS, or HTTPS, or only allow access to this topic for a specific user. The policy themselves follow the same format as IAM policies. For more information on IAM policies, please see our existing IAM course which is available within our library of content. I will now perform a demonstration, showing you how topic policies are configured and the different options within them, which allows you to apply access security to your topics. </p>
<p>So in this demonstration, I’m just gonna show you where to find your SNS policies and how to edit them, et cetera. So if we go to our SNS service, and if we create a new topic, go down to create topic here. And if we give it a topic name of Cloud Academy, and then go to create topic. From here, we can now edit the topic policy. So if we go to other topic actions, we can see here, the second option down is edit topic policy. Now there’s two views here, a basic view and an advanced view. The basic view shows the policy is very much a point and click overview, so it’s very simple to understand.</p>
<p>So this top section here allow these users to publish messages to this topic. We can say only myself, everyone or only these users, and we can enter users in this box here. I’m just gonna leave it as only me for this demonstration. And at the bottom here, you can see, allow these users to subscribe to the topic. So again, you can restrict it to only yourself, everyone or only specific AWS users. And down here, you can also specify different delivery protocols as well that I spoke about earlier. So again, for this demonstration, I’m just gonna leave it as only me. If we go to the advanced view, we can see the policy as a JSON view.</p>
<p>Now I explain that if you are familiar with IAM policies, this is laid out in exactly the same fashion. So we have the version at the top. We have a statement. We have a statement ID. And then also we have the usual parameters of effect principle, an action and resource. So if you look at this, for example, we can see that this will allow any principle with the following actions. For example, we can publish the SNS. We can delete the topic, et cetera. Now if we scroll down, we can see resource. And this resource line shows that it’s the Cloud Academy topic that I just created. Now you can edit this policy directly in here and simply click on update policy if you’re confident to do so. But like I say, it follows the same principles as IAM policies. And it’s through these policies that you can control access to your SNS topics. And that’s it.</p>
<p>Both SNS and SQS integrate with each other, which makes sense as both of these services are designed to run in a highly distributed and decoupled environment. By working together, a solution can be designed to send messages to subscribers through a push method, or SQS handles incoming messages and waits for consumers to pull data. Therefore, being able to use SNS as a producer for an SQS queue makes perfect sense from a development perspective. To do this, you’ll need to have your SQS queue subscribed to the SNS topic. And this can be achieved by performing the following steps within this demonstration.</p>
<p>So in this demonstration, I’m gonna show you how you can use SNS as a producer for an SQS queue. So from within the management console, if we go to our SQS service again, and we can find the queue that we had earlier. So if I just select that, and then go to queue actions, then you can see down here, you have subscribe queue to an SNS topic. If I select that, now I can select the topic region and the topic that I want. Now the topic that I created earlier was in the EU Ireland region, so by selecting this drop down list, I should be able to find the Cloud Academy topic. And there it is. And that gives our topic ARN. If we say subscribe, we get a confirmation message to say that this queue has successfully subscribed to the following SNS topic, which is the Cloud Academy topic. And it also set up the relevant permissions as well to allow that to happen. So if we click on okay, now we can test this out. If we go through to SNS, and if we go to our topics and Cloud Academy, and the first thing that we can see is the SQS queue is actually subscribed to this topic. So that was the action we just carried out.</p>
<p>Now I wanna test this by publishing a message to this topic to make sure that SQS receives a copy of it. So if I click on publish to topic, and I’ll just create a message here just called, Cloud Academy Test. This is a test, and click on publish message. Now that has published a message to that topic, so any subscribers should receive a copy, which means our queue should also receive a copy. So if we go back to SQS, we can see here that messages available is one. So if we go across and select our queue, and go to view&#x2F;delete messages, click on start polling for messages, we can see here straight away that we have our message that we received from the topic. And if we go to more details, we can see here the subject of Cloud Academy Test, and also the message, “This is a test.” So this proves that we have successfully used SNS as a producer for this SQS queue. Much like SQS, SNS also integrates well with AWS Lambda, a key serverless computer service. To learn more about serverless technologies, you can view our existing learning path, entitled, “<a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/serverless-computing-aws-developers-45/">Serverless Computing on AWS for Developers</a>,” which can be found <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/serverless-computing-aws-developers-45/">here</a>.</p>
<p>This integration allows SNS notifications to invoke existing Lambda functions. Like SQS, the Lambda function has to be subscribed to the topic. Then when a message is sent to the topic, the message is pushed out to the Lambda function to invoke it. The function itself uses the payload of the message as an input parameter, where it can then alter the message if required, or forward the message onto another AWS service, or indeed to another SNS topic.</p>
<p>To configure AWS Lambda to work with the topic, you can perform the following steps. From within the SNS dashboard of the AWS management console, select topics. Select the topic that you want to subscribe to with the Lambda function. Select actions and subscribe to topic. Using the protocol menu, select the AWS Lambda option. Then you must select the Lambda function to be used from the endpoint dropdown box.</p>
<p>Finally, you can select the version or alias of the function, and select the latest version of the function. Choose the latest option. Select create subscription. To gain more insight into this process and to see an example of how this can be used to create a sample message history store using SNS Lambda and Amazon DynamoDB, you can view this blog post made by AWS found here. We also have a lab which would teach you how to process SNS notifications with a Lambda function. As a simple example, the lab uses Python to log custom metrics to CloudWatch based on the message payload. That now brings me to the end of this lecture, which covered an introduction to the Simple Notification Service.</p>
<h1 id="Introduction-to-Amazon-Kinesis"><a href="#Introduction-to-Amazon-Kinesis" class="headerlink" title="Introduction to Amazon Kinesis"></a>Introduction to Amazon Kinesis</h1><p>Hello and welcome to this lecture introducing Amazon Kinesis.</p>
<p>Amazon Kinesis makes it easy to collect, process, and analyze real-time streaming data so you can get timely insights and react quickly to new information. With Amazon Kinesis, you can ingest real-time data such as application logs, website clickstreams, IoT to imagery data, and more, into your databases, your data lakes and data warehouses.</p>
<p>It enables you to process and analyze data as it arrives and responds to it in real-time, instead of having to wait until all your data is collected before the processing can begin.</p>
<p>Amazon Kinesis can continuously capture terabytes of data per hour from hundreds or thousands of sources, such as website clickstreams, financial transactions, social media feeds, IT logs, and location-tracking events.</p>
<p>From a storage perspective, Amazon Kinesis does not store persistent data itself, unlike many of the other Amazon big data services. As a result, Amazon Kinesis needs to be deployed as part of a larger event-driven solution.</p>
<p>Amazon Kinesis provides three different solution capabilities. Amazon Kinesis Streams: This enables you to build custom applications that process or analyze streaming data for specialized needs. This comes in 2 different variations, Kinesis Data Streams, and Kinesis Video streams. Data Streams offer a real-time data streaming service capable of elastically scaling to support hundreds of thousands of data feeds to help you build real-time solutions, such as live dashboards or identifying any security anomalies. Video Streams are designed to securely elastically scale and ingest video streams on a massive scale, connecting to millions of video streaming devices, where it can then store, and encrypt the data ready for processing by your data analytics solutions. Amazon Kinesis Data Firehose. This enables you to load streaming data into Amazon Kinesis Analytics, Amazon S3, Amazon RedShift, Amazon Elastic Search, and Splunk. Amazon Kinesis Analytics. This enables you to write standard SQL queries on streaming data.</p>
<p>Amazon Kinesis Streams is based on a platform as a service style architecture where you determine the throughput of the capacity you require and the architecture and components are automatically provisioned and stored and configured for you. You have no need or ability to change the way these architectural components are deployed.</p>
<p>An Amazon Kinesis stream is an ordered sequence of data records. A record is the unit of data in an Amazon Kinesis stream. Each record in the stream is composed of a sequence number, a partition key, and a data blob. The data blob is the data of interest that your data producer adds to a stream.</p>
<p>So what is a Producer? A producer is an entity that is continuously pushing data to Kinesis Streams, for example, a web service sending log data to a stream is a producer.</p>
<p>And then we have Consumers, now a consumer receives records from Amazon Kinesis Streams and processes them in real-time. Consumers can store their results using an AWS service, such as Amazon DynamoDB, Amazon Redshift, or Amazon S3. These consumers are known as Amazon Kinesis Streams applications and typically run on a fleet of EC2 instances. You need to build your applications using either the Amazon Kinesis API or the Amazon Kinesis Client Library.</p>
<p>Okay, let’s have a look at the architecture that underpins the Amazon Kinesis Firehose. While still under the Kinesis moniker, the Amazon Kinesis Firehouse architecture is different to that of Amazon Kinesis Streams.</p>
<p>Amazon Kinesis Firehose is a fully-managed service for delivering real-time streaming data to destinations such as Amazon S3, Amazon Redshift, Amazon Elasticsearch Service and Splunk.</p>
<p>With Kinesis Firehose, you do not need to write applications as your consumers. Instead, you configure your data producers to send data to Kinesis Firehose, where the service then automatically delivers the data to the destination that you specify. You can also configure Amazon Kinesis Firehose to transform your data before data delivery.</p>
<p>A delivery stream is the underlying entity of Kinesis Firehose. You use Kinesis Firehose by creating a Firehose delivery stream and then sending data to it, which means each delivery stream is effectively defined by the target system that receives the streamed data. Firehose can also invoke an AWS Lambda function to transform incoming data before delivering it to the selected destination. You can configure a new Lambda function using one of the Lambda blueprints AWS provides or you can choose on of your existing Lambda functions.</p>
<p>Let’s have a quick look at the difference between Amazon Kinesis Streams and Firehose. Amazon Kinesis Streams is a service for workloads that require custom processing, per incoming record, with sub-one-second processing latency, and a choice of stream processing frameworks.</p>
<p>Amazon Kinesis Firehose is a service for workloads that require zero administration, with data latency of 60 seconds or higher. You use Firehose by creating a delivery stream to a specified destination and send data to it, you do not have to create a stream or create a custom application as the destination. But Firehose is limited to S3, Redshift, and Elasticsearch and Splunk as the data destinations.</p>
<p>Amazon Kinesis Analytics is a fully managed service that enables you to quickly author SQL code that continuously reads, processes and stores data. With Amazon Kinesis Analytics, you can ingest in real-time billions of small data points. Each and every individual data point can then be aggregated to provide intelligent business insights, which in turn can be used to continually optimize and improve business processes.</p>
<p>Working with Kinesis Analytics requires you to perform three steps. You must create an input stream. Input streams typically come from streaming data sources such as Kinesis streams. Create SQL processing logic, a series of SQL statements that process input and produce output. The SQL code will typically perform aggregations and generate insights. And finally, create an output stream. Output streams can be configured to hold intermediate results that are used to feed into other queries or be used to stream out the final results. Output streams can be configured to write out to destinations such as S3, Redshift, Elasticsearch and&#x2F;or other Kinesis streams.</p>
<p>What is the benefit of using Kinesis Analytics, well, the ability to maintain peak performance of a business is often related to the ability to make timely decisions. The earlier we can make informed and actionable decisions, the quicker we can adjust and maintain optimal performance, and hence highlights the importance of being able to process data in near to real-time.</p>
<p>The type of decision making we can make is based on the age of the data itself. Considering this, we can see that data processed within real-time allows us to take preventative and&#x2F;or predictive decisions.</p>
<p>Your SQL querying statements that you author represent the most important part of your Kinesis Analytics application as they generate the actual analytics that you wish to derive. Your analytics are implemented using one or several SQL statements, used to process and manipulate input and produce output.</p>
<p>This process can involve intermediary steps, whereby the outputs of one query feed into a second in-application stream. This process can be repeated multiple times until a final desired result is achieved persisted to an output stream.</p>
<h1 id="A-Survey-of-Serverless"><a href="#A-Survey-of-Serverless" class="headerlink" title="A Survey of Serverless"></a>A Survey of Serverless</h1><p>Hello, my name is Will Meadows and I would like to welcome you to this survey of the serverless services. </p>
<p>Today we’re going to go over all the different serverless categories and services that are available within <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/amazon-web-services/">AWS</a>. Initially serverless was a very small domain that only offered Lambda as the sole option for someone getting into the serverless category. However, At this point in time, there are over 12 different serverless services for you to choose, each providing a unique benefit and solving a specific problem. </p>
<p>That’s why I think it’s important for someone just getting in the domain to take a survey of all of these options to get a real understanding of what it is that they want to learn about. This lecture will spend just a few minutes on each of the 12 different services to help you drive forward your learning and education. And for each service where we have a course, I will link to that lecture so that way you can continue your education on anything that you deem fit.</p>
<p>So grab a coffee, sit back and relax, and let’s take a look at all the different serverless options that AWS has available.</p>
<p>To get us started there are currently three different categories of serverless services. These categories include: serverless compute services, serverless application integration services, and serverless database services.</p>
<p>I think we should start off by looking at something you’re probably the most familiar with, which is the serverless compute services.</p>
<p>Compute is probably one of the most important things that any application will have to deal with. It is the way that the actual work gets performed. </p>
<p>Traditionally this job was completed by fleets of servers all running specific applications or code to complete their jobs. These jobs might range from running websites, big data analytics, or even dealing with long-running applications like video game servers.</p>
<p>In this category of serverless compute there are currently two different services that can complete these jobs in varying ways. Each of the options have some positives and negatives that lend themselves to some use cases over others. Let’s start off with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/understanding-aws-lambda-to-run-scale-code/introduction/">AWS Lambda</a> and take a look at where it might shine.</p>
<p>Lambda was released in 2014 as the first serverless service. It offered the ability to run code, without needing to manage a server, for up to 5 minutes at a time. </p>
<p>This new paradigm of compute, the idea of functions as a service Is what really pushed forward the category of serverless as a whole.</p>
<p>Lambda is an event-driven service. This means that it needs some kind of action, or event, to trigger the code you wish to run. In many situations, the event or action is just a change of state. This change of state could be something as simple as when an image is placed into an S3 bucket.</p>
<p>These days Lambda has increased its execution time to up to 15 minutes, and has greatly increased its range of functionality from its 2014 introduction.</p>
<p>If you are just starting your journey into this space, getting a deeper understanding of lambda will really help your learning and understanding of every other serverless offering.</p>
<p>We have a course that covers AWS Lambda in-depth over here if you want to learn more: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/understanding-aws-lambda-to-run-scale-code/introduction/">https://cloudacademy.com/course/understanding-aws-lambda-to-run-scale-code/introduction/</a></p>
<p>This service allows you to run serverless containers on <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/compute-fundamentals-for-aws/ecs-ec2-container-service/">Amazon ECS</a> (the elastic container service). If you are currently running a container-based application, and would like to convert to a serverless format, this is the perfect solution for you! </p>
<p>One of the coolest aspects about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/course-automatically-created-2018-10-02-113135226141/c3l4-terraform1/">Fargate</a> is that it allows you to get over the 15 minutes execution hurdle that plagues AWS lambda. You are allowed to run your Fargate tasks (containers) for an unlimited amount of time. The serverless component of AWS Fargate is in regard to where those containers actually live.</p>
<p>If you would like to learn more about ECS, Fargate, and Microservices - we have a course that covers all of that right here: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-microservices-containers-ecs-1828/introduction-to-microservices-containers-and-ecs/">https://cloudacademy.com/course/introduction-microservices-containers-ecs-1828/introduction-to-microservices-containers-and-ecs/ </a></p>
<p>Application integration services are a part of the interstitial glue that helps weave everything together. They allow you to connect to and send data to other applications and AWS services. There are a number of these types of offering available nowadays, and they all fill a slightly different niche. </p>
<p>Amazon has a serverless event-based service called Amazon Eventbridge that functions as a serverless event bus. Think of an event bus as a kind of event coordinator. It allows you to intake information from both external SAAS providers, AWS services (over 90 different ones are supported), and even your own custom applications. With these input events, Amazon Eventbridge can filter, manage, and direct them to other systems that listen for them, and are able to take action based on their content. It does this filtering process with routing rules, which give you full control over your event bus.</p>
<p>If you would like to learn more about this service, please check out this course over here: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/connecting-application-data-using-amazon-eventbridge-1301/introduction/">https://cloudacademy.com/course/connecting-application-data-using-amazon-eventbridge-1301/introduction/</a></p>
<p>AWS Step Functions can best be described as a serverless state machine service. For those who don’t know what a state machine is, think of your standard vending machine. </p>
<p>A vending machine sits there waiting for a customer to come up to it and input money (that’s its idle state). Once money has been added into the machine, it movies onto the next state, which would be item selection. The user inputs their choice, and the machine moves into the final state of vending the product. After the workflow has been completed it returns back to the idle state, waiting for another customer.</p>
<p>AWS Step Functions allow you to create serverless workflows just like the vending machine, where you can have your system wait for inputs, make decisions, and process information based on the input variables.</p>
<p>If you would like to know more about AWS Step Functions please check out this course: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/aws-step-functions-1117/introduction/">https://cloudacademy.com/course/aws-step-functions-1117/introduction/</a></p>
<p>Amazon SQS (the simple queue service) is a messaging queue system. It can help you decouple your applications by providing a system for sending, storing, and receiving messages between multiple software components. SQS is a managed service that offers two types of queues: FIFO and Standard (which is a best-effort ordering queue, with at least once delivery).</p>
<p>Amazon SQS is a fantastically useful service that works splendidly in most serverless applications but can also find a home in many standard architectures.</p>
<p>For more on SQS please check out this course here: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-queue-service/">https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-queue-service/</a></p>
<p>This service is a Pub-Sub notification service that provides both application-to-application or application-to-person communication. This communication works well for high-throughput applications as well as many-to-many messaging between distributed systems. SNS can also act as an event-driven hub similar to Amazon Eventbridge - It’s just more bare bones.</p>
<p>For more info on Amazon SNS take a look over here: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-notification-service/">https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-notification-service/</a></p>
<p>AWS has created a fully managed service called Amazon API Gateway which helps deal with: building, publishing, monitoring, securing, and maintaining API within AWS. It works quite well at any scale, and is able to support serverless, generic web applications, and even containerized workloads on the back end. </p>
<p>You can build your APIs for public use, for private use, or even for third-party developers. The best part about it is that it is entirely serverless, and does not require you to manage any infrastructure and you pay just for what you use.</p>
<p>The service is also able to handle accepting and processing hundreds of thousands of concurrent requests. If things start to get out of hand, API Gateway is able to monitor all traffic and can throttle requests as desired.</p>
<p>Please check out this introductory course on API gateway if you are interested in learning more: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-amazon-api-gateway-2140/introduction-to-api-gateway/">https://cloudacademy.com/course/introduction-amazon-api-gateway-2140/introduction-to-api-gateway/</a></p>
<p>AWS app sync allows you to manage and synchronize data across multiple mobile devices and users. The service also allows users to modify data while offline, and having those changes be automatically synced when the device reconnects to the internet. </p>
<p>This functionality allows you to build real-time, multi-user collaborative tools and applications that work between browsers, mobile applications, and even Amazon Alexa skills. </p>
<p>AWS AppSync uses GraphQL to enable clients to fetch, change, and subscribe to data from databases, microservices, and APIs all from a single GraphQL endpoint.</p>
<p>Setting up and managing databases is a huge challenge for many organizations. Having to deal with scalability and right-sizing can take a lot of knowledge, time, and money to get set up just right. Having data storage be serverless can greatly increase your productivity as well as reduce a lot of headaches. There are a number of fantastic data storage services available serverlessly these days, so let’s take a moment to look at each of them.</p>
<p>Amazon s3 is an object-based serverless storage system that is able to handle a nearly unlimited amount of data. S3 provides great scalability, availability, and speedy performance for many different use cases. Amazon S3 is able to support files as small as zero bytes, and tops out at five terabytes. </p>
<p>Objects stored in S3 have a durability of 11 nines (99.999999999%) and so, the likelihood of losing data is extremely rare.</p>
<p>S3 has native integrations with AWS lambda, allowing you to create event-based workflows with ease. Additionally, s3 provides some of the cheapest data storage available through the use of the S3 Glacier storage class. </p>
<p>Please take a look over here at this course if you wish to learn more about Amazon S3: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/aws-storage-fundamentals-2016/introduction-32/">https://cloudacademy.com/course/aws-storage-fundamentals-2016/introduction-32/</a></p>
<p>DynamoDB is a fully managed serverless, NoSQL database that has been built to run high-performance applications at any scale. The service can operate at single-digit millisecond latency which is very valuable for time-sensitive applications that require the fastest response times. DynamoDB is a key-value store database that has no strict design schema that it needs to conform to.</p>
<p>DynamoDB is designed to be highly available. Your data is automatically replicated across three different availability zones within a geographic region. In the case of an outage or an incident affecting an entire hosting facility, DynamoDB transparently routes around the affected availability zone.</p>
<p>For more information about DynamoDB please take a look at this course: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/working-with-amazon-dynamodb/introduction-31/">https://cloudacademy.com/course/working-with-amazon-dynamodb/introduction-31/</a></p>
<p>Amazon RDS Proxy is a fully managed, serverless, highly available database proxy for Amazon RDS. The proxy allows you to build serverless applications that are more scalable than your standard direct to RDS implementations.</p>
<p>If you are opening many new connections to your RDS databases through lambda functions or other serverless methods - you might have issues when large surges of connections are required.</p>
<p>RDS Proxy allows you to pool and share already established database connections, reducing the latency of your applications when establishing a new connection. Additionally RDS Proxy helps the availability of your serverless application by denying access to unserviceable connections that may degrade your database’s performance. </p>
<p>Aurora serverless is a fully on-demand SQL database configuration for Amazon Aurora. It automatically starts up, shuts down, and scales its capacity based on the application’s needs. It operates on a pay-per-second basis while the database is active, and can be used through a simple database endpoint. If you ever need to switch over to standard workload and leave the realm of serverless, you can do so with the click of a button.</p>
<p>Aurora is built to be highly available, fault-tolerant, and self-healing as it replicates your data 6 ways across multiple availability zones.</p>
<p>If you would like to learn more about Aurora serverless please take a look at this course over here: <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/amazon-aurora-high-availability/aurora-serverless/">https://cloudacademy.com/course/amazon-aurora-high-availability/aurora-serverless/</a></p>
<p>AWS has developed and positioned a well-thought-out series of serverless services that can help almost any application. These days there’s pretty much an in-place stand-in for every piece of normally servered component, that can be run serverlessly.</p>
<p>I would highly recommend looking at the coursework for any of the services covered today that interested you. Each course dives directly into the service and can really help explain where it fits in an architecture and what problems it can help you solve.</p>
<p>Hopefully, you’ve enjoyed this survey of all the service services and categories within AWS. My goal was to give you just a little taste of each facet of serverless so that way you could explore and find what you want to learn about.</p>
<p>My name is Will Meadows and I’d like to thank you for spending your time here learning about Serverless. If you have any feedback, positive or negative, please contact us at <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>, your feedback is greatly appreciated, thank you!</p>
<h1 id="4Introduction-to-the-Simple-Notification-Service"><a href="#4Introduction-to-the-Simple-Notification-Service" class="headerlink" title="4Introduction to the Simple Notification Service"></a>4<strong>Introduction to the Simple Notification Service</strong></h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/serverless-computing-aws-developers-45/">Serverless Computing on AWS for Developers</a></p>
<h1 id="6A-Survey-of-Serverless"><a href="#6A-Survey-of-Serverless" class="headerlink" title="6A Survey of Serverless"></a>6<strong>A Survey of Serverless</strong></h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/understanding-aws-lambda-to-run-scale-code/introduction/">Understanding AWS Lambda to Run &amp; Scale Your Code</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-microservices-containers-ecs-1828/introduction-to-microservices-containers-and-ecs/">Introduction to Microservices, Containers, and ECS</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/connecting-application-data-using-amazon-eventbridge-1301/introduction/">Connecting Application Data using Amazon EventBridge</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/aws-step-functions-1117/introduction/">AWS Step Functions</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-queue-service/">Introduction to the Simple Queue Service</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/using-sqs-sns-ses/introduction-simple-notification-service/">Introduction to the Simple Notification Service</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/introduction-amazon-api-gateway-2140/introduction-to-api-gateway/">Introduction to API Gateway</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/aws-storage-fundamentals-2016/introduction-32/">Storage Fundamentals for AWS</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/working-with-amazon-dynamodb/introduction-31/">Working with DynamoDB</a></p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/amazon-aurora-high-availability/aurora-serverless/">Amazon Aurora High Availability</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AWS-Cloud-Practitioner-Introduction-to-Virtual-Private-Cloud-VPC-17/" rel="prev" title="AWS-Cloud-Practitioner-Introduction-to-Virtual-Private-Cloud-VPC-17">
      <i class="fa fa-chevron-left"></i> AWS-Cloud-Practitioner-Introduction-to-Virtual-Private-Cloud-VPC-17
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AWS-Cloud-Practitioner-Management-Fundamentals-CLF-C01-19/" rel="next" title="AWS-Cloud-Practitioner-Management-Fundamentals-CLF-C01-19">
      AWS-Cloud-Practitioner-Management-Fundamentals-CLF-C01-19 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-a-Decoupled-and-Event-Driven-Architecture"><span class="nav-number">2.</span> <span class="nav-text">What is a Decoupled and Event-Driven Architecture?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction-to-the-Simple-Queue-Service"><span class="nav-number">3.</span> <span class="nav-text">Introduction to the Simple Queue Service</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction-to-the-Simple-Notification-Service"><span class="nav-number">4.</span> <span class="nav-text">Introduction to the Simple Notification Service</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction-to-Amazon-Kinesis"><span class="nav-number">5.</span> <span class="nav-text">Introduction to Amazon Kinesis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-Survey-of-Serverless"><span class="nav-number">6.</span> <span class="nav-text">A Survey of Serverless</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4Introduction-to-the-Simple-Notification-Service"><span class="nav-number">7.</span> <span class="nav-text">4Introduction to the Simple Notification Service</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6A-Survey-of-Serverless"><span class="nav-number">8.</span> <span class="nav-text">6A Survey of Serverless</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
