<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to Implementing Continuous Delivery. My name’s Matthew Quickenden and I’m going to be guiding you through understanding how to configure and implement continuous delivery with Azur">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-400-Implementing-Continuous-Delivery-on-Azure-14">
<meta property="og:url" content="https://example.com/2022/11/18/AZ-400-Implementing-Continuous-Delivery-on-Azure-14/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to Implementing Continuous Delivery. My name’s Matthew Quickenden and I’m going to be guiding you through understanding how to configure and implement continuous delivery with Azur">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T00:37:47.000Z">
<meta property="article:modified_time" content="2022-11-27T16:25:20.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AZ-400-Implementing-Continuous-Delivery-on-Azure-14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-400-Implementing-Continuous-Delivery-on-Azure-14 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AZ-400-Implementing-Continuous-Delivery-on-Azure-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-400-Implementing-Continuous-Delivery-on-Azure-14
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 20:37:47" itemprop="dateCreated datePublished" datetime="2022-11-18T20:37:47-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-27 12:25:20" itemprop="dateModified" datetime="2022-11-27T12:25:20-04:00">2022-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-400/" itemprop="url" rel="index"><span itemprop="name">AZ-400</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AZ-400-Implementing-Continuous-Delivery-on-Azure-14/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AZ-400-Implementing-Continuous-Delivery-on-Azure-14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to Implementing Continuous Delivery. My name’s Matthew Quickenden and I’m going to be guiding you through understanding how to configure and implement continuous delivery with Azure DevOps. If you have any questions, feel free to connect with me on LinkedIn or send an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This course is intended for people who want to become a Microsoft certified Azure DevOps engineer, or who need to combine people, process and technologies to continuously deliver products and services to meet business objectives. While it is very useful to have experience with Agile processes and practices, having a basic understanding will be okay. Having some experience in <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/overview-of-azure-services/">Azure administration</a> will be useful during this course, but not essential. DevOps is still considered a very new practice and students who may not have any experience or background in Agile, but are just interested in learning, will be able to benefit from this course.</p>
<p>By the end of this course, you should be able to decide on a release strategy and implement a release pipeline with various checks and triggers to deploy artifacts. Your feedback on this course is important so give it a rating when you’re finished. We have lots to cover so let’s get started.</p>
<h1 id="What-is-Continuous-Delivery"><a href="#What-is-Continuous-Delivery" class="headerlink" title="What is Continuous Delivery?"></a>What is Continuous Delivery?</h1><p>You will hear continuous delivery is often combined with the term CI&#x2F;CD or continuous integration, continuous delivery, but what is it? It was born as part of a manifesto to software development but has evolved over time and is used widely in various different ways. Wikipedia defines continuous delivery as “An approach in which teams produce software in short cycles, ensuring that software can be reliably released at any time and when releasing the software, doing so manually. It aims at building, testing, and releasing software with greater speed and frequency. The approach helps reduce cost, time, and risk of delivering changes by allowing for more incremental updates to an application in production. A straightforward and repeatable deployment process is important for continuous delivery.”</p>
<p>Continuous delivery is made possible through the implementation of processes enabling a trusted and repeatable deployment pipeline. While manual <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/triggers-approvals-and-release-gates/">triggers</a> are often used to move through these different stages as a pipeline matures and the process itself gains trust, many of these triggers become automated, which we will look at during <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/introduction/">this course</a>.</p>
<h1 id="Designing-a-Release-Strategy"><a href="#Designing-a-Release-Strategy" class="headerlink" title="Designing a Release Strategy"></a>Designing a Release Strategy</h1><p>Before we get started with some hands-on exercises, we need to cover some general concepts. A release is a package that holds a versioned set of artifacts specific to your release pipeline. All the information needed to execute the tasks are stored in the release pipeline and are included from the stages, variables, triggers through to approvers and release gates. There can be multiple releases for one release pipeline.</p>
<p>An important distinction is understanding the difference between the release and the deployment. A release is talking about implementation of a new feature or a change to an existing system in the way it works. A deployment is pushing the code into a new environment. This distinction is also referred to as separating your functional release (or feature release) from your technical release (deployment to an environment). These two things often get mixed together because they are tightly coupled together in the release process.</p>
<p>Many of the tools and programs you will use do not exist within the Azure DevOps environment. To access these services, you will need to create services connections. You may have already created some of these but here is a list of commons service connections. Each service connection will have the specific parameters needed to create connect to that service.</p>
<p>An artifact is content required to deploy your application or infrastructure. The process is to build, collect, or create the content once and then release or deploy that same content over and over again. This is done by ensuring that the base artifacts don’t change, if it changes how can we guarantee a consistent result? Here is the list of artifact sources and depending on your purpose or project you may choose different sources, there is no one right answer.</p>
<p>Looking over these sources there are some general types we can consider. There are builds where a build pipeline creates a package that is versioned and stored where the contents can’t be changed. There are version control solutions, where the release pipelines pull code and packages directly from source control. There are container registries, that allow you to pull a specific version of a container helping with deployment consistency.</p>
<p>This list will obviously change over time, but the important thing to remember is the goal of this style of deployment is to create a consistent deployment that you can rely on. To achieve this, the source artifact you need to select needs to be stable. The only thing that should be changing when you deploy to a new environment is the configuration. The ‘thing’ you are deploying should never change.</p>
<p>An important consideration is what type of auditing do you need to provide for these source artifacts? As more layers are added, it often becomes more important to know what line of code changed and who checked in the code, or merged that branch. There are many tools and techniques out there to help with code in relation to version control but each organization needs to implement their own process around what they need to do and what to release.</p>
<p>Environments define collection of resources such as Kubernetes namespaces, Web Apps, VMs, or databases that can be targeted by deployments from a pipeline. Typical examples of environments include Dev, Test, Staging, and Production. Some benefits of using environments are that you can view deployment history by environment, users permissions, resource health, or traceability for tracking work items or tasks against an environment.</p>
<p>A deployment stage is a logical representation of somewhere you want to release your artifacts to, some easy examples are dev, test, or production. A key aspect of a stage is the boundaries of a stage. Each stage should be independent from each other, meaning you can release code independently to that stage. Depending on what you’re deploying, this will also help define your boundaries.</p>
<p>With modern cloud platforms and PaaS services we can now define infrastructure as code or IAC. We can now define infrastructure that can be versioned and deployed along with the applications, for example, using ARM templates to build out network load balancers, virtual machines in Azure or even Kubernetes using AKS. Leveraging this power means a deployment stage can be completely torn down and rebuilt to ensure the source artifacts or package truly contain all the content and that our release contains all the configuration to ensure the solution is fully deployable.</p>
<p>Now that we have covered some fundamental concepts, let’s take a look at the prerequisites needed to work through our lab. We are going to create one pipeline, containing four stages, we’re going to use a GitHub project for our <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> infrastructure as code, we’re going to use an HTML project as the website. By the end of this lab, we will be able to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/lab-01-prep-work/">trigger a deployment</a> simply by checking in a change to the HTML code or completing a pull request.</p>
<h1 id="Lab-01-Prep-Work"><a href="#Lab-01-Prep-Work" class="headerlink" title="Lab 01: Prep Work"></a>Lab 01: Prep Work</h1><p>The goal of this lab series is to leverage two public projects in our own environment. One project will be used to create the infrastructure in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a>, in this case, we’re going to be using web apps. The other project will be an HTML webpage. The focus here is on the deployment pipeline. We’re gonna take a little bit of time and just get things set up.</p>
<p>So, a couple of prerequisites. You’re gonna need a GitHub account. You’ll need an Azure DevOps account, which should be free to sign up. You’ll need an Azure account, and you should have an editor installed with Git on your local machine. In this case, I’ve got Visual Studio Code, which I would recommend for this demo.</p>
<p>First thing, once we’ve got our Azure DevOps, you should have an organization setup. And if you don’t already have a project, we’ll create one. So, you may have one from previous sessions. We’re gonna use version control Git and select through different work items. In this case, I’ll use Agile, and create. So, here we have our boards, repos, and the pipelines.</p>
<p>The first thing we’re gonna need to do is create some service connections under project settings, or you can go down to service connections, and create a service connection. Here we can see the variety of different systems we can connect to. In this case, our first connection will be to the Azure Resource Manager, or ARM. So we’ll give this “MyAzure” and allow pipelines. Select your subscription. You’ll need to log in, just to ensure you have authentication. It helps if you’re already signed in, and it will authorize Azure DevOps to use the Azure Resource Manager.</p>
<p>Now that we have that connection, we’ll create a new connection to GitHub. Next here. And we’re just going to grant authorization to Azure pipelines and authorize. You do have other connection options, but for this case, this is the easiest. And we’re just going to call this GitHub. So you can have access to different users with different repositories. So we now have two service connections created in our Azure DevOps project.</p>
<p>Next, we need to create a repo where we’re going to import our HTML project. So this GitHub connection we’re going to get the infrastructure from, if we go to repos and files, and we’re gonna chose to import a repository. We need to go find the repository we’re gonna import. So let’s go over here and the project you’re looking for is called the <a target="_blank" rel="noopener" href="https://github.com/azure-samples/html-docs-hello-world">Azure-Samples&#x2F;html-docs-hello-world</a>. If we search for that, we should find that project here, it’s a public project.</p>
<p>If we scroll down, you should see this clone or download and it will give you this connection here. So let’s take that back to our file repo and we’re gonna import this html-docs-hello-world. So if we do import, that will process that request and copy all those files into a repository inside our own Azure DevOps space. So this is part of the CI area, the continuous integration. So we’re not gonna cover a lot of this, I’ll assume you already know something about it. But we will go through enough just to use it.</p>
<p>Now that we have a copy of the project in Azure DevOps, we need to clone it to our desktop. And this is where Visual Studio Code comes in, it’s connected easily with this link here. You open the page, we’re gonna select a repository for this. So I’m just gonna do Documents, Labs, and select repository. That will then copy a set of those files to my local system and I can open them.</p>
<p>You can see the same project that was available in my Azure DevOps repo is now available on my local system. I need to create a new branch. There are multiple ways to do this. You can do that through visual studio code, through the Repo. Here we can say, create new branch, provide branch name, dev. Enter. And we can see we have now that changed to sync cloud. So if we push that change into the cloud, and we go have a look at our branches, we can see we have a Dev branch.</p>
<p>That’s the prerequisites set up, we have two service connections to Azure, to GitHub, we’ve also imported a GitHub project into our own Azure Repo, created a Dev branch and we have that code synchronized on our local system in visual studio code.</p>
<h1 id="Triggers-Approvals-and-Release-Gates"><a href="#Triggers-Approvals-and-Release-Gates" class="headerlink" title="Triggers, Approvals, and Release Gates"></a>Triggers, Approvals, and Release Gates</h1><p>Triggers, Approvals and Release Gates. Once you have defined different types of stages, next you need to consider how the package (a versioned set of artifacts) will be moved through the stages. To release the package from one stage to the next, we can use triggers. There are different types of triggers we can use: Continuous deployment Triggers, Scheduled Triggers, Manual Triggers.</p>
<p>Here is a screenshot of the visual representation of the Azure DevOps Release pipeline. The artifacts are in green, pre-deployment conditions, triggers, and approvals are in purple, and post-deployment approvals are in orange. Scheduled release triggers occur as we would expect with a scheduled task. You can add multiple schedules to one trigger. For instance, perhaps you want to refresh your test environment each night with the code that’s currently in development.</p>
<p>Artifact Push&#x2F;Pull Triggers. We can trigger a release based on the source control actions. Here we have a simple Git project showing push and pull actions. In our pipeline, we can create triggers that initiate a new release based on the action of a Git push or the merging of a pull request.</p>
<p>Stage triggers help move and deploy the artifacts through the various stages of a release. This can be after the release, after a stage, or we can create them as manual triggers requiring user interaction. There are additional options such as auto-deploy triggers. You can base these on post-deployment conditions or a particular event. We can also add approvals. Approvals can give you additional control over the start or completion of a deployment pipeline. Each stage has a pre-deployment and post-deployment condition. One of these conditions can include waiting for users to manually approve or reject a deployment. There are various options around this and you can configure the pipeline to continue with the deployment if no response is received during a period of time.</p>
<p>You can enable gates at the start of a stage, in the pre-deployment conditions, or at the end of a stage in the post-deployment, or both. There are a few types of gates available out of the box as we can see here: Azure Machine Learning, Check Azure Policy, Invoke Azure functions, REST API, Query Azure Monitor alerts, or Query work items. You can add more than one test to a gate, you can add additional tests found on the marketplace or even create your own.</p>
<p>An example of a release gate could be a test that the website responds to a query in a certain amount of time and that there are currently no open issues or bugs against this version of the website. Once you have your tests configured, you have to define the evaluation criteria that define whether or not a gate is marked pass or fail. This includes the time between the re-evaluation of a gate or the sample interval and the timeout after which a gate will fail. </p>
<p>Here are two examples from the Microsoft documentation. The following diagram illustrates the flow of a gate evaluation where, after the initial stabilization delay period and three sampling intervals, the deployment is approved. We can see from the history that the first gate failed twice and was finally approved when all three gates passed. The next diagram illustrates the flow of a gate evaluation where, after the initial stabilization delay period, not all gates have succeeded at the sampling interval. In this case, after a timeout period expires, the deployment is rejected. We can see gate one failed twice while gate two was passing and then gate one passed and gate two failed. Not all three gates succeeded at the same time.</p>
<h1 id="Lab-02-Set-Up-Stages"><a href="#Lab-02-Set-Up-Stages" class="headerlink" title="Lab 02: Set Up Stages"></a>Lab 02: Set Up Stages</h1><p>Now that we have our prerequisites done, we can come down to our pipelines and releases and add a new pipeline. There are some templates here to help you get started with the tasks. In our case, we’re just gonna use the blank pipeline, and we need to bolt on our two artifacts. One, we have the HTML code, and two, we have the Azure ARM templates. So we’re gonna pick an artifact and we’ll use the Azure repo first.</p>
<p>If we choose the drop-down project CDLab, we’ll see our hello world. I’ll select the master branch and latest version of that code. An alias is created underscore in front of the name, and we have our first artifact.</p>
<p>Next, we’re gonna add again and we’re gonna choose Github. And now we can see the service connections we created earlier are available here. We wanna search for a repository, as if we were in Github. So this is now using the Azure quickstart templates. If I use the ellipses, I can search partial names and find the projects I need. From the drop-down, we’ll choose master and latest version.</p>
<p>We see the alias is created with an underscore and we have our first two artifacts. Now we’d like to create a development environment, so we’re gonna push these two artifacts through four stages. There’s gonna be development and test and pre-prod and production. Right now, we’re just gonna focus on doing the development and test stages. So we’ll create a new stage, empty, and we’ll call it development. From the development stage, we wanna add another stage called test and, by default, it adds it in order. We can look at the pre-deployment conditions here for the test stage and if we look at the visual representation of what’s occurring, if we change our option here for select trigger for the stage after release or manual, we can see that line disappears.</p>
<p>In our case, we are deploying after a stage and we’re deploying after the development stage. You can the different choices here in the dropdown. We just need to give ourself a name. And we can save this as our first revision. We now have our first pipeline. If we choose Create Release, we’ll get a new release option and we can click Create. We’ll see there’s Release-1 and we can also go view that release here under View Releases. And here’s a history of our releases. So we can see the development environments currently in progress and there’s a test environment to go.</p>
<p>If we dive into this release, we get a more visual representation of what’s happening and we can look into the logs of what the agents are doing and the tasks that they’re executing. So currently it’s downloading deltas. However, we had to trigger that manually, which is not really what we wanna do. We wanna automate this process. So while this is underway, we’re gonna go click edit our pipeline again and we’re gonna add some triggers.</p>
<p>What we want to do is when we push code or pull code into our HTML branch, we wanna <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/creating-a-release/">create the releases</a> for our development environment and production, so we want a pull request we’ll push into production and a development request we’ll push through the development and test environments. We’re also gonna create a schedule for the test so every Monday to Friday at 3 a.m. the test environment will be updated with the latest development code.</p>
<p>If we click on the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/triggers-approvals-and-release-gates/">continuous deployment trigger</a> for html-docs-hello-world, we can enable both the pull request and push, and we’ll create a filter for the master branch on the pull request. We’re given a warning here which shows us that zero out of two stages are enabled. That’s fine. We’ll close that. In the pre-deployment conditions for the development environment, we do wanna add an artifact filter. So we don’t wanna update the development branch with master code, so we’ll pick our html-docs-hello-world and we’ll put the filter in there for dev. In the pre-deployment conditions for test, we’re gonna add a schedule, and Monday to Friday 3 a.m. Close that and we’ll save. So we’ll say Added Triggers.</p>
<p>If we bring up our Visual Studio code that we had connected earlier, we’re gonna just change this name and we’ll just say a tiny hello world application. Save. You’ll need to commit that change, and synchronize it to the cloud. So now, as that synchronizes to the cloud and we come back and look at our release history or our releases, we can see a second release was created and it’s kicking off now. If we look at that release, we can actually see here this artifact is the thing that triggered the release and we’re running again. I’ll just pause this while it downloads the artifacts and we’ll see what happens with the test environment.</p>
<p>We can see the development environment’s succeeded and our test environment is scheduled. We could choose to deploy that manually. For now, we’ve completed our first successful trigger to push code through our pipeline.</p>
<h1 id="Creating-a-Release"><a href="#Creating-a-Release" class="headerlink" title="Creating a Release"></a>Creating a Release</h1><p>Next, we’re going to explore the specifics of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/lab-03-creating-a-pipeline/">creating a release pipeline</a>. Variables allow a pipeline to be dynamic, meaning we can feed data from one task into the next task. It means we can reuse tasks, <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/lab-02-set-up-stages/">stages</a>, and pipelines for multiple deployments. We can scope variables to different parts of the release, for instance, we can set up a set of variables and scope it to the development stage and then create another set of variables with the same name for a production stage.</p>
<p>You can use variable groups to store values that you want to take control of, and make them available across multiple pipelines. Azure DevOps also has a number of predefined variables as shown here. Here’s a brief look at a few items accessible from the agent variable. The Microsoft documentation will help you explore what these predefined variables are and what you can use them for. It is highly likely that in your pipeline you’ll need to pass through secure data. This could be an SSH key, passwords, API secrets, ClientID or even configuration settings. Variables have a built-in option to store secrets securely. It is important to use this flag as shown here in the screenshot as it means the secrets will be hidden while being used, for example, in the output of log files.</p>
<p>Another option is to store your secret in Azure Key Vault. If you create a Key Vault in Azure and populate a secret, then you’ll need to authorize Azure DevOps to retrieve the secrets from the Key Vault itself. Once authorized, you’ll be able to add secrets directly from Key Vault to Azure DevOps variable groups as we can see here on the screenshot. And now we can see the secret in Azure DevOps.</p>
<p>A pipeline contains tasks which can be executed repeatability often with parameters and variables used to drive dynamic execution. There are many standard tasks that come out of the box and there’s a growing list of tasks available on the marketplace. There are also generic shell tasks which will let you execute your own custom script like PowerShell or SSH tasks. You can browse marketplace tasks from within the Azure DevOps console. If you select Add, you’ll be walked through the process of installing that task into your DevOps environment.</p>
<p>Task groups allow you to group a series of tasks, already defined, into a single reusable task. This task group can be added to the pipeline, just like any other task. You can define configuration variables, allowing the task to be reusable. A major advantage of task groups is that it allows groups of tasks to be centrally managed, reducing the complexity involved of managing this sequence at scale.</p>
<h1 id="Lab-03-Creating-a-Pipeline"><a href="#Lab-03-Creating-a-Pipeline" class="headerlink" title="Lab 03: Creating a Pipeline"></a>Lab 03: Creating a Pipeline</h1><p>So now that we’ve created our skeleton of the release pipeline, we want to populate those with tasks that will deploy the web application. The first step in this process, though, is we’re gonna create some variables groups. So we go to variable group, add variable group, we’re gonna call this VarDev. And we’re gonna add three variables to this. We’re gonna add the ResourceGroupName. We’re gonna add the SlotName, and the WebAppName. Resource group, we’ll call WebAppDev. The slot, we already have a production slot so we’re gonna add one for development, and the web app needs to be unique within Azure itself. So I’ll just use my initials, the date, mywebapp and add dev on the end and save.</p>
<p>To save time, we’re gonna clone this variable set and we’ll call it VarProd. And take the dev off here, we’re gonna call this PreProduction or PreProd. And take the dev off the end, save. If we go back to the library, we can see we’ve created two, VarDev, VarProd, and we can now go to our release. Here’s our pipeline and the releases we have so far. If we edit that release and go to variables, first thing we’re gonna do is add ourself a single variable for the pipeline release called Region. So that’s the Azure region we’re gonna deploy to. In this case, I’m in West US and that’s where we’re gonna deploy it. We go to the variable group, we can link a variable group. And we’re gonna link VarDev to the stages rather than the release for test and development.</p>
<p>So now we can return to the pipeline and add some tasks. If we click on the view stage tasks here, we’ll add our first task, and we’ll search for Azure resource group deployment and add. If we click the task itself we can choose the subscription which we’ve already set up with the service connections. The resource group, we wanna use the variables, which was the dollar ResourceGroupName. And it is case sensitive so make sure you get that right. We can have Region in here and linked artifacts. In this case, we wanna use the Azure deployment template. So if we go look just briefly at the GitHub project for the quickstart template <a target="_blank" rel="noopener" href="https://github.com/Azure/azure-quickstart-templates/tree/master/quickstarts/microsoft.web/webapp-basic-windows">101-webapp-basic-windows</a>, we can see we’ve got the azuredeploy.json and the parameters file.</p>
<p>If we look at the Azure deploy file, we can see we’ve got a WebAppName, so we need to be case sensitive of that. And the rest of these parameters we’re gonna pick up through the default parameters. So if we use the ellipsis, we can see our two, our source artifacts, and we have the hello world from our Azure Repo and the GitHub quickstart template.</p>
<p>If we open this up and scroll down, 101-webapp-basic-windows, expand that and choose the azuredeploy.json file. So that’s the template we wanna use. Now we wanna do the same thing and pick out the parameters file. Scroll down. Parameters. In our case, we want to give a parameterized, our parameter for the web application name to this template. But instead of creating our own parameter file, we’ll just override one particular parameter. So that’s the parameter we wanna override. So we’re just gonna do a dash, parameter, dollar, WebAppName. And there are other deployment options there, we can choose the names and outputs and other things. We’re not gonna touch any of that at the moment. We’re gonna add our next job, which is an archive job.</p>
<p>We’re looking for the HTML docs root directory. So we don’t need all the Azure quickstart templates, that’s really large, we just wanna zip up the docs file there. We’re also gonna un-tick this prepend root. We don’t want the root name on that, we just wanna deploy directly to it. If we have any trouble, we can use the verbose output, so let’s tick that on. The next task we wanna add is Azure PowerShell. You have a choice here of using a file path for a script or we’re gonna use some inline code. I’ve already typed this out to save some time, but we’ll review it. Pick your service connection. So the code here is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-AzWebAppSlot -ResourceGroupName $(ResourceGroupName) -Name $(webAppName)-webapp -Slot $(SlotName) -AppServicePlan AppServicePlan-$(WebAppName)</span><br></pre></td></tr></table></figure>

<p>which is what the template does, so it actually adds <code>-WebApp</code> to the name and uses the app’s service name for that plan. So we’ll save that there.</p>
<p>We just need to come down, we’ve still got something wrong, it wants to know what version of PowerShell. So we’re just gonna use the latest version that’s installed. We’re gonna add another task which is the Azure app service. Deploy. Again, pick the service connection. I’m gonna copy these parameters in to save some time. So <code>$(webAppName)-webapp</code>. We wanna deploy to a slot, right. Paste in the ResourceGroupName here and the SlotName we want is again the parameter we’ve already created.</p>
<p>Now, in this case, we can see what’s next, we’re looking for the package or folder. So that’s what we’re creating in this archive file. So if we look at this output here, to keep things simple, we’re gonna call this the WebAppName. And we’re just gonna copy that parameter as it is into our app service package deployment. So in our staging directory, these are one of these predefined variables that exist within Azure DevOps. And we have one last task here, select deployment method. So it will try to auto-detect. In our case, we just wanna use the zip deploy. So we’ve gone and created the zip file, we’ve told it where to find that zip file, and we’ve told it how to deploy it. Fingers crossed, that should be the dev stage complete. So we’ll save that.</p>
<p>Next, we wanna go and create the tasks for test. In the tasks for test, we’re gonna do a swap application slots. So under app service manage, if we add that. We’re gonna pick our Azure subscription again. We’re gonna pick the app service name. So that’s our $(WebAppName)-webapp, $(ResourceGroupName), SlotName, which in our case was dev and we wanna swap that with production. So for our test environment, we’re moving the development stage into the test stage which is the production version of this web application. And we’ll click save.</p>
<p>So to kick this off we can commit some code again. So we’ll call this My World HTML app. My code. Save all and commit. And let’s push that change.</p>
<p>If we go look at our releases, we now see Release-6. There’s some ones I deleted in between that. And we’ll watch the development. If dive into the release itself we can see that job’s being initialized, artifacts being downloaded. We can also actually look at the pipeline again while we’re waiting for that.</p>
<p>Under the test task itself, if we scroll down here, we can see artifacts to download. So for that environment, we don’t actually need to download all this content, so that’s a very large file. So we’re just gonna un-tick these two and that should speed up our deployments. So we’ll save that and just say remove artifacts. So that’s not gonna happen till next release, which is fine because that will still help us through this version. So we’re still deploying. Waiting for output.</p>
<p>If we go over to our Azure subscription. So we’re in the Azure portal. Refresh that, we can see the web apps here. And then currently we have no resources inside it but we have one resource group template being deployed. And here, here’s the deployment name, date, time. And we can dive in and start looking a little bit closer at all these resources. I’m going to pause the video at this point and return once this web application has deployed into this resource group.</p>
<p>So let’s have a look at our environment. We can see the web service template finished deploying. If we go to the resource group we can see our AppServicePlan, we can see the dev slot here, we can see the application itself. So we’ve deployed into the dev slot. If we open up that slot there and then we do browse, we can see the static sample HTML which is the page we should be seeing.</p>
<p>If we return to our deployment, we can see we’re not scheduled to go into the test environment yet. It’s waiting. If we go back to the web app and look at our production slot and browse, we’ll get the default template here. If we return to this piece and choose to deploy manually, so rather than waiting for that scheduled time, we’re just gonna say manual kick off and we’re gonna deploy. That job is now queued.</p>
<p>While we’re waiting for that to complete, we’ll come back and have a look at the logs for this task itself. And we can see the various initialize job, download artifacts, here we created the resource group, it gives you the times of how long everything’s taken, can see the inline PowerShell script we used to create the slot and the application deployment, and the job’s been finalized.</p>
<p>If we return to the release, we can see now this is the downloading artifacts. So because we changed that artifacts before this release, that change isn’t in effect in this release v6. So we’re gonna have to wait for that to download, so you see how removing those artifacts that we don’t use will speed up this deployment time. Here we can see we’re up to the swap slots. It’s running.</p>
<p>So we’ve now got the -dev website, which is now empty because we have swapped the application into the new site. And running in our production slot for the dev environment is our sample application. So we’ve successfully created and executed our first pipeline task and moved a web application and deployed the infrastructure for it using parameters and a continuous deployment trigger.</p>
<p>As a final task, you can change the code here and make sure you change the header. I’ve just executed the change on the wrong title, so we’ll change the header this time and we’ll commit that change, so I’ll save that. Welcome to DevOps. And we’ll push that change there, so it’s gonna initiate a new release. And what we’re gonna see is into the dev slot we’re gonna see the Welcome to DevOps header change and our production or test version of the application will have the old version of the website. So we’ll minimize this and there’s my previous release I pushed into the… Didn’t make the change in the right heading. I’ll pause the video and we’ll just wait and see how that goes. So that release has completed. If we go refresh the main website, we can see we’ve still got our HTML code there. And if we refresh that site, we can see in the development slot we now have Welcome to DevOps.</p>
<h1 id="Creating-a-Release-Agents"><a href="#Creating-a-Release-Agents" class="headerlink" title="Creating a Release: Agents"></a>Creating a Release: Agents</h1><p>To execute your pipeline, you need to use agents. Agents are the workhorse of Azure DevOps. When a task in a pipeline needs to be executed, a job is created and submitted to an agent queue to be completed by an agent. Microsoft provides hosted agents which live in the cloud and need to be able to access public endpoints like AWS or <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a>. There is a variety of hosts you can select. Here is the current list. This will, of course, evolve over time. Depending on your pipeline, you may want to execute tasks at different locations, for instance, if you’re using a cloud-hosted Azure DevOps instance but want to execute your pipeline tasks on your on-premise servers, the cloud agents have no line of sight to your target systems; you’ll need to install a self-hosted agent. These agents will be able to talk to the cloud-hosted Azure DevOps and to the on-premise target servers.</p>
<p>If you need to execute these tasks in a private workspace, the Azure DevOps agent can be installed on a variety of platforms from Windows OS to macOS, Linux, and Docker, allowing for integrations into many different of environments. Agent pools allow you to group and create security boundaries for your agents. They are scoped to your DevOps organization, and agent pools can be shared across multiple teams and projects. This is because sometimes the infrastructure you’re deploying to is used by multiple teams.</p>
<p>A queue is used to collect jobs for an agent pool, which can be backed by one or many agents. When you create your release, you can specify what queue you want to use. Queues are scoped to your team project collection, this is so that you can share them across multiple team projects.</p>
<p>In your release pipeline, you can organize groups of tasks into jobs. Every build or deployment pipeline has at least one job, but can also be made up of many jobs. A simple example could be you have a mixed OS environment and you have tasks you need run on a Windows machine and tasks you need run on a Linux machine. In this case, you would define multiple release jobs, targeting different agents, to help achieve the desired deployment result.</p>
<p>Azure DevOps has the ability to run server jobs, which run tasks on the DevOps server itself. This is also referred to as agentless jobs. Agentless jobs do not require an agent to execute the task. The list of tasks that can be executed this way are small and contain tasks like manual intervention or REST API tasks.</p>
<p>Containers are becoming more common in today’s landscape. With a container, you can leverage existing containers built by vendors or by the community or by yourself. When you specify a container to run your tasks, the tasks will be executed inside that container.</p>
<p>Agents can be grouped together into deployment groups. Deployment groups are logical collections of agents that exist within an environment, for instance, Dev, Test or Production. Tasks that are targeted at a deployment group can run on some or all of the target servers, depending on the arguments you specify.</p>
<p>The last thing to cover in regards to jobs are Multi-configuration, and Multi-Agent. Typically, a task will run on a single agent, however, with multi-configuration, you can run the same set of tasks with different configurations. For instance, deploying the same website to different regions in Azure. With multi-agent, you can run the same set of tasks many times on a number of different agents. A good example would be a performance test, where you can run the same 10 tests on 20 different servers to validate the results.</p>
<h1 id="Ensuring-Release-Quality"><a href="#Ensuring-Release-Quality" class="headerlink" title="Ensuring Release Quality"></a>Ensuring Release Quality</h1><p>In some GitHub projects, you may have noticed these badges. The badges can define the states and different aspects of a project. These tags can be generated by Azure DevOps. This can help generate a view of what state various parts of the project are in, regarding build, deployments, release or even compliance.</p>
<p>We’ve already looked at release gates. If we explore this idea further, we can use release gates for two different purposes. The type we discussed earlier was using gates for automatic approval of a release. We can also use a release gate as a quality check. This could mean we create a query against work items that are looking for any outstanding bugs, issues, incidents against this release version. We could also do it for security scanning the code base or scanning artifacts like containers for security compliance.</p>
<p>Automating tests is another challenge when we start looking at incorporating it into continuous delivery pipelines. To automate testing, this chart has been designed and can help us define tests into four quadrants that helps us define what test we can automate. Tests in quadrant one are designed at the lowest level to test specific functionality, generally allowing them to be automated easier than some other tests. Quadrant four focuses on tests that require tooling to help, things like load testing, measuring performance, or security analysis. Tests in quadrant two and three move into the more complicated tests that are generally harder to automate or that simply require user interaction.</p>
<p>Documentation can have a number of different purposes from design, tracking work items, logging issues and bugs, installation, configuration, through to product operational manuals. There are a variety of approaches to this. One solution might not fit all use cases and you may need to use a combination. When we introduce more automation using release pipelines and increase the number of changes in an environment, we need to ensure that supporting documentation stays in sync.</p>
<p>Documentation can describe the changes that are present and being released into each environment and also needs to be in step with the product or environment changes, including a manual of how these new features and functionalities work. Manuals or documentation that we release together with the product should be treated as source code also.</p>
<p>A common method is using text files sometimes written using markdown syntax that are stored in the same directory or repository as the code. Another option is to create a new repository like a wiki. There are also wikis in Azure DevOps. In addition, we can use services like SharePoint or third-party solutions like Confluence by Atlassian. Another option is using work items to store and capture release notes. Depending on how you track your tasks, you could have bugs, tasks, user stories or other items which you can extract data from a particular field to cobble together a release notes text block allowing the task of extracting this text to be fully automated.</p>
<p>Now that we have covered ensuring the quality of a release pipeline, let’s return to the lab and look at <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-continuous-delivery-on-azure/lab-04-clones-stages/">cloning</a> and finishing off our lab environment.</p>
<h1 id="Lab-04-Clones-Stages"><a href="#Lab-04-Clones-Stages" class="headerlink" title="Lab 04: Clones Stages"></a>Lab 04: Clones Stages</h1><p>The next task we want to do is clone the stage tasks. So we’re just gonna clone this one and if we go into this task, we’re gonna pull this PreProd. We’re also gonna change the pre-production conditions, so this one’s actually after release, and we enabled the pull request previously on this one, so this is a pull request deployment, so we can turn that on for this particular stage, and we need to apply the artifact filter for html-docs, and this is for the master branch.</p>
<p>We’ll close that, and we need to clone the Test environment to be our production, so we’re gonna swap this slot with the PreProduction slot. So this is called Production, and we want this to be after the stage PreProd, and for Production, we don’t want it to be scheduled, we actually want to get some approvals, so we need a responsible person before we go through. There are other options here around the user can’t approve their own request. For our purposes, this is fine.</p>
<p>Next, we’ll need to change the variable scope. So at the moment, we’ve connected VarDev into these other environments we’ve just created. So we’re gonna change the scope of that and untick it for PreProd and Production, and we’re going to link ourselves with the VarProd, particular stages, and PreProduction, and Production. So we’ve now mapped to a different set of parameters to our secondary pipeline.</p>
<p>So let’s kick this one off. We’re gonna create the release manually and we’re gonna say here, select stages for manual trigger, so we’re gonna select PreProd, we’ll go to the release, and we can see now that the artifact doesn’t meet the conditions, but we can deploy this one. Job waiting. So we’ll let that go, and in the meantime, we’re gonna add some badges to our HTML pages to the… We’re gonna add some badges to the code, and if we go into options, under integrations, we can see here, we can say enable the deployment stage badges. Now each one of these is the actual badge for Development, Test, Production, PreProduction, and we can put that into our Visual Studio code.</p>
<p>Let’s copy the Development badge, and we’ll bring up Visual Studio Code. We’re gonna make this change in the markdown file, so let’s bring the markdown file back, and put the status at the top. We can see, just used markdown syntax and put in the pasted link from each of the different badges for each of the releases. We can save that and commit that code. And push that into dev branch. Save it first, come into our files section, and we’ll look at the html-docs for the dev branch, and look at the markdown syntax, we can see we’ve got three badges, never deployed, succeeded, succeeded, and I’ve got a syntax mistake here. Brackets the wrong way around. Go.</p>
<p>So by enabling those deployments, we can now see the different states in our markdown page, in our Github Repo, and we can obviously see that the PreProduction environment we manually kicked off deployed, now we’d like to do one last thing and just test if that pull request will work. So we can do that from within here. If we go to our Branches, we can see we’ve got the just now and our master branch which hasn’t changed. So if we go to our Pull requests, we’re gonna create a new pull request, dev into master, Pull trigger test. You can associate different items to see what’s changed. In this case, it’s gonna push everything we’ve done; we’re just gonna complete the request.</p>
<p>It’s important here that for this example, we’re not gonna delete the branch, so this is a nondestructive branch change, and complete the merge. If we return to our Pipeline Releases, we can see now we’ve got the pull request here, merge, and Release-14’s been created from the master. So again, we can see the trigger that effects this, we can see this artifact condition hasn’t been met because it’s not from the dev branch, whereas the artifact condition here has been met.</p>
<p>We still have an existing deployment in the background, so let’s go back to… Last deployment is down here. So that’s the one we triggered manually. We’ll have to wait for these to finish before we can test the release into production. Here we can see that the PreProduction’s kicked off. If we look at our Azure portal, at our Resource groups, we can see we’ve got a new resource group for a production version of this application. So we’ve got the PreProd slot, the production app. So we can see the PreProd deployment finished, and we’re now pending an approval for Matthew. So I can simply approve that task, go for production.</p>
<p>Before we do that, if we go to our webapp and look at the PreProd, and do a browse, we’ve got a Welcome to DevOps, and we go back to the webapp and our production slot, and browse. There’s nothing there. Go for production, Approve. It is now kicked off. We’ll give it a few minutes. You see in this case it isn’t downloading those artifacts now that we’ve taken that step out, so initialize the job and then swap the slots. So we see production has succeeded. We refresh this, we have Welcome to DevOps, and our PreProd environment will be blank. So I hope this walkthrough has been helpful and given you a good base to learn some of the other aspects of Azure DevOps.</p>
<h1 id="Implementing-Deployment-Patterns"><a href="#Implementing-Deployment-Patterns" class="headerlink" title="Implementing Deployment Patterns"></a>Implementing Deployment Patterns</h1><p>A deployment pattern refers to the process which you move an application, or piece of code, into production. Traditional methods used to involve large changes, less often. In the past two decades, the speed of IT has given rise to a business that needs to be more agile and respond fast to customer needs. This means they need to be able to handle changes and push out changes in infrastructure and applications faster. Organizations are learning to incorporate change on a regular basis—monthly, weekly, daily or even hourly—into their business. In this last section, we’re going to review some modern deployment patterns.</p>
<p>We have all likely heard of environment names such as dev, test, dev&#x2F;test, QA, pre-prod, and production. Depending on the size of your budget, you can see more or less of these environments. A common problem with these in the past has been keeping these environments consistent. Often, they are used for many different purposes, testing different technologies and applications all in one place. This can lead to configuration drift, making it harder to guarantee that testing in one environment is a true representation of what will happen moving into the next environment.</p>
<p>As application development has changed, the way we deploy and test applications has also changed: being able to utilize platforms as service, or PaaS, also the advent of containers, even through to infrastructure as code. All these types of things can be versioned and related to artifacts and stored and released using agile-related deployment patterns. Let’s have a look at some of these modern patterns.</p>
<p>Blue-green deployment is a technique that can reduce downtime and risk by running two identical production environments called Blue and Green. At any one time, only one environment is live, with the live environment serving all the production traffic. Often, a router is used to redirect the traffic. Code is released to the Blue environment and traffic is redirected from Green to Blue. This can allow you to ensure the new environment is truly running before flipping the switch to redirect the traffic without interrupting the user’s experience. It also has the advantage that if you need to roll back the change you can redirect the traffic back to the last known good deployment very easily.</p>
<p>A canary release means that most users will continue to use the known good application (in this case, v1). A small number of users are given access, or are redirected, to a new version of the application (in this case, v1.1). There are various ways you can filter these users to the canary release, through the user login IDs, a cookie, source IP address. The method itself will be dependent on the type of application and how you are filtering these users through. The impact of the change is small and if there are any issues, changes can be reversed or corrected quickly with minimal impact to the larger user base.</p>
<p>The next pattern has a couple of different names: feature toggles, feature flag or feature switch. It is the concept of adding a flag to a feature so that it can be enabled, or disabled, to a specific user or group of users, in the backend or frontend of the application. This allows a feature to be tested even before it is completed and ready for release. Feature toggles are used to hide, enable, or disable the feature. If we consider <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> itself, you may have seen video or demonstrations of Azure private preview features. Microsoft often invites people, or companies, into these preview groups before a feature goes GA. This allows them to test and work to refine that feature with a customer before it goes live.</p>
<p>Progressive exposure deployment is where new software is exposed to a subset of users that gets extended gradually over time. A conceptual illustration here shows the inner circle called canaries, followed by early adopters, and finally, the users sphere representing the remaining user base. This is often referred to as the impact, or blast radius, where the release is evaluated and observed before exposing them to more users. One of the terms that is often used in DevOps and Agile processes is, “Fail early and fail fast.” What this means is the sooner we know there is an issue, the sooner we can correct it. However, with some of these programs, they are so large that testing every aspect of a system is virtually impossible.</p>
<p>An example of this is Windows as a service. Windows has millions and millions of lines of code. Microsoft relies on their user base and customers to implement and test these new features against existing systems to make sure they continue to function as expected. We can see how the impact on the user base is affected over time. An advantage of this method is that users know they are in an early adoption program and they are often looking for, or expecting to see, issues.</p>
<p>A&#x2F;B testing, also known as split testing or bucket testing, is a method of comparing two versions of a webpage, or app, against each other to determine which one performs better. A&#x2F;B testing is mostly an experiment where two or more variants of a page are shown to users at random, and statistical analysis is used to determine which variant performs better for the given conversion goal. Imagine a shopping network testing a new checkout page to encourage users to complete their purchase. You can analyze the percentage of users that used version A of the website and purchased their items in the shopping cart, versus version B.</p>
<p>Dark launching is the process of releasing production-ready features and released to a subset of users gradually, in order to get the user feedback, or test the application or infrastructure performance. Features are wrapped in a way where they can be toggled which is used to control who gets the new features and when. Dark launching is a popular method to test new features gradually, by releasing them to small groups of users over time. This way, they can see how users respond to the changes and make adjustments before continuing. They’re called dark launches because these changes typically aren’t publicly announced. These changes are released gradually to 1%, 5% 20%, and so on. If there are any issues with these new features, the existing systems are still in place and it’s easy to roll back the change to fix the problem.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>This brings us to the end of the course. I hope you found the content useful, and you found the demo gave you a good experience of using Azure DevOps to create and implement a release pipeline. Azure DevOps is a powerful and flexible tool, and I wish you luck using it now and in the future. Thank you for taking the time to watch this course, please don’t forget to give this course a rating.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Continuous-Integration-using-Azure-Pipelines-in-Azure-DevOps-13/" rel="prev" title="AZ-400-Continuous-Integration-using-Azure-Pipelines-in-Azure-DevOps-13">
      <i class="fa fa-chevron-left"></i> AZ-400-Continuous-Integration-using-Azure-Pipelines-in-Azure-DevOps-13
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Managing-Workstreams-Using-Projects-in-Azure-DevOps-15/" rel="next" title="AZ-400-Managing-Workstreams-Using-Projects-in-Azure-DevOps-15">
      AZ-400-Managing-Workstreams-Using-Projects-in-Azure-DevOps-15 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-Continuous-Delivery"><span class="nav-number">2.</span> <span class="nav-text">What is Continuous Delivery?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Designing-a-Release-Strategy"><span class="nav-number">3.</span> <span class="nav-text">Designing a Release Strategy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-01-Prep-Work"><span class="nav-number">4.</span> <span class="nav-text">Lab 01: Prep Work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Triggers-Approvals-and-Release-Gates"><span class="nav-number">5.</span> <span class="nav-text">Triggers, Approvals, and Release Gates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-02-Set-Up-Stages"><span class="nav-number">6.</span> <span class="nav-text">Lab 02: Set Up Stages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Creating-a-Release"><span class="nav-number">7.</span> <span class="nav-text">Creating a Release</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-03-Creating-a-Pipeline"><span class="nav-number">8.</span> <span class="nav-text">Lab 03: Creating a Pipeline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Creating-a-Release-Agents"><span class="nav-number">9.</span> <span class="nav-text">Creating a Release: Agents</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ensuring-Release-Quality"><span class="nav-number">10.</span> <span class="nav-text">Ensuring Release Quality</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-04-Clones-Stages"><span class="nav-number">11.</span> <span class="nav-text">Lab 04: Clones Stages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implementing-Deployment-Patterns"><span class="nav-number">12.</span> <span class="nav-text">Implementing Deployment Patterns</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">13.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
