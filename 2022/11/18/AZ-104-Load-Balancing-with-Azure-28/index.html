<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course IntroductionHi there, and welcome to Load Balancing with Azure. My name is Thomas Mitchell and I’ll be taking you through this course. I’m an Azure instructor at cloud Academy and I have over 2">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-104-Load-Balancing-with-Azure-28">
<meta property="og:url" content="https://example.com/2022/11/18/AZ-104-Load-Balancing-with-Azure-28/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course IntroductionHi there, and welcome to Load Balancing with Azure. My name is Thomas Mitchell and I’ll be taking you through this course. I’m an Azure instructor at cloud Academy and I have over 2">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T00:22:23.000Z">
<meta property="article:modified_time" content="2022-11-22T15:40:04.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AZ-104-Load-Balancing-with-Azure-28/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-104-Load-Balancing-with-Azure-28 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AZ-104-Load-Balancing-with-Azure-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-104-Load-Balancing-with-Azure-28
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 20:22:23" itemprop="dateCreated datePublished" datetime="2022-11-18T20:22:23-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-22 11:40:04" itemprop="dateModified" datetime="2022-11-22T11:40:04-04:00">2022-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-104/" itemprop="url" rel="index"><span itemprop="name">AZ-104</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AZ-104-Load-Balancing-with-Azure-28/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AZ-104-Load-Balancing-with-Azure-28/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Hi there, and welcome to Load Balancing with Azure. My name is Thomas Mitchell and I’ll be taking you through this course.</p>
<p>I’m an Azure instructor at cloud Academy and I have over 25 years of IT experience, several of those with cloud technologies. If you have any questions about this course, feel free to connect with me on LinkedIn, or send an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This course is intended for those who wish to learn about different ways that you can perform load balancing in Azure. </p>
<p>We’re going to start things off with load balancers, where you’ll be introduced to the different types of load balancers, their components, and their use cases. You’ll even get to see a demonstration that shows you how to deploy a load balancer using the Azure portal.</p>
<p>After covering load balancers, we’ll dive into Application Gateway. You’ll learn what it is, what its features are, and what components comprise it. We’ll then work through the deployment of an Application Gateway.</p>
<p>Next, we’ll take a look at Azure Front Door. You’ll learn what it is and how to create a front door instance.</p>
<p>Down the home stretch, we’ll take a look at Web Application Firewall. You’ll learn what it is and when to use it. You’ll learn about using it with Application Gateway, Azure Front Door, and with Azure CDN. We’ll wrap up the section with a deployment of Web Application Firewall on Application Gateway.</p>
<p>After covering Web Application Firewall, we’ll wrap things up with Traffic Manager, which is essentially a DNS-type load balancer. You’ll learn what it is, how it works, and when to use it. You’ll also get to see a demonstration that shows you how to create a Traffic Manager profile.</p>
<p>After finishing this course, you’ll come away with a foundational understanding of the different ways you can load balance traffic in Microsoft Azure.</p>
<p>We’d love to get your feedback on this course, so please give it a rating when you’re finished. </p>
<p>If you’re ready to learn about load balancing with Azure, let’s get started!</p>
<h1 id="An-Intro-to-Azure-Load-Balancers"><a href="#An-Intro-to-Azure-Load-Balancers" class="headerlink" title="An Intro to Azure Load Balancers"></a>An Intro to Azure Load Balancers</h1><p>Hello and welcome to Azure load balancers! In this brief lecture, you will learn what Azure load balancers are and what they are used for.</p>
<p>In the context of networking, the term “load balancing” refers to the process of distributing incoming network traffic across multiple backend resources. Such backend resources are typically virtual machines that are deployed in a “backend pool” but can also be instances in a virtual machine scale set.</p>
<p>The Azure Load Balancer operates at the Transport Layer, which is layer 4 of the OSI model. When you place a load balancer in front of an application running on VMs or on a scale set, the load balancer serves as the single point of access for that application. As users hit the load balancer to access the application, the load balancer balances that incoming traffic across however many backend VMs or resources you’ve deployed in the backend pool.</p>
<p>Azure load balancers come in two varieties. There are public load balancers and internal load balancers, which are also known as private load balancers.</p>
<p>A public load balancer is used when you need to load balance incoming Internet traffic to your virtual machines. This type of load balancer requires you to assign a public IP address to the frontend of the load balancer. It’s also important to note that public load balancers can provide outbound connections to the Internet for VMs that are located inside your Azure virtual network. To make this happen, what public load balancers do is translate the private IP addresses of the virtual machines to public IPs. This allows them to communicate externally even though the VMs themselves have no public IP addresses.</p>
<p>Internal load balancers can be used in situations where only private IP addresses are required on the frontend. This means that internal load balancers are limited to use cases where you only need to load balance traffic within your Azure virtual network, or from an on-prem network that has been connected to your virtual network through a VPN or ExpressRoute connection.</p>
<p>The image on your screen depicts a typical use case for both internal and public load balancers.</p>
<p>When you deploy a load balancer, you’ll have a choice of two SKUs: Basic and Standard. The standard load balancer can support any scenario that a basic load balancer can support – and then some.</p>
<p>For example, while the basic load balancer can support up to 300 instances, the standard load balancer can support up to 1000 instances. Another benefit of the standard load balancer over the basic load balancer is the support for availability zones. While the standard load balancer supports zone-redundant and zonal frontends for inbound and outbound traffic, basic load balancers do not offer any support at all for availability zones.</p>
<p>The table on your screen shows the key differences between Basic and Standard load balancers.</p>
<p>So, why would you ever use a load balancer? Well, there are many use cases for load balancers, both public and internal. The most common use case for a load balancer is when you wish to increase availability of your application by distributing it across multiple VMs and across multiple zones. You might also want to deploy a load balancer if you wish to provide outbound connectivity for your VMs without assigning them their own public IP addresses.</p>
<p>As far as security goes, while the basic load balancer is open to the Internet by default, the standard load balancer is built upon the zero-trust model. This means that the standard load balancer is inherently secure. As a matter of fact, the standard load balancer is part of your virtual network. Unless you explicitly allow inbound traffic via a network security group, traffic is not allowed.</p>
<p>Because of the built-in security and better features Microsoft recommends using standard load balancers over basic load balancers whenever possible.</p>
<h1 id="Load-Balancer-Components"><a href="#Load-Balancer-Components" class="headerlink" title="Load Balancer Components"></a>Load Balancer Components</h1><p>Welcome to Load Balancer Components. Now that you know what a load balancer is and what it’s used for, let’s talk a little bit about the components that make up an Azure load balancer.</p>
<p>There are actually several pieces that make up a load balancer. You have the Frontend IP Configuration, the Backend Pool, Health Probes, and Load Balancing Rules. You also have High Availability Ports, Inbound NAT Rules, and Outbound Rules.</p>
<p>So, lets touch on each of these, starting with the Frontend IP Configuration.</p>
<p>The Frontend IP of a load balancer is the point of contact for clients. It can be a private IP address or a public IP address, depending on the type of load balancer. When someone needs to access an application that is load balanced, that person would access it through the Frontend IP. Load balancers can even have multiple Frontend IP addresses assigned to them.</p>
<p>The Backend Pool is really just a collection of VMs or VM instances within a scale set that is configured to service the incoming requests to a load balancer. When a request for an application comes in on the Frontend IP, the load balancer sends the request to the backend pool. The load balancer will even automatically reconfigure itself whenever you add or remove instances from the backend pool. This ensures that the load balancer never sends traffic to an instance that has been removed.</p>
<p>Health probes determine the status of the instances that are configured in the backend pool. They determine whether or not a specific instance is healthy and if it can receive traffic. When a health probe that you configure during load balancer set up stops responding, the load balancer will stop sending connections to the unhealthy instance.</p>
<p>Load balancing rules determine how inbound traffic gets distributed across the backend pool instances. A typical configuration for a load balanced Web server would include a load-balancing rule for port 80 traffic, or HTTP, that routes traffic from the front-end IP back to port 80 on the backend instances.</p>
<p>The picture on your screen depicts such a rule.</p>
<p>When you configure a load balancer rule with ‘protocol - all and port - 0’, what you are doing is configuring high-availability ports. What this rule does is allow you to use a single rule to load balance all TCP flows and UDP flows that hit all ports of an internal standard load balancer. You would typically leverage this feature if you need to load balance a large number of ports.</p>
<p>Inbound NAT rules are used to forward inbound traffic with a specific front-end IP address and port combination. Such traffic is sent to a specific VM or to a specific instance within the backend pool. A typical use case for inbound NAT rules would be one where you wish to allow RDP connections to multiple different VM’s behind a load balancer. Configuring NAT rules for your virtual machines allows you to connect to your VM’s over RDP without the need for jump box or a public IP for each VM.</p>
<p>And lastly, outbound rules are used to configure outbound network address translation, or NAT, for all VM’s within the backend pool. This kind of rule allows you to provide outbound communication to the Internet for your instances within the backend pool. I should mention, however, that outbound rules are only supported on the standard load balancer. They are not supported by the basic load balancer.</p>
<p>Join me in the next lesson, where I will show you how to perform a basic load balancer deployment.</p>
<h1 id="DEMO-Deploying-a-Load-Balancer"><a href="#DEMO-Deploying-a-Load-Balancer" class="headerlink" title="DEMO: Deploying a Load Balancer"></a>DEMO: Deploying a Load Balancer</h1><p>Welcome back, in this demonstration here, I want to show you how to deploy a basic load balancer. What this will be is a load balancer that load balances two VMs that I have already deployed. On the screen here, you can see I’m logged into my Azure portal. And what we have here is a VM called VM1 and a VM2. These VMs are both deployed into an availability set called AvailSet.</p>
<p>Now what I’ve done on each of these VMs is install IIS Web Services since they are both Windows 2019 servers. So what we’ll do is deploy a basic load balancer, and we’ll load balance port 80 or HTTP across both of these VMs. So to get started, what we’ll do here is we’ll create a new resource. And to do that we’ll select the hamburger here, and we’ll click Create a resource. And then what we’ll do is we’ll search the marketplace for load balancer. We’ll go ahead and select Load Balancer from the list. And then from here, we can read a little bit about the load balancer itself, how it works, what it offers, all that fun stuff. And then what we can do is click Create here.</p>
<p>Now what we’re going to do for this load balancer is deploy into the Lab Subscription and then into the LBLabs resource group that I’ve set up. This LBLabs resource group contains the VMs that are part of this lab. I like to keep things together.</p>
<p>Now as you can see here, we have quite a bit of information we need to provide here. What we’ll do is call our load balancer Myloadbalancer. Then what we’ll do is we’ll deploy into East US which is where my other resources are located. And we can see here the type offers us either an internal type or a public type. If we select Internal, we’ll be deploying an internal load balancer that is not exposed to the Internet. Public exposes it to the Internet, so we’ll leave this at Public. And like I mentioned earlier, we’re going to deploy a basic load balancer.</p>
<p>Now since the load balancer is public, we need to assign a public IP address for it. We don’t have an existing public IP that I’m going to use, so we’re going to select the option here to create a new one. And what I’ll do is I’ll call the public IP address myloadbalancerIP.</p>
<p>Now the SKU for the public IP address is going to match the SKU of the load balancer itself. And then the option here for assignment is whether or not we want to assign a static public IP to our load balancer or simply just use a dynamic one. For this exercise, we’ll use a dynamic IP address. And what that means is that can change over time. But normally in a production environment, you’d be accessing it through DNS anyway. So the IP address changing is typically not that big of a deal. And for this exercise, we do not need a public IPv6 address.</p>
<p>We’re not going to do any tagging for this particular load balancer, so we can just click Review and create here. And what it does here, it validates our configuration, makes sure everything that we’ve provided matches up with what is required for that particular load balancer. We can see we get the green validation passed check mark, so we can go ahead and create the load balancer.</p>
<p>Now the creation of the load balancer is just the first part of what we need to do here. We’ll go ahead and Go to resource here. And we can see that our load balancer has now been deployed. Now like I was saying, the creation of the load balancer itself is just the first piece of what we need to do here. We need to create a frontend IP configuration. We need to configure backend pools. We need to configure health probes, load balancing rules, and we need to make sure that we can load balance those two VMs properly.</p>
<p>Now since I’ve already gone ahead and deployed the VMs that I’m going to load balance, that’s one task that we don’t need to worry about. So the first task we’re going to complete here for our load balancer is to create the backend pool that’s going to host the two VMs that we’re going to load balance.</p>
<p>So to create that backend pool, we simply select Backend pools here. We can see we have none defined, so we’ll go ahead and add one. And we’ll give it a name, and we’ll just call it BackendPool. And then what we need to do is select a virtual network that this backend pool will run from. If we select the dropdown here, we can see we have our LBLabs vnet which is where our VMs are. So we’ll go ahead and select him. And again we’re using IPv4. And if we hover over Associated to here, what we need to do here is associate the backend pool to one or more VMs.</p>
<p>Now we could also associate it with instances within a VM scale set. But for this demonstration, we’re just using two basic virtual machines. So we’ll select the dropdown here. We’ll tell it we’re going to associate with virtual machines. And then when we do that, it’s going to ask us what virtual machines we want to associate with.</p>
<p>Now you’ll notice that we can only attach virtual machines in East US, and that’s because that’s where our load balancers being deployed. It also tells us here that the VMs need to have a basic SKU public IP configuration or no public IP configuration at all. So we’ll go ahead and add our virtual machines here. We have VM1 and VM2. And we’ll add them in.</p>
<p>Now that we have a name for our pool, an associated virtual network, and it’s associated with our backend VMs, we’ll go ahead and click Add. And what this is doing is adding the backend pool to the load balancer. So we can see our backend pool is now part of our load balancer. With our backend pool configured, we can go ahead and create the health probe that I talked about in the previous lesson. This health probe is going to allow the load balancer to monitor the status of the backend VMs.</p>
<p>So let’s go ahead and add a health probe down here. Go ahead and click Add. And we’ll just call this again MyHealthProbe. Since we are going to load balance HTTP traffic or port 80 traffic, we will select the dropdown for Protocol and select HTTP. We can leave the path at the default forward slash. And basically what that means is that’s the routes of the URI for that requesting health status from that backend point. So it’s just going to hit the root of the website on those VMs.</p>
<p>Now this interval here, this is the amount of time between the probe attempts. So it’s gonna go back every so many seconds to check the status of each of the backend endpoints. We’ll change this to 15 seconds. The unhealthy threshold is the number of times that it senses a failure before it actually raises an actual unhealthy failure. This basically tells the load balancer hey, you need to detect two probe failures consecutively before you label a VM as unhealthy. So we’ll leave this default two here, and we’ll go ahead and click okay.</p>
<p>Now what this does is create the health probe. So now we have the backend pool that contains our two VMs which are running IIS. And then we have the health probe that’s going to go back and check the root path for HTTP over port 80 on each of those VMs. If one of them fails twice in a row, the load balancer will mark that particular instance as failed and not send any traffic to it.</p>
<p>Now speaking of sending traffic, we now need to create the load balancing rule. And this load balancing rule will tell the load balancer where traffic goes and why and when. So we’ll go ahead and select a load balancing rule here, and we’ll click Add. We’ll give our rule a name here. And again we’re working with IPv4. Now this frontend IP address, we can only select the front IP address that has a public IP.</p>
<p>Now this frontend IP address is the frontend of the load balancer. If we select the dropdown here, we only have the load balancer frontend. Since HTTP comes over TCP port 80, we’ll leave the protocol set to TCP and the port as 80. The backend port is also 80. So basically what we’re doing here is we’re routing traffic hitting the frontend on 80 and then sending it to the backend port on 80.</p>
<p>So we’re not doing any kind of translations or anything. We can see we already have the backend pool filled in here for this dropdown here. And the health probe is already there by default. Now if we hover over Session Persistence here, we can see in this black box what Azure is telling us is that we can configure what is called Session Persistence. And this means that we can ensure that traffic from a specific client gets handled by the same virtual machine in the backend pool for the duration of that specific session.</p>
<p>Now if we select the dropdown, we can base it on client IP, client IP and protocol, or have no session persistence. We’re not interested in creating any kind of session persistence because you don’t need to for this demonstration. But if you have a situation where you need to ensure that a client session remains on a specific VM throughout that session, you would configure your Session Persistence here. So we’ll leave this set to none. And if we hover over Idle Timeout here, we can see that this Idle Timeout allows us to configure how to keep the session open without relying on the client to send keep alive messages. We’ll leave the default here at four minutes.</p>
<p>Now if we hover over this Floating IP direct server return, we can see here that Microsoft recommends using this only when you’re using SQL AlwaysOn Availability Group Listener and SQL Failover Clustered Instance IP Address. We’re not using SQL AlwaysOn here or any kind of failover, so we’ll leave this disabled. And then from here, we’ll click okay.</p>
<p>Now at this point, we have the rule saved. And if we click on Frontend IP configuration, we can see we have the load balancer frontend. And it’s using the myloadbalancerIP. Now what I’ll do here is go out to my LBLabs here, and we’ll start up VM1 and VM2 here. We’ll let these VMs spin up for a second. And then what we’ll do is we’ll go out and we’ll test our load balancer, and see if we can hit IIS on our load balancer.</p>
<p>Now to get the IP address for our load balancer, we can go ahead and select myloadbalancerIP. This is the public IP address that we created earlier. And we can see we have an IP address here of 52.149.165.55. So we’ll copy this. Let’s open up an incognito window. And we’ll paste and go. And we can see that VM1 has responded.</p>
<p>Now this VM1 here is showing up because I made a custom default HTML file on our VM1 IIS deployment. Now if we open up another tab, let’s see if I can get this to work on both. We can see VM1 shows up again. If we refresh, it’s gonna keep hitting whatever makes the most sense at the time. Try one more here. And the reason this is hitting VM one first is because there’s no real load on the load balancer to be distributing across VMs. So it’s just going to hit whatever makes sense.</p>
<p>Now if I do this, if I go back out to LBLabs and I stop VM1, we’ll give this a moment to stop. And then what we’ll do is we’ll try to hit the load balancer again. And you’ll see that the load balancer then recognizes that VM1 is not there and sends us over to VM2. Let’s go ahead and open an incognito window. And we can see here that the load balancer sent me over the VM2. And that’s because the health rule noticed that the VM1 server has gone offline. So the load balancer is smart enough to look at that and say okay, we know VM1 is down.</p>
<p>So let’s go over to VM2. And that’s pretty much it. So let’s minimize this here, and we’ll go back out to my load balancer. And we can see we have our frontend with an IP address that’s public. We can see the backend pool that points to our two VMs. We can see we have our health probe that is looking for port 80. So it’s going out to each of those VMs every 15 seconds and checking to see if port 80 is responding. If it doesn’t twice in a row, it marks that resource as down so it won’t send any traffic to it. And then we have the load balancing rules.</p>
<p>So with that, you now know how to deploy a basic load balancer and how to load balance a basic IIS deployment across two virtual machines.</p>
<h1 id="Application-Gateway-Intro"><a href="#Application-Gateway-Intro" class="headerlink" title="Application Gateway Intro"></a>Application Gateway Intro</h1><p>Hello, and welcome to Application Gateway! In this lesson, we are just going to touch on what Azure application Gateway is and what it offers.</p>
<p>Azure application Gateway is another load balancer offering that is used to load balance web traffic to web applications. While the Azure load balancer offering operates at the transport layer of the OSI model, and routes traffic based on source IP and port to a destination IP and port, the Azure application Gateway uses additional HTTP attributes to make routing decisions.</p>
<p>For example, when a request hits the application Gateway, the gateway can make routing decisions based on the URI path or based on host headers. Let’s assume, for example, that we have a website that hosts images and video. You could use application Gateway to route incoming traffic to the correct set of servers based on the URL. Incoming requests for a URL that includes &#x2F;images can be routed to the servers, or backend pool, that hosts your images. Incoming requests for a URL that includes &#x2F;video can be routed to the pool that hosts your videos. The pool that you route traffic to can consist of VM’s, a VM scale set, or even on-prem servers.</p>
<p>The image on your screen shows an example of how application Gateway can route traffic.</p>
<p>This is known as application layer routing and it happens at layer 7 of the OSI model.</p>
<p>The Azure application Gateway offers several features that allow you to load balance and manage traffic to web applications. Some key features include SSL termination, autoscaling, web application firewall, and zone redundancy. </p>
<p>SSL termination allows you to offload encryption and decryption to the gateway itself, rather than forcing the backend servers to handle it. </p>
<p>The autoscaling feature of application Gateway allows you to automatically scale up or down, based on traffic load. This feature is only supported by application Gateway standard V2. </p>
<p>The web application firewall is a service that offers centralized protection of web applications. The web application firewall, or WAF, protects such applications from many common exploits and vulnerabilities like SQL injection attacks, cross site scripting attacks, and many more. </p>
<p>By offering zone redundancy, the standard V2 application Gateway can be spanned across multiple availability zones. Because it can span multiple availability zones, you do not need to provision a separate application Gateway in each zone.</p>
<p>There are many other application Gateway features available. Visit the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/application-gateway/features">URL</a> that you see on your screen for a complete list and details of each.</p>
<h1 id="Application-Gateway-Components"><a href="#Application-Gateway-Components" class="headerlink" title="Application Gateway Components"></a>Application Gateway Components</h1><p>Welcome to application Gateway components. Now that you’ve been introduced to application Gateway and what it offers, let’s take a look at the difference components that make up the application Gateway.</p>
<p>The application Gateway consists of front-end IP addresses, listeners, request routing rules, HTTP, settings, backend pools, and health probes.</p>
<p>As is the case with load balancers, an application gateway has a front-end IP address associated with it. The front-end IP address can be public, private, or both. An application Gateway can support one public IP address or one private IP address.</p>
<p>Listeners are used to check for incoming connection requests to the gateway. When you configure a listener, you can specify a protocol, a port, a hostname, and an IP address. If an incoming request matches what has been configured in the listener, the listener accepts the request. The gateway will then route the request to whatever backend members are configured in the rule.</p>
<p>Speaking of rules, request routing rules are used to determine how to route traffic on the listeners. The request routing rule is essentially the glue that binds the listener, the backend pool, and the backend HTTP settings. What the rule does is pretty simple. It takes a request that has been accepted by the listener and forwards that request to the backend. The request routing rule defines which backend server pool that requests should be sent to.</p>
<p>The HTTP settings include ports and protocols that are used to determine whether or not the traffic between the application Gateway and the backend servers is encrypted or not. HTTP settings also determine whether or not cookie-based session affinity should be used to keep a specific user session on the same server.</p>
<p>The backend pools that I have mentioned can consist of NICs, VM scale sets, public IP addresses, internal IP addresses, FQDNs, and multitenant backends like App Service. Backend pools are essentially that - pools of resources that the gateway can direct traffic to.</p>
<p>Lastly, the health probes are used to monitor the health of the resources contained within the backend pool. When an unhealthy resource is detected by the health probe, that resource is removed from service. The health probe will then continue monitoring the unhealthy resource. If it becomes healthy again, the resource is added back to the pool automatically.</p>
<p>To learn more about the azure application gateway components, visit the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/application-gateway/application-gateway-components">URL</a> that you see on your screen.</p>
<p>Join me in the next lesson, where I’ll show you how to deploy an application gateway.</p>
<h1 id="DEMO-Deploying-an-Application-Gateway"><a href="#DEMO-Deploying-an-Application-Gateway" class="headerlink" title="DEMO: Deploying an Application Gateway"></a>DEMO: Deploying an Application Gateway</h1><p>Welcome back. In this lesson, we are going to walk through the process of creating an application gateway. Now, if you remember from the lesson previously an application gateway is essentially a load balancer that’s built for load balancing web traffic specifically. So that’s what we’re going to do here.</p>
<p>We have two VMs called VM1 and VM2. Both have IIS installed. What we’re going to do is deploy a gateway and load balance that web traffic to both of those VMs through the use of a backend. So to begin the process of deploying our application gateway, we’ll go ahead and select the hamburger and Create a Resource. And then we’ll search the marketplace for application gateway. We’ll go ahead and select it and we’ll begin the creation process.</p>
<p>Now, when we create the application gateway, we have, looks like six different tabs here that we need to configure information for. Some of them will require more information than others. This basics tab, as you would expect is where we configure some of the basic information for our application gateway, the name, the subscription it’s going to, the resource group some of that information here. So what we’re going to do for this application gateway is deploy into our lab subscription and then into the resource group called LBLab.</p>
<p>Now in this application gateway name box we need to give our gateway a name. So I’ll just call it MyAppGateway. And what we’ll do here is we’ll deploy into East US since that’s where my other resources are here. And then in this teardrop down we can select the standard Standard V2 or web application firewall web application, Firewall V2. If we hover over the icon here we can see that the V2 tier offers performance enhancements over that of the standard original tier.</p>
<p>Now, if we hover over the, go back here. If we hover over the Learn more link here and open it up, we can see the information about the different features of the application gateway V2. The enhancements include like auto scaling, zone redundancy, you can even do a static virtual IP, header rewrites, all of this cool stuff that the V2 offers over the standard. So I encourage you to take a look at, that this page here and take a look and see what the application gateway enhancements are for the V2 SKU.</p>
<p>So we’ll bounce back over here and we’ll leave this set to standard V2 it is default, and then we’ll keep auto scaling enabled. Now, this minimum scale units here, if we hover over the icon here, this little black box will tell us that the minimum scale units refers to additional reserve capacity which is always maintained regardless of what traffic is hitting the gateway.</p>
<p>Now by selecting zero here, what this does is signify a purely auto-scaling application gateway and it doesn’t have any additional reserve capacity while still maintaining that high availability. So we’ll leave this at zero and then the maximum scale units again, we go up to 10. We’ll leave the default there. If we select the drop down for availability zone, we can see, we can select an availability zone to provide high availability for our application gateway.</p>
<p>If we hover over the icon on here, we can see that some regions will support the ability to put this application gateway into zones for availability or availability zones. Since we’re in East US that is a region that supports availability zones. We’re not going to do anything with high availability here so we’ll leave this set to None. Hovering over HTTP2 shows us that the application gateway does support HTTP2 protocols for clients that are going to connect to application gateway listeners only. We’re not doing anything with HTTP2, so we’ll leave that off.</p>
<p>Now, the tricky thing here with an application gateway is the virtual network. If we hover over the icon here for virtual network, we can see that we need to provide a virtual network for our application gateway to connect to. Now that being the case, the next sentence here the second sentence in this box is critical. The virtual network that we use needs to have either an empty sub-net or a sub-net that only contains application gateways. If we don’t have one of those two, we have to create a new virtual network and sub-net for that specific gateway.</p>
<p>Now for this exercise, I’m going to select the LBLab vnet where my virtual machines are installed. Now, if I select this, the default sub-net automatically appears because that’s the only sub-net there. And it turns red here. And this is because it’s not an empty sub-net because I have VMs on it and it’s not a sub-net that contains just application gateways.</p>
<p>So what I need to do here is create an empty sub-net on that virtual network. And to do that, I select the manage sub-net configuration here. And this takes me out to the LBLab vnet virtual network, where I can create another sub-net here. So I’m just going to call this AGSubnet.</p>
<p>Now the address range for the subnet needs to fall under the umbrella of the address space for the virtual network. The address space for this virtual network is 10000&#x2F;16. The existing default sub-net as 10010&#x2F;24. So what I’ll do here is call this 10020&#x2F;24. We’re not doing anything with Nat gateways, nothing with sub-net delegation or anything. We just need a dumb sub-net here. So we’ll okay it and if we refresh this, we can see we now have the AGSubnet.</p>
<p>So we’ll go back to the Create application gateway here, and what we’ll do here is select the AGSubnet. At this point, we need to configure the frontends. So we’ll go ahead and click Frontends here. Now the frontend is where traffic will enter the gateway to access whatever web application you have running. You can have a public frontend type, a private or both. For this exercise, we’re going to have a Public Frontend IP address and I can either use the existing IP, which in this case I only have two defined and it’s one for each of my VMs. So what I’ll do here is I’ll create a new one and I’ll just call this AGPublicIP.</p>
<p>Now you can see the SKU and assignments are great out because I can’t change those. The SKU is going to match that of my gateway and then the assignments going to be static. So, okay at here. At this point we have our frontend configured and now we can move on to the backends. We can see here, we have no backend pool and this obviously the backend pool is the pool of resources that the application gateway is going to send traffic to.</p>
<p>If you look at the note here you can see a backend pool can contain virtual machines, VM scale sets, app services, IP addresses, or even FQDNs. For this exercise, we’re going to build that pool from two virtual machines. So we’ll go ahead and add the backend pool. And I’m just going to call this AGBackend. Now this option here for adding backend pool without targets, if we don’t have targets already defined, we could select Yes here, Create the pool and then come back and add our backend targets later. But since we already have our VMs created, we just leave this at No and then in the target type, we select the dropdown for Virtual machine. Now from Virtual machine next to it for target, we go ahead and select VM1 and VM2.</p>
<p>Now you’ll notice I’m not even selecting VMs here, I’m selecting the NIC for each of those VMs. And there you go we go to VMs, we’ll add them in and we have two targets. So we’ll go ahead and Next here to Configuration. Now on this configuration tab what we’re going to do is connect the front end to the backend, using a routing rule.</p>
<p>We can see under frontend, we have the new AGPublic IP and we can have our backend here defined as AGBackend. What we need to do here is add a routing rule. I’m just going to call this rule RoutingRule. Now the very first thing we have to do is define a listener.</p>
<p>Now that listener is a component that listens on the specific port and IP address for any kind of traffic. If that traffic matches the traffic that we specify here the application gateway applies the rule. So I’ll just call this MyListener. Now we have to tell the listener where it needs to listen.</p>
<p>So in this dropdown here, we select the Public Frontend IP because this is the frontend IP that we created for it and then we’re going to listen for HTTP traffic which is Port 80. Now, if we hover over Listener type here this is where we can define whether we’re using a single site behind the gateway or if we’re using multiple sites. We’re not using multiple sites, so we’ll leave this at Basic Listener type and we don’t have an error page URLs. So we’ll leave this set to No. And then what we wanna do is go to the Backend targets tab here.</p>
<p>Now, since we have a backend pool we’re going to specify the backend pool target type and then we’re going to select our AGBackend that we defined. Now, this HTTP settings option here. This is what defines the behavior of the rule. It’s where we’ll specify ports, protocols, backend settings, affinity, that kind of fun stuff. Now we don’t have an HTTP setting defined yet, so we’ll go ahead and click Add new. And for the name, we’ll just call it myHTTPSettings.</p>
<p>Now we’re not balancing HTTPS traffic, we’re doing HTTP. So we’ll leave HTTP set and the backend port at 80. Now Cookie-based affinity is a way to ensure that the application gateway forces a user session to a specific backend server or instance for the duration of the session. We’re not doing any kind of a Cookie based affinity here, so we’ll leave this disabled. And then for connection draining here what this does is allow you to more gracefully remove backend pool members during planned service updates.</p>
<p>I’m not worried about connection draining for this simple demonstration, so I’ll leave this disabled as well. Hovering over the Request time-out, what this is, this is the number of seconds that the application gateway will wait for a response from the backend pool before it comes back and says there’s a connection time out, or any kind of error message that it has to return to the end user. The default here is 20 seconds, so we’ll leave that there. That works for me. And then this override backend path, this allows you to override the path in the URL so any requests for a specific path can get rerouted to a different path. </p>
<p>So if we read what’s noted in this box, we can see that for example, if he wants to route requests for contoso.com&#x2F;images to the default path, we enter a forward slash here and then attach this HTTP setting to the rule associated with contoso.com&#x2F;images. We’re not doing any redirections or overrides here so we can leave this blank. And then under host name here, we can override with new host names. These are more advanced features we don’t need to do anything with overrides here.</p>
<p>So we’ll go ahead and click Add and we’ll go ahead and finish up here. So now we have the Frontend, the Routing rule, and the Backend configured. And then if we’re going to do any tagging, we can click Next for tags but we’re not gonna do any tagging here. And then we’ll Review and Create. And what Azure will do here is look at our configuration and validate it. Everything looks good. We get the green check mark. We can go ahead and Create the application gateway. We can see our deployment is now complete.</p>
<p>So we’ll bounce back to our Resource group here. Now to test our gateway, what we need to do is identify the public IP address for it. And to do that, you can see here, we’re in our LBLab Resource group. If we select the public IP that we created, we can see the IP address of it. So this is the public IP of our application gateway.</p>
<p>If we copy that and open up a new incognito window, we can paste and go. We can see that the gateway has defaulted at least on this load to VM2. If we refresh here a few times, we may be able to get it to hit VM1. Maybe we’ll try to open an incognito window, do it again and we still hit VM2. Now, the reason for this is because there’s really no load on these. So it’s just gonna pick whatever is working and it’s gonna go with it. </p>
<p>So what I can do to confirm that the gateway works, is I’ll bounce out of this and what I’ll do is I’ll go back into my LBLab Resource group here and what I’ll do is I’ll shut down VM2. Let’s Refresh. So let’s go ahead and open our incognito window and we can see we hit VM1. So the application gateway knows VM2 is no longer available, so it’s now sending traffic to VM1.</p>
<p>If we close this out, we can go back to our application gateway here and there you have it. That’s how you deploy an application gateway and how you load balance web traffic using the application gateway.</p>
<h1 id="An-Intro-to-Azure-Front-Door"><a href="#An-Intro-to-Azure-Front-Door" class="headerlink" title="An Intro to Azure Front Door"></a>An Intro to Azure Front Door</h1><p>Hello and welcome to Azure Front Door. In this lesson, we’ll take a look at what Azure Front Door is, and what it offers.</p>
<p>Azure Front Door is a service offering that is delivered from the edge of Microsoft’s global network. This service offers global load balancing for applications and even microservices. With Azure Front Door, you can fail over such apps and microservices across different regions or even different clouds. You can use it to define, manage, and monitor global routing for your web traffic. It also provides high availability.</p>
<p>Key features and benefits of Azure Front Door include improved application performance, increased availability, URL-based routing, session affinity, and much, much more.</p>
<p>Improved app performance is attained through the use of split TCP-based anycast protocol. What this does is ensure that users of an application connect to the nearest point of presence to them. This speeds access and reduces latency.</p>
<p>Increased availability is made possible with smart health probes. These smart health probes monitor the backend resources for latency and availability. When a backend resource goes down, the health probes facilitate a quick failover to remaining backend resources.</p>
<p>The URL-based routing that Front Door offers allows you to route traffic to backend pools based on the URL paths of the requests. For example, requests for a URL like <a target="_blank" rel="noopener" href="http://www.bluewidgetcorp.com/video">http://www.bluewidgetcorp.com/video</a> could be configured to go to resources hosting videos, while a URL like <a target="_blank" rel="noopener" href="http://www.bluewidgetcorp.com/images">http://www.bluewidgetcorp.com/images</a> could be configured to go to resources hosting images.</p>
<p>The cookie-based session affinity that Front Door offers can be used to ensure that a specific user session remains on the same backend for the duration of the session.</p>
<p>There are also many other features and benefits of Front Door, including things like TLS termination, custom domain support, URL redirection, and others.</p>
<p>For a complete list of Azure Front Door features and benefits, along with an explanation of each, visit the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/frontdoor/front-door-overview">URL</a> that you see on your screen.</p>
<h1 id="DEMO-Creating-a-Front-Door"><a href="#DEMO-Creating-a-Front-Door" class="headerlink" title="DEMO: Creating a Front Door"></a>DEMO: Creating a Front Door</h1><p>Welcome back. In this demonstration, we’re going to walk through the process of configuring Azure Front Door so that it directs user traffic based on lowest latency between two web apps. Now, what I’ve done here to prepare for this demonstration is deploy two different web apps in my environment, within the LBLab, Resource group I created a web app called BlueWidget1. This application is hosted in Central US.</p>
<p>In the LBLab2 resource group that I’ve spun up, I created a web app called BlueWidget2. This application runs in East US. What we’re going to do is configure front door to front end both BlueWidget1 and BlueWidget2. So let me bounce back into LBLab which is my primary resource group here for some of my labs. And to create our front door, what we’re going to do is go to the hamburger and create a resource. And then from here, we can search for front door or we could browse it by going into Networking and then finding front door down here in the feature or if we See all, we could find it down in here.</p>
<p>So for this demonstration, we’ll search for front door, we’ll select it and we will deploy our Front Door. When we create a front door we need to tell Azure what subscription to deploy to and into what resource group. So we’ll go into LBLab for this. Now we can see the Resource group location is greyed out because we can’t change that.</p>
<p>Next, we’ll go into the configuration of the door and we can see here that this configuration happens in three steps. We create the Front end, we create the Backend, and then we create the Routing rules. So let’s go ahead and click the plus sign here to create a frontend. Now this frontend is going to be where traffic enters. This host name here is upended with this domain of Azure FD for front door. It’s Azurefd.net. So the name I give it needs to be globally unique across the entire landscape. So I’m going to call this bluewidgetFD.</p>
<p>So, for our host name, we’ll call it bluewidgetFD which stands for bluewidget front door. So the complete host name will be bluewidgetFD.azure.net. Now for this demonstration we’re not going to configure session affinity. Now that session affinity would allow us to direct traffic from a specific user session to the same application backend for the duration of the session. I’m not worried about affinity right now, so we’ll leave that alone nor am I going to configure web application firewall this time.</p>
<p>So at this point, we can click Add. At this point we have our front end configured for our front door. Now we need to tell Azure what the backend is going to be where are we going to send our traffic to. So we’ll go ahead and plus it up here and we’ll just call this MyBackend. Actually we’ll call it MyBackendPool.</p>
<p>We’ll go ahead and add a backend and the backend host type allows us to define what that backend is. In our case here, it’s an app service. So we’ll select App service. We can see it fills in the backend host name, the backend host header. All of this HTTP information is automatically filled in. We’ll go ahead and add this backend and then we’ll add the second backend bluewidget2 and we add.</p>
<p>These health probes here allow the front door to check the status of our backends. These can be left at their defaults. And then the load balancing settings down here are used as it says here to define what sample set we need to call the backend as healthy or unhealthy. We’ll go ahead and add. And now we have our front end and our backend defined.</p>
<p>At this point, we need to add a routing rule. Now this routing rule is going to map the front end host to a backend pool. So let’s go ahead and create a routing rule here and we’ll just call this MyRule. Now for this demonstration we can accept the default settings here because the accepted protocol is HTTP and HTTPS which is what we’re going to send to our backend. And we can see the front end is already free filled with the front end that we defined earlier.</p>
<p>The pattern to match is the default URL path and then the route details here tell front door what to do. For example, with the forward setting, if we hover over this, we tell the front door to forward traffic to the backend rather than redirect it. We can see the backend pool is configured. If we hover over URL rewrite, we can take a look here and see that by enabling this, we can configure a path to use when constructing this request for the URL and use a rewrite to forward that to the backend. And the same thing with caching here. We can enable caching for this particular routing rule.</p>
<p>Now for this demonstration, we’re not going to do any rewriting or caching so we can go ahead and add our rule. At this point, we have our front end configured, our backend and our routing rule. So we’ll go ahead and create our front door here, we get the validation and then we can create.</p>
<p>Now once this deployment completes, we’ll go in and I’ll let you see what happens with Azure front door here by viewing it in action here. Now what Azure front door is going to do for us is perform pretty much an instant global fail over. Remember one of our apps is in the East region and the other one is in Central.</p>
<p>So let’s go ahead and open up an incognito window and browse to our front door. And now the bluewidgetfd.azurefd.net is directing to our app service. And what front door will do is keep track of which application is running and if one of them goes down, front door will ensure that traffic instead of being sent to the down instance is sent to the instance that remains up. And that’s pretty much it. I mean, setting up the front door service, isn’t terribly complicated, you simply set up a frontend, a backend and your rule to route that traffic. That traffic is then directed to each of your backends that you’ve configured behind that front door service.</p>
<h1 id="What-is-Web-Application-Firewall"><a href="#What-is-Web-Application-Firewall" class="headerlink" title="What is Web Application Firewall?"></a>What is Web Application Firewall?</h1><p>Welcome to web application firewall! In this lesson, I’m going to introduce you to the Azure web application firewall and what it offers.</p>
<p>Also known as WAF, the web application firewall in Azure offers a way to protect web applications from common vulnerabilities and exploits, like SQL injection attacks and cross-site scripting attacks.</p>
<p>While such attacks CAN be prevented within application coding, doing so is tedious and requires ongoing maintenance. The centralized protection that web application firewall offers vastly simplifies such protection – and it can often allow you to respond to threats far more quickly by patching known vulnerabilities instead of needing to secure every individual web application behind it.</p>
<p>The image on your screen depicts what a typical WAF solution looks like.</p>
<p>You can deploy web application firewall in conjunction with several different Azure services. It can be deployed with Azure Application Gateway, Azure Front Door, and with the Azure Content Delivery Network. The features of web application firewall can be customized for each service.</p>
<p>When used with Application Gateway, web application firewall offers protection for web applications against web vulnerabilities and attacks without any need for changes to the application code itself. You can even protect multiple applications simultaneously. As a matter of fact, you can host and protect up to 40 websites with web application firewall on a single instance of Application Gateway. The ability to create custom WAF policies allows you to use different policies for different sites.</p>
<p>The image on your screen depicts a typical WAF deployment with Application Gateway.</p>
<p>Just as it does when used with Application Gateway, web application firewall provides centralized protection against web threats when use with Azure Front Door. This type of global solution is deployed on edge locations on the Azure network around the world. Every incoming request to the Front Door is inspected at the edge of the network. This means attacks are prevented by WAF before they even enter your virtual network.</p>
<p>The image on your screen depicts a typical web application firewall deployment with Front Door.</p>
<p>When used with the Azure Content Delivery Network, the web application firewall can be used to protect web content itself. A global and centralized solution, WAF with the Azure CDN mitigates malicious attacks closer to their sources, rather than after they reach your network.</p>
<p>The image on your screen depicts a typical WAF deployment with Azure CDN.</p>
<p>So, to recap, web application firewall is designed to protect against various web threats, and it can be used with Application Gateway, Azure Front Door, and with the Azure Content Delivery Network. </p>
<p>For more technical details on Web Application Firewall, visit the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/web-application-firewall/">URL</a> that you see on your screen.</p>
<h1 id="DEMO-Enabling-Web-Application-Firewall-on-Application-Gateway"><a href="#DEMO-Enabling-Web-Application-Firewall-on-Application-Gateway" class="headerlink" title="DEMO: Enabling Web Application Firewall on Application Gateway"></a>DEMO: Enabling Web Application Firewall on Application Gateway</h1><p>Hello and welcome back. In this demonstration, what we’re going to do is enable Web Application Firewall with app Gateway. Now on the screen here, you can see I’m logged into my Azure portal and I’m looking at my Application Gateway, which is aptly called MyAppGateway. There are two servers on the backend of this. They’re two virtual machines. It’s called VM1 and VM2 and both are running IIS.</p>
<p>So our app Gateway is already set up as is the backend. So all we need to do here is enable Web Application Firewall. Now to do that, the first thing I need to do is create a storage account to store data for detection and prevention purposes. Now we could also use Azure monitor logs or Event Hub but for this demonstration, we’ll just create a storage account.</p>
<p>So we’ll go ahead and click the hamburger, create the resource and we’ll select Storage Account from the popular list here. We’ll deploy this in the LB Lab Resource Group and we’ll just call this something like BW Diag Storage. There we go. Remember that storage account name needs to be unique. So we got a unique name here. We’ll leave this in East U.S. and the performance can remain standard here for diagnostics and we’ll leave it at the default storage V2 which is the recommended storage account kind that Microsoft recommends. And we can leave the default replication which is not really critical here.</p>
<p>The same thing goes for access here. We’re not really using cool data. We’ll use this hot. And then what we’ll do is we’ll review and create here. Now once we have this storage account created, what we’ll do is configure the diagnostics to record data into our Application Gateway Access Log, the Application Gateway Performance log and the Application Gateway Firewall Log.</p>
<p>So let’s go back out and we’ll go into my app Gateway here. Now what we do here is go down under monitoring here and we select the Diagnostic Settings option. We can see here, we don’t have any diagnostics configured for our app Gateway. So what we’ll do here is we’ll add one and we’re just going to call this MyDiags. And then what we’re going to do is archive to a storage account here and we’ll keep our logs here. We’re not going to worry about metrics at this point. We’ll just leave the logs here collected.</p>
<p>Now obviously in these boxes, we can configure the retention for each of these. Now leaving this at zero means we’re not setting any retention policy and what this will do is retain our data forever. So now that we’re archiving to a storage account, we need to make sure that we select our storage account to archive to. We only have the one storage account here so it’s been selected by default.</p>
<p>At this point, we can save our diagnostic setting. Let’s go back out to our resource group here and now the next step in the process is to create what’s called a WAF policy or a Web Application Firewall policy. We need to create that policy and then associate it with our Application Gateway. What we’ll do here for this demonstration is create a basic policy with a managed default rule set. Basically, it’s just a basic vanilla policy. </p>
<p>Now to do this, we’ll go up into the hamburger, create a resource, and then we’ll search for WAF. And we can see Web Application Firewall appears. And then we’ll go ahead and begin the creation process of the Web Application Firewall policy. On this screen here, we’re going to configure some basics.</p>
<p>For the policy here, We need to indicate what resource type we’re trying to protect. We select the dropdown here. We have Azure CDN Application Gateway or front door. We’re going to protect Application Gateway and we’ll put this in the LB Lab Resource Group. Now for instance details, we need to specify the location, the policy state and we need to give the policy a name. This policy name must be unique.</p>
<p>So we’ll just call it MyBWPolicy. It’s my blue widget policy. Now since this is a vanilla policy, we don’t have to do anything crazy at this point. You can go ahead and click through to next. Under policy settings, here we can leave the defaults. If we hover over mode here, we can see that detection mode will monitor and log all threat alerts to a log file.</p>
<p>Prevention mode will take some corresponding action if that request matches a rule. We’re gonna leave this in its default configuration here. We’ll leave our rules in place. It’s already pre-configured with a specific rule set and we can see what those rules are. So we’ll leave the default rules in place. We’re not going to do any custom rules but what we do want to do is go into association here and associate our WAF policy with an Application Gateway.</p>
<p>So what we’ll do here is we’ll associate our Application Gateway and if we do a dropdown, we can see we don’t have any gateways to associate. Now I know for a fact we have the Application Gateway already created. But if you notice here, it needs to be a WAF V2 SKU for the gateway.</p>
<p>So what we’re going to do is open up another tab here and we’ll go into my app Gateway. If we look at the configuration for our Gateway, we can see that the tier is standard V2. It’s not this WAF V2. So what I need to do here is change the tier and save that. So that gateway needs to be a WAF V2 tier in order to work with the Application Gateway WAF policy. So we’ll cancel this. So let’s go back in here and we’ll go ahead and associate our Application Gateway and we’ll go ahead and save it. And we can see that our deployment has succeeded.</p>
<p>So now that our policy has been associated with our Application Gateway, we can test the Application Gateway. What we’ll do here we’ll go out to our Gateway. We’ll copy the IP and we can see that we’re now hitting the Gateway and it’s still up and running where I hit VM1 which is one of the backend VMs of the Gateway.</p>
<p>If we close this out, go back out to our LB Lab and then we can take a look at our policy. We can see the status is enabled. We can take a look at the activity log and we now have a Web Application Firewall policy associated with our Application Gateway.</p>
<h1 id="An-Intro-to-Traffic-Manager"><a href="#An-Intro-to-Traffic-Manager" class="headerlink" title="An Intro to Traffic Manager"></a>An Intro to Traffic Manager</h1><p>Welcome to Traffic Manager! In this lesson, we’ll touch on yet another load balancing feature, called Traffic Manager. We’ll look at what it is and what it does.</p>
<p>Azure Traffic Manager is a load balancer that works by distributing traffic using DNS. It’s a bit different from the Azure load balancer offerings that we discussed earlier. You typically use Traffic Manager to distribute traffic to services that are located across different global Azure regions. When you use Traffic Manager, you can ensure that your European users can access your application from and endpoint closest to them, while your North American users can access the same app from a service endpoint closest to them. This provides higher availability of your app and makes it more responsive to end user requests.</p>
<p>The way it works is pretty straightforward. What Traffic Manager will do is use DNS to send access requests to the service endpoint with the least latency for the requester, based on the configured traffic routing method and on the health of the endpoints that have been configured. The configured endpoints can be any Internet-facing service that’s hosted inside or outside of Azure. Its flexibility protects applications against failures, including the failure of an entire Azure region.</p>
<p>Because it works at the DNS level, Traffic Manager will use DNS to route incoming connections to the necessary endpoint, based on how the rules are configured and on the traffic routing method. Speaking of routing methods, there are several available when using Traffic Manager.</p>
<p>You have Priority, Weighted, Performance, Geographic, Multivalue, and Subnet.</p>
<p>If you want to send all incoming traffic to a primary service endpoint, while making backup endpoints available in the event the primary endpoint is not available, you would choose the Priority method.</p>
<p>The Weighted routing method can be used in situations where you need to split traffic out across multiple endpoints, based on weighting that you define. Weighted routing can also be used to evenly split traffic across multiple endpoints.</p>
<p>The Performance routing method is often used with applications that are distributed across multiple geographic locations. Choosing the Performance routing method allows you to direct users to the closest endpoint to them, when they access your application. This reduces latency for those users.</p>
<p>Geographic routing also allows you to force users to an endpoint closest to them, but it works a little differently than Performance routing. Geographic routing is performed based on the geographic location of the original DNS query. You would typically use Geographic routing to ensure a user in Europe access your application from a European endpoint. This is a useful option when you need to comply with sovereignty mandates.</p>
<p>The Multivalue option should be used for Traffic Manager profiles that can only have IPv4 or IPV6 addresses as endpoints.</p>
<p>And lastly, the Subnet routing method allows you to map specific ranges of end-user IP addresses to specific endpoints. This means you can force specific users, based on their IP addresses, to connect to certain endpoints.</p>
<p>Now, I should point out here, because its not always evident when I talk about it, that Traffic Manager is NOT a proxy or gateway. Despite all these routing methods that are available, what Traffic Manager actually does is play traffic cop. No traffic ever passes through Traffic Manager. Instead, Traffic Manager directs clients to the endpoints. The clients then make connections directly to those endpoints. Keep that in mind.</p>
<p>The picture on your screen shows how a client typically connects to an endpoint, using Traffic Manager.</p>
<p>Notice what happens here. (1) The process starts off with a DNS query for the app called app.bluewidgetco.com from the client to the client’s DNS service.</p>
<p>Next, (2) the DNS service reaches out to the name servers for the domain hosting the application, and those name servers return the CNAME record that points to the Traffic Manager implementation for the app. In this case, the CNAME record is called bluewidgetco.trafficmanager.net. The root domain will always be trafficmanager.net for Traffic Manager implementations.</p>
<p>At this point (3) the client’s DNS service finds the name servers for the trafficmanager.net domain. These servers are provided by the Traffic Manager service itself. After finding the name servers for the trafficmanager.net domain, the client’s DNS service sends a request for bluewidgetco.trafficmanager.net.</p>
<p>Once the Traffic Manager (4) name servers receive the request, they determine the correct endpoint, based on the state of the configured endpoints, the health of the endpoints, and the routing method that has been configured.</p>
<p>Traffic Manager (5) then returns the CNAME record of the proper endpoint to the client’s DNS service. In this example, there are two deployments of the app. The app is deployed at bluewidget-us.cloudapp.net and at bluewidget-eu.cloudapp.net. Let’s assume the users is US-based and should hit the US-based deployment of bluewidget-us.cloudapp.net. In this scenario, the endpoint of bluewidget-us.cloudapp.net is returned to the client’s DNS service.</p>
<p>Once it receives the endpoint DNS name, (6) the client’s DNS service finds the DNS name servers for the cloudapp.net domain and requests the DNS record for bluewidget-us.cloudapp.net. The cloudapp.net name servers respond to the client’s DNS service with the IP address of the US-based endpoint.</p>
<p>The (7) client’s DNS service sends this information back to the client requesting access.</p>
<p>Once the client receives the DNS information and IP address for the US-based deployment, the (8) client connects directly to that deployment.</p>
<p>So, as you can see here, Traffic Manager is heavily dependent on DNS. After all, like I mentioned at the outset, it’s a DNS-specific load balancing solution.</p>
<p>Join me in the next lesson, where I’ll show you how to create a Traffic Manager profile.</p>
<h1 id="DEMO-Creating-a-Traffic-Manager-Profile"><a href="#DEMO-Creating-a-Traffic-Manager-Profile" class="headerlink" title="DEMO: Creating a Traffic Manager Profile"></a>DEMO: Creating a Traffic Manager Profile</h1><p>Welcome back. What we’re going to do in this demonstration here is deploy a Traffic Manager profile. The process is going to be pretty straightforward. We’re going to deploy the profile, and then we’re going to add two backend endpoints to that profile. The endpoints will be two web apps that I’ve deployed in Microsoft Azure.</p>
<p>On the screen here, you can see I’m logged in to my Azure portal, as my admin. And I’m sitting in the LB Lab resource group. We have two web apps deployed here, Blue Widget 1 and Blue Widget 2 is going to live in the other research group of LB Lab 2. So these will be the end points.</p>
<p>So let’s bounce back to LB Lab. Now to begin the process, we’ll go into the hamburger here and we’ll create a resource. And what we’ll do here is we’ll search for Traffic Manager. And you can see here Traffic Manager profile shows up in the list, so we’ll go ahead and begin the process here.</p>
<p>Now when we create our Traffic Manager profile, we need to give it a unique name across the Azure landscape. We need to specify the routing method that we talked about earlier, the subscription, and the resource group we want to deploy it into. When we create our profile, the name we use here is going to append the trafficmanager.net domain name. So that’s why this needs to be unique.</p>
<p>So what we’ll do here is we’ll try to call this MyBWApp. So mybwapp.trafficmanager.net will be the URL that we use to hit the web applications that are sitting behind the Traffic Manager profile. In the drop-down here for routing method, we have the different routing methods we talked about. Performance, weighted, priority, the geographic multi-value and subnet. We’ll leave this set to performance, we’ll deploy into the lab subscription, and we will deploy into LB Lab.</p>
<p>Now you’ll notice the resource group location grays out based on the resource group that we select. So we’ll go ahead and create the profile. We can see our deployment has succeeded, so we’ll go to our resource here. And we now have My BW App Traffic Manager profile.</p>
<p>Now at this point, what we’re going to do is create the endpoints. We’ll create a primary endpoint that points to our app 1, and then a secondary that points to app 2. So we’ll go ahead, to do this under Settings here we select Endpoints, and we can see we have no endpoints currently created, so we’ll go ahead and add the first one. And you can see here there’s not too much information we need to provide.</p>
<p>In the Type drop-down here, we need to tell Azure what kind of endpoint we’re going to add, whether it’s an Azure endpoint, an external endpoint, or a nested endpoint. Since our endpoints are going to be a web app, we’ll select Azure Endpoint. And then we need to give our endpoint a name here, so I’ll just call it Endpoint 1.</p>
<p>Now in the target resource type, you can see we have a couple of different options here. Cloud service, app service, App Service Slot, and Public IP. Since we are using App Service as our endpoints, it stands to reason that we deploy App Service as our target resource type. And then once we do that, the Target Resource dropdown allows us to select our app service. We can see we have one in the central US and one in east US. So we’ll select the blue widget 1 for a primary endpoint here.</p>
<p>Now, if we hover over custom header settings here, what this does is allow us to configure custom headers for the app. We don’t need any custom headers for our applications here, so we’ll leave this box alone. Now we could add our endpoint in a disabled state by checking the Disabled box, but we’ll add this in in an active state. And to do that, we simply click the Add button.</p>
<p>To add the second endpoint, we just repeat the process. We go ahead and add. We’ll select the Azure endpoint, We’ll call this Endpoint 2. We’ll select the app service, and then we’ll choose Blue Widget 2 this time. Now to test our Traffic Manager, if we bounce out to Overview here, we can copy the URL, which is the DNS name for our Traffic Manager. And to get to our Traffic Manager, we’re going to hit <a target="_blank" rel="noopener" href="http://mybwapp.trafficmanager.net/">http://mybwapp.trafficmanager.net</a>.</p>
<p>Let’s open up an Incognito window here, and there you go. So Traffic Manager is now going to send me to the closest iteration of our web app. In my case here, I have an east US deployment and a central US deployment. Me personally, I’m located in the eastern part of the United States.</p>
<p>So what Traffic Manager will do is look at where the request for the application is coming from and send me to the closest iteration of that web app based on the DNS request. And that’s pretty much it. That is how you deploy and configure a Traffic Manager profile.</p>
<h1 id="Course-Conclusion"><a href="#Course-Conclusion" class="headerlink" title="Course Conclusion"></a>Course Conclusion</h1><p>Congratulations! You’ve come to the end of Load Balancing with Azure. Let’s review what you’ve learned.</p>
<p>We started things off with load balancers, where you were introduced to the different types of load balancers, their components, and their use cases. You even got to see a demonstration that showed you how to deploy a load balancer using the Azure portal.</p>
<p>After covering load balancers, we dove into Application Gateway. You learned what it is, what its features are, and what components comprise it.</p>
<p>We then worked through the deployment of an Application Gateway.</p>
<p>Next, we took a look at Azure Front Door, where you learned what the Azure Front Door service is and how to create a front door instance.</p>
<p>We then dove into Web Application Firewall. You learned what it is and when to use it. You also learned about using it with Application Gateway, Azure Front Door, and with Azure CDN. We wrapped up the section with a deployment of Web Application Firewall on Application Gateway.</p>
<p>After covering Web Application Firewall, we wrapped up with Traffic Manager, which is essentially a DNS-type load balancer. You learned what Traffic Manager is, how it works, and when to use it. You also got to see a demonstration of how to create a Traffic Manager profile.</p>
<p>At this point, you should have a good understanding of how to load balance with Microsoft Azure.</p>
<p>To learn more about load balancing with Azure, you can, and should, read Microsoft’s published documentation. You should also keep an eye out for new courses on Cloud Academy because we’re always publishing new ones. </p>
<p>Be sure to give this course a rating, and if you have any questions or comments, please let us know.</p>
<h1 id="5Application-Gateway-Intro"><a href="#5Application-Gateway-Intro" class="headerlink" title="5Application Gateway Intro"></a>5<strong>Application Gateway Intro</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/application-gateway/features">List of Gateway Features</a></p>
<h1 id="6Application-Gateway-Components"><a href="#6Application-Gateway-Components" class="headerlink" title="6Application Gateway Components"></a>6<strong>Application Gateway Components</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/application-gateway/application-gateway-components">Azure Application Gateway Components</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-104-Create-Your-First-Azure-Virtual-Network-27/" rel="prev" title="AZ-104-Create-Your-First-Azure-Virtual-Network-27">
      <i class="fa fa-chevron-left"></i> AZ-104-Create-Your-First-Azure-Virtual-Network-27
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-104-Application-Load-Balancing-with-Azure-Application-Gateways-29/" rel="next" title="AZ-104-Application-Load-Balancing-with-Azure-Application-Gateways-29">
      AZ-104-Application-Load-Balancing-with-Azure-Application-Gateways-29 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#An-Intro-to-Azure-Load-Balancers"><span class="nav-number">2.</span> <span class="nav-text">An Intro to Azure Load Balancers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Load-Balancer-Components"><span class="nav-number">3.</span> <span class="nav-text">Load Balancer Components</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Deploying-a-Load-Balancer"><span class="nav-number">4.</span> <span class="nav-text">DEMO: Deploying a Load Balancer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Application-Gateway-Intro"><span class="nav-number">5.</span> <span class="nav-text">Application Gateway Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Application-Gateway-Components"><span class="nav-number">6.</span> <span class="nav-text">Application Gateway Components</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Deploying-an-Application-Gateway"><span class="nav-number">7.</span> <span class="nav-text">DEMO: Deploying an Application Gateway</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#An-Intro-to-Azure-Front-Door"><span class="nav-number">8.</span> <span class="nav-text">An Intro to Azure Front Door</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Creating-a-Front-Door"><span class="nav-number">9.</span> <span class="nav-text">DEMO: Creating a Front Door</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-Web-Application-Firewall"><span class="nav-number">10.</span> <span class="nav-text">What is Web Application Firewall?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Enabling-Web-Application-Firewall-on-Application-Gateway"><span class="nav-number">11.</span> <span class="nav-text">DEMO: Enabling Web Application Firewall on Application Gateway</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#An-Intro-to-Traffic-Manager"><span class="nav-number">12.</span> <span class="nav-text">An Intro to Traffic Manager</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Creating-a-Traffic-Manager-Profile"><span class="nav-number">13.</span> <span class="nav-text">DEMO: Creating a Traffic Manager Profile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Conclusion"><span class="nav-number">14.</span> <span class="nav-text">Course Conclusion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5Application-Gateway-Intro"><span class="nav-number">15.</span> <span class="nav-text">5Application Gateway Intro</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6Application-Gateway-Components"><span class="nav-number">16.</span> <span class="nav-text">6Application Gateway Components</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
