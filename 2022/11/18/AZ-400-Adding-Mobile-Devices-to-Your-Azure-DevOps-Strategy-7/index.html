<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Course IntroductionHi, my name is Kelso Sharp, I have been writing web applications for the past 20 years. I’m also a Microsoft Certified Professional and an Azure Cloud Architect. I’ve been working w">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7">
<meta property="og:url" content="https://example.com/2022/11/18/AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="Course IntroductionHi, my name is Kelso Sharp, I have been writing web applications for the past 20 years. I’m also a Microsoft Certified Professional and an Azure Cloud Architect. I’ve been working w">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-19T00:37:37.000Z">
<meta property="article:modified_time" content="2022-11-27T14:06:24.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/18/AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/18/AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-18 20:37:37" itemprop="dateCreated datePublished" datetime="2022-11-18T20:37:37-04:00">2022-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-27 10:06:24" itemprop="dateModified" datetime="2022-11-27T10:06:24-04:00">2022-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-400/" itemprop="url" rel="index"><span itemprop="name">AZ-400</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/18/AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/18/AZ-400-Adding-Mobile-Devices-to-Your-Azure-DevOps-Strategy-7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Course-Introduction"><a href="#Course-Introduction" class="headerlink" title="Course Introduction"></a>Course Introduction</h1><p>Hi, my name is Kelso Sharp, I have been writing web applications for the past 20 years. I’m also a Microsoft Certified Professional and an Azure Cloud Architect. I’ve been working with the Microsoft web development stack since 1996. Welcome to my course on implementing mobile DevOps strategy.</p>
<p>In this course, we will be discussing and demonstrating how to implement a mobile DevOps strategy. If you run into any issues during the course, please feel free to email <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a> and the team here at Cloud Academy we’ll do our best to help you get your issues sorted out as quickly as possible. As always, please remember to rate my course and provide feedback as I’m always looking to improve my courses.</p>
<p>Visual Studio App Center is a collection of common services and integrated tools that are part of <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a>. It allows you to create a mobile DevOps strategy for building, testing, and releasing your mobile applications. With App Center, you can perform build and automated UI testing for iOS, Android, Universal Windows Platform, and tvOS, using different native and web-based testing frameworks.</p>
<p>Just like Azure DevOps pipelines, App Center can trigger builds and distribute your releases. It also provides you with a way to test your mobile applications on real devices. You can group devices together into a set and create a test series that has one or more device sets. In a future module, we’ll talk about device sets, device series, and device tiers.</p>
<p>Although compared to <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a>, App Center is a little bit more streamlined and build and release functionality is not quite as robust. However, it makes up for this with the ability to do testing on real devices and with its integration with Azure DevOps pipelines. We will go through a demo on how to integrate apps in our UI testing and distribution into an Azure DevOps pipeline in a future module. If you’d like to know more about Azure DevOps pipelines, you can check out one of my other courses here on Cloud Academy called <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-and-managing-azure-build-infrastructure/course-introduction/">Implementing and Managing Azure Build Infrastructure</a>.</p>
<p>Implementing a mobile DevOps strategy can involve a number of tasks such as continuous integration, continuous delivery, and user interface testing. One of the greatest challenges to mobile development is the ability to run the same application across hundreds of different devices and still achieve the same user experience.</p>
<p>This necessitates the need to do testing that spans multiple device tiers, multiple operating systems, and multiple device manufacturers. This could be a truly expensive and daunting task. Lucky for us, this is where App Center comes to the rescue.</p>
<p>As I mentioned, App Center has a number of services and tools for creating a strategy for building and releasing our mobile applications. These tools are <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/mobile-build-services/">build services</a> which uses built-in agents or custom scripts to perform built functions, Test Runs, which is an automated UI testing tool that runs our unit tests on a real device or set of devices.</p>
<p>App center supports iOS, Android, Universal Windows Platform, and tvOS. Your mobile applications can also utilize App Center’s analytic and diagnostic services to collect data about your application and how it’s being used. This can give valuable insights and how to improve your application, what new features to add, and to find undiagnosed issues that will surely show up from time to time.</p>
<p>App Center allows you to automate your release process and distribute your application to testers prior to releasing it to the various app stores. This can reduce the possibility of missed tests and rejected app store approvals, which can be time-consuming and costly.</p>
<p>This course is intended for IT and DevOps professionals that need to implement a DevOps strategy for mobile applications, IT professionals that wanna learn more about mobile DevOps options in Azure, and anyone looking to increase their knowledge on how to deploy mobile applications using Visual Studio App Center.</p>
<p>For this course, you should have an understanding of DevOps processes, you should be able to set up your IDE or integrated development environment for mobile application development. You should be able to install Node Package Manager and other command-line tools if you intend on following along in the demos. You should have a good understanding of Azure Pipelines, and how to work with YAML files and service connections in Azure DevOps.</p>
<p>In our first module, we’ll look at the Visual Studio App Center, what it is, and how it plays into our mobile DevOps strategy. In our second module, we will look at build services and iterate on the build service options available there. Then we’ll go through a demonstration of creating an App Center account, creating an organization, connecting to our code repository, and building our application.</p>
<p>From there, we’ll have a look at UI testing for multiple device sets and go through a demo of setting up a test series and creating a device set that will allow us to run our UI tests on actual devices. We will do this using both App Center CLI, and Azure DevOps pipelines. Then we’ll have a look at distribution groups and how to release our application to these groups. Finally, we will discuss implementing analytics and diagnostics, and demonstrate how to build this functionality into our application.</p>
<p>By the end of this course, you should be comfortable with creating an App Center account, creating an organization, and adding a new application. You should be able to create public and private distribution groups, build your applications, run UI testing across multiple device sets using both App Center Command Line Interface, and Azure DevOps pipelines. Finally, you should be able to understand and use analytics and diagnostics provided by App Center.</p>
<p>Now that we have a plan, let’s get started.</p>
<h1 id="Mobile-Build-Services"><a href="#Mobile-Build-Services" class="headerlink" title="Mobile Build Services"></a>Mobile Build Services</h1><p>In this module, we will be discussing <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-app-center-build-services/">App Center Build services</a>. Build services allow you to connect to your code repository and trigger a build when code is committed. This is an optional service, and it’s up to you to decide if App Center build services will work for your application or not. You also have the option to use <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps Pipelines or you can also simply upload pre-built application files for testing and release. To help you determine if build services will be appropriate for your application or not, let’s talk about the capabilities of the build service.</p>
<p>Build services can build <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile applications</a> for iOS, Android, Windows Platforms, and tvOS respectively. For iOS, App Center supports the Swift and Objective C programming languages, and for platforms, it supports React Native, Xamarin, and Cordova is currently in preview. For Android, the supported languages are Java and Kotlin, and supported platforms are React Native, Xamarin, and again Cordova in preview. Windows Operating system platforms are Universal Windows Platform, Windows Presentation Foundation, WinForms, and Unity. tvOS currently only supports Objective C and swift.</p>
<p>The currently supported code repositories are GitHub, GitLab, BitBucket, and Azure Repos, but this service offering will likely continue to grow as App Center expands and improves. You are able to connect by giving app center third party access to your code repositories. When you build your application, you can perform a one-time configuration that allows you to sign any of your builds so that you can distribute your application to groups of users such as testers or to the respective app stores. Unsigned builds can only be run on an emulator, so if you plan to distribute your mobile application, signing your build is mandatory. Build signing is a way to ensure that no one other than you can update your application.</p>
<p>Your mobile applications are built using single-use VMs that are expressly spun up to build your application, after which they are immediately torn down to ensure that you have a clean environment and to maintain the security of your application.</p>
<p>Builds for iOS and Android by default use a macOS VM with common development and runtime software installed. You can find the list of software installed here at this <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/build/software">URL</a>.</p>
<p>Windows mobile applications are built using a Microsoft hosted agent running windows and visual studio. You also have the option to build your Android applications using this configuration although it’s not the default setting. You can find the relevant information for the VM and software installed here at this <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted?view=azure-devops#software">URL</a>.</p>
<p>Now that we know what’s included in the build services, let’s go take a look at our build services demo.</p>
<h1 id="DEMO-App-Center-Build-Services"><a href="#DEMO-App-Center-Build-Services" class="headerlink" title="DEMO: App Center Build Services"></a>DEMO: App Center Build Services</h1><p>In this demonstration, we’ll be diving into App Center <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/mobile-build-services/">build services</a>. App Center can handle building <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile applications</a>, testing UI on physical devices, managing distribution groups, crash reporting, and usage monitoring.</p>
<p>The first thing that we need to do is point our browsers to appcenter.ms. This will take us to the main sign up page for App Center. We will just click the “GET STARTED” button in the top right. This link will take us to the create account page. Here we have the option to use third-party authentication from GitHub, Microsoft, Facebook and Google. We can also create an App Center account directly. I’m just gonna use my GitHub account because that will make it simple to connect to our code repository on GitHub.</p>
<p>Once we have signed into our account, the first thing we might wanna do is to set up an organization. Organizations in App Center are just a convenient way to organize our applications, especially if we’re working with multiple teams and multiple applications. Attaching an <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> subscription to this organization will allow you to integrate it with tools like Azure Key Vault and Active Directory from that subscription.</p>
<p>Now we can click the “New App” button in the top right. That will bring up our new application configuration page. Here we can enter our application name, and note this did not need to be the same as our project name. We then pick an operating system and a platform and finally click the “Add new app” button to create our application. I’m not gonna add this app since I’ve already created one for us to use in this demo.</p>
<p>If you’d like to clone the mobile application to follow along with this demo, you can find it at the following <a target="_blank" rel="noopener" href="https://github.com/kelsosharp/MobileDevOps">URL</a>. This application is just a template Xamarin drawer style Android application, with a Xamarin UI Test project for the UI testing. We will need this later to integrate our tests with the App Center Testing API.</p>
<p>The main overview page should now be displayed. This page explains how to configure App Center to work with your particular development environment and IDE setup. We’re using straight Xamarin on a Windows 10 client machine, which means we will need to have the Xamarin SDK installed at a minimum.</p>
<p>Now let’s have a look at how to connect our code repository to our new App Center application. We will just click on the build option from the menu on the left-hand side, that will give us a list of code repository providers and currently App Center only supports <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a>, GitHub, Bitbucket and GitLab. Our code is currently in GitHub so that’s what I will select.</p>
<p>Now we see a list of repositories on our GitHub account. I will select the MobileDevOps project and that’s all we need to do to link our App Center account to our code repository. If you did not use GitHub as your credentials provider, you will most likely need to authenticate with whichever provider you use and provide access for App Center to your repository.</p>
<p>Since I’ve already committed the master branch to my code repo and it is ready to build, we can now configure our build settings for this branch. When we click it we can see that there’s now a “Configure build” button on our last commit. I will go ahead and click it so we can configure the App Center build options.</p>
<p>This is our build configuration page. Here we can set the type of build we want, debug or release. We can set the version of the Xamarin SDK used to build our application, we can specify any build scripts we might wanna use, and set our build frequency. This is what triggers our builds. Some of the other options are Build Android App Bundle, this creates a bundle as well as your APK file if checked. We can turn on auto-increment for updating our app version automatically, we can set environment variables. If you’re going to use App Center to deploy your application, this is where you would provide your KeyStore or provisioning profile for Android and Apple. This will allow App Center to sign our builds for deployment to the app stores and enable physical device testing.</p>
<p>At this point, we can set our build to do an initial test on an actual device, but in order to do that, we need to change a project property in our Android project. “Use a shared Runtime” needs to be unchecked. Let me show you how to do that in Visual Studio.</p>
<p>The first thing we need to do is to right-click on our main Android project and select the project properties page. On the properties page, we need to click on the “Android Options” section and then uncheck the “Use Shared Runtime” option. This is usually checked by default and I previously unchecked it when I created this project for use in our course.</p>
<p>Now that we have our build configuration set up, let’s run our build. This is gonna take a few minutes, so while that’s building, let’s talk about the costs for App Center Services. The free tier of App Center gives you 240 build minutes per month, with a single build time limit of 30 minutes. You get a 30-day free trial of UI testing on real devices to start with, unlimited distributions and unlimited users, and full access to analytics and crash reporting.</p>
<p>If the free tier is no longer meeting your needs, for example, if you have multiple teams building multiple applications in App Center at the same time, without concurrent builds, they will simply be queued and execute in sequence. You can add additional concurrent builds for an extra $40 per month for each additional build. This is referred to as build concurrency. This is defined by Microsoft as “the number of builds that can run in parallel “at any given time.”</p>
<p>For <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/ui-testing-in-app-center/">UI testing</a> this is a similar pricing model. After your 30-day trial is over, testing costs $99 per month for 30 hours of device time per device concurrency. For example, if you have five devices, the devices will be tested in sequence up to 30 hours in a month. If you were to purchase five concurrent devices, then all five devices would be tested at the same time and reduce your overall testing time to one fifth, and you have 150 total device hours to work with.</p>
<p>Now that our build is done, we can see that it’s been successful. So as you can see there’s plenty of options in the build services for App Center. In our next module, we’ll be talking about how we go about testing our mobile applications on real devices. I hope I see you there.</p>
<h1 id="UI-Testing-in-App-Center"><a href="#UI-Testing-in-App-Center" class="headerlink" title="UI Testing in App Center"></a>UI Testing in App Center</h1><p>One of the major benefits of testing in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-app-center-build-services/">App Center</a> is the ability to test your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">application</a> on multiple physical devices, without the need to buy the actual devices themselves. App Center provides the ability to create something called a device set. A device set is a set of device configurations grouped together by different options, such as OS version, manufacturer, and device tier. A device here is a value of 1, 2 or 3, with the lower numbers representing the most current hardware released. You can also filter the device list by other options, such as CPU, memory, and form factor.</p>
<p>You can add these device sets to a test series. A test series can be a way to organize different types of tests like smoke test or <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-ui-testing/">UI test</a>. You can also use it as a way to group multiple device sets to run them together. There’s no limit to the number of device sets or test series you can have.</p>
<p>You can use one of a number of testing frameworks in App Center. The current testing frameworks include Appium, XCUITest, Espresso and Xamarin.UITest. To utilize a testing framework, you simply add one of the chosen frameworks to your solution as you normally would, then create a test run in App Center that is configured to use your testing framework.</p>
<p>App Center takes the unit test framework and utilizes it to run your test on each of the devices in the device set. It takes a screenshot of the test results and creates a test report and adds them to the App Center. </p>
<p>You can run your tests in App Center by using one of three options. You can use the App Center CLI, the App Center REST API, or you can use an <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps pipeline task. In a later demo, we will walk through running our tests from the App Center CLI and from an <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a> pipeline. If you’d like to know more information on the App Center API, you can find it at the following <a target="_blank" rel="noopener" href="https://openapi.appcenter.ms/#/test">URL</a>.</p>
<p>Now that we have a basic understanding of what testing entails in App Center, let’s check out the demo.</p>
<h1 id="DEMO-App-Center-CLI-UI-Testing"><a href="#DEMO-App-Center-CLI-UI-Testing" class="headerlink" title="DEMO: App Center CLI UI Testing"></a>DEMO: App Center CLI UI Testing</h1><p>In this demo, we’re going to use the App Center command-line interface to upload and run our unit tests from our test project. This requires that you have Node js 6.3 or later, npm and the App Center CLI installed. You also need to make sure that the testing framework you picked when you set up your test run is also installed and configured for the project. In our case, we’re using the Xamarin.UITest.</p>
<p>So now that we have a successful build, let’s have a look at testing. We will select the test menu option on the left side and that will bring up our test runs page. If you’ve already had a few test runs, this will show a list of the runs here. If you’ve set your build configuration to do an initial test on a real device, you will see that test run listed here.</p>
<p>If you do not have any test runs yet, there should be a button that says start testing your app. Clicking this will bring up a dialog, that asks you if you want to start your free trial of device testing. We can click on the Start Trial button and this will bring up a list of devices to choose from.</p>
<p>We can select whichever devices that you’d like to use to test your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile application</a> on. You can filter the device list by Foreign factor, CPU, memory, operating system and manufacturer. Once you have a list of devices you want to use, just check the checkbox beside each one or check the checkbox at the top of the list to select them all. There’s a lot of options here. If you want to see the list of all the devices available, you can check them out at this <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/test-cloud/devices/android">URL</a>.</p>
<p>When you run the command to upload and execute your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/ui-testing-in-app-center/">UI tests</a> using the App Center CLI, there’s a few pieces of information that would be helpful to have handy, or to know when typing out the command. The first is your App Center username or organization name. However, you need to replace the @ symbol in any spaces with a hyphen as these cannot be used in the command-line. The next piece of information that’s handy to have, is the path to the APK file that’s built by your project. You can specify this path when you build your Android application for the first time in Visual Studio.</p>
<p>The next piece of information that you need to have is the path to the cloud-test.exe file in the Xamarin.UITest NuGet package for our test project. Xamarin no longer uses a NuGet.config file or creates a packages folder as part of the project. So you need to specify the path using the argument, <code>--uitest-tools-dir</code>, to specify the path. This will be different depending on the version of the NuGet package you’re using. And if you upgrade your NuGet package, you will need to update this path as well.</p>
<p>This is a fragile and brittle implementation and can cause you hours of frustration if you’re not aware of it. The App Center Dev team at <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft</a> is aware of this issue and is currently working on providing a better way to handle it.</p>
<p>Finally, you will need the name of the device set in the App Center, that you want to use to test your project. If you create a new series without first creating a device set, there will be a button named Save set, in the top right of the configuration page. If you do not click this and give the set a name, a random ID will be created for the set and the set itself will not be saved.</p>
<p>Once you’ve chosen your testing series and your testing framework, you will then be given the opportunity to copy the <code>appcenter-cli</code> command to the clipboard. This command has the device set random identifier, and this is what we used for this demo. But if you do not copy to the clipboard now, or you do not click the Save set button and give it a name, you will not be able to find it again once you leave this page. So I recommend that you either create a device set prior to creating a test series or save the device set for later use.</p>
<p>I’m just going to take these paths and paste them along with the command in the notepad here to make it easier for me to edit. You will need to use this every time you want to run the UI tests on this device set in App Center. The identifier given as the name for the device set defines a list of devices being used for the tests. So if you copy these identifiers, you can reuse them in PowerShell or bash so that you can run multiple UI tests against multiple device sets.</p>
<p>Now, I will copy the command and run it in our command window. This, will upload the project files and run the unit tests that are in the Xamarin.UITest project on all the devices in the test series we named Master.</p>
<p>Now as we watch, we can see that these tests are being run in sequence and not in parallel. If we had paid for additional concurrent devices for our apps in our account, we could have run these in parallel and reduce the length of time needed to run our tests. For just a few devices, this is not too much of a problem. But if our device set had hundreds of devices, it could take many hours to get through them all and we would like to run out of device minutes quite quickly.</p>
<p>Once our tests have completed, we can look at the test run page in App Center and see that they’ve passed successfully. And we can have a look at the results for each of the test as an image on the device it was run on.</p>
<p>That’s all there is to having App Center run our UI unit tests on actual physical devices. This gives us the comfort of knowing exactly how our UI will run on each of the devices we used to test with. A small price to pay to know our user experience will be consistent across many devices.</p>
<p>In our next module, we’ll be demonstrating how to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-app-center-azure-devops-integration/">integrate Apps Center UI testing into an Azure DevOps Pipeline</a>. It’s some pretty cool stuff, so let’s go check it out.</p>
<h1 id="DEMO-App-Center-Azure-DevOps-Integration"><a href="#DEMO-App-Center-Azure-DevOps-Integration" class="headerlink" title="DEMO: App Center Azure DevOps Integration"></a>DEMO: App Center Azure DevOps Integration</h1><p>In our previous demo, we used the App Center CLI to upload and run our <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-ui-testing/">unit tests</a> from our Xamarin.UITest project. Now, I will show you how to add the App Center Test task to a pipeline in <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/https://cloudacademy.com/library/azure/">Azure</a> DevOps. This task is the equivalent to the App Center CLI command, and it uses the same REST API that the App Center CLI used. We will use this task to upload our project to the App Center and test it on the device set we called master. But before we can do this, there are a few things that we need to do to enable us to run this task successfully.</p>
<p>Before we head to <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a>, we need to create an API access token for the App Center. This token will grant Azure DevOps access to our App Center organizations and applications. We can do this by clicking on our profile icon in the top-right corner of the page, selecting account settings, and then scrolling down and clicking the API tokens. This will open a page that lists our existing API tokens, if we have any.</p>
<p>Now, we need to click the New API token button in the top-right. This opens a configuration page and here we need to give our token a name and set the access level to full. Once we have done that and clicked the add, this will bring up a dialog box that has our access token displayed, and gives you the opportunity to copy your token to the clipboard. This is the only chance you’ll get to copy this token, so make sure to copy it and save it to a safe place.</p>
<p>We can now head to Azure DevOps and open our project settings page. From the list of options now displayed, we click on the service connections menu option. This will display a list of current service connections and a new service connection button will be in the top-right. Clicking this button will give us a list of options to choose from. We wanna scroll down and select Visual Studio App Center. After selecting this option and clicking the next button, we need to paste our new API key here in the API token box and add any details that you’d like to add. The checkbox under the security heading, if checked, gives all pipelines immediate access to this service connection upon creation. If unchecked, you need to authorize each pipeline that uses this service connection individually the next time you build those pipelines. Click save, and you now have a new service connection to the App Center.</p>
<p>Azure DevOps pipelines are the CI&#x2F;CD or Continuous Integration Continuous Delivery automation process for building our projects. The first thing we’re gonna wanna do is to create a variable group and variables to hold our security information for signing our build. We will use encrypted variables to prevent them from being saved as plain text in our code repository.</p>
<p>So we will click on the Pipelines option from our project menu on the left side, and then click Library. The Library is where we can create variable groups, environment variables, and upload secure files, like our Android Keystore. We can also set up access roles for these files and variables and assign users to those roles.</p>
<p>Now we click on the Add Variable Group button. This will bring up a configuration page for creating a new variable group. I’m gonna call this group Android key group, and we’re going to add each of the variables we need for signing our build. The variables that we need are the Keystore password, our key alias, and our key password. If your App Center or Azure DevOps organization is linked to an Azure subscription, we would be able to use the Azure Key Vault here to store these values and access them.</p>
<p>Unsigned Android builds are only allowed to run in an emulator. So if you wanna be able to test on a real device, you’re required to sign your builds. In order to sign a build for an Android application, you need to create a Keystore file using Android studio. If you’d like to know more about how to sign your Android builds for use outside of an emulator, you can get more information at the following <a target="_blank" rel="noopener" href="https://developer.android.com/studio/publish/app-signing.html">URL</a>.</p>
<p>The first variable we will create is going to hold our Keystore password. We will name the variable keystore.password. And by clicking a lock on the right here, it will encrypt this variable and change the input to a password text box type. Next, we’ll create the variable for the key alias and we will name it key.alias. Finally, we will add the variable for the key password itself and name it key.password. Oh, I forgot to save my variable, so when I clicked on the Pipeline’s menu option, I got a popup that asked me if I really wanna leave the page. So, I will click no, and I will save my variables now by clicking on the save icon at the top of the page.</p>
<p>The last thing that we would need to do is upload our Keystore file to the secure files area of the library section. We will click on the secure files link here, and this is where you would upload your Keystore file. I’ve already done that, so I do not need to do it again. And if we click on the file, we see that we can add additional properties and we can authorize its use for all pipelines.</p>
<p>Now that we have our sensitive data configured, we will edit our Azure Pipeline by updating our YAML page. YAML is the configuration markup language Azure DevOps uses to configure tasks for its pipelines. You can find out more about YAML and the schema that Azure DevOps uses at the following <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema,parameter-schema">URL</a>.</p>
<p>We will need to modify our YAML page so that we can add our App Center Test Task. It requires a bit of setup to be able to run successfully. We’ll do that next.</p>
<p>We will click on the pipelines link on the left. That will take us to a list of builds that we’ve run previously. We can click on any one of these, since we will be creating a new branch for our edited pipeline. Then we will click the edit button in the top-right, which will bring up the YAML configuration page for our default master branch.</p>
<p>Now that we have our YAML page up, we can begin editing it. Because we are adding a variable group to the variable section, we need to be a bit more specific in how we define our other variables. So we need to add the name and value properties to the variable declarations.</p>
<p>These variables are buildConfiguration, which is set to Debug, and outputDirectory, which is set to our bin directory, using the built-in build variable, build.binariesDirectory. Wow, that was a mouthful. Then a slash and our buildConfiguration variable that we just said. This is the standard path Visual Studio uses when compiling projects. By using this built-in build variable, it points our outputDirectory variable to the correct path for the project we’re building. That way, we only need to set it once for both projects. We can now add our variable group. YAML is very particular in how the commands are laid out in regards to spacing and how things are defined.</p>
<p>After we’ve added our variable group, we need to modify the NuGet Command to specify our directory to put our NuGet packages into. One of the challenges of implementing an App Center Test Task is that Xamarin projects no longer use a NuGet.config file, and it no longer copies the NuGet packages into a packages directory in the project by default. So we need to force the command to do that, so we know where to find the cloud-test.exe file that App Center needs in order to upload and run our Xamarin.UITest project.</p>
<p>The hosted build agent, however, does use the Nuget.config file. And we can fix this by adding the restoreDirectory property to the NuGet Command task and pointing it to our main project folder slash packages. We can do this using the built-in build.sourcesDirectory. This variable always points to the current project’s main directory.</p>
<p>The next thing we need to do is to create separate build tasks for each of our projects. By default, the main Xamarin.Android task tries to build all projects within our solution, assuming that they are all Android applications. This will not work for our test project. So we need to enter the name of our specific project file for our Android main project. We will keep our output directory and configuration the same, since they are already pointing to the variables we set up. Although not completely necessary, I like to specify the Java Developers Kit version here, since I have multiple versions of this STK on my computer. JDK Version sets this to the most current version.</p>
<p>The next task we want to prepare is signing our build so that we can test our application on real devices. So if we go over here to the right, and at the top, we see that there’s an Android signing task. When I click this, it shows the configuration page for this task.</p>
<p>The first thing you need to do is enter the path to the APK file that’s created from our previous build task. That value is stored in our outputDirectory variable. So we can just use that here rather than hard-coding a path. Hard-coding a path can be very brittle and can cause the build to break if it changes.</p>
<p>Next, we need to make sure the Sign the APK checkbox is checked, and for the Keystore file, we just need to enter the name of the file we uploaded to the secure files area of the pipeline library. We will likely need to authorize this later when we go to run the build. For the Keystore password, alias, and key password, we just need to enter the variables that we previously added to our variable group in the library. Doing this prevents us from needing to add them here as plain text and storing it in our repository.</p>
<p>There’s a few additional properties here, apksigner is used if you wanna use a different signing library for our applications. The Zipalign checkbox is used when we wanna conserve RAM. And the last property is our location for a custom application for Zipalign. We can just use the defaults that are part of the Android SDK and click the Add button to add our task.</p>
<p>Our next task is to build our test project. We need to do this because the binaries need to be uploaded to the App Center for our final App Center Test Task. I’ll just scroll down to the Xamarin.Android task and click it to bring up the configuration page. The last time we modified the YAML directly, this time we’ll configure a new task and add it to our YAML page. I could just copy the Xamarin.Android task, but I wanted to show you both ways to add a task.</p>
<p>First, we enter our project file name. Next, we have the target property. This is why we need to use a separate task for building this project. When you build an Android application, it expects a target. And since this is not an Android application, we will not have a target, causing our build to fail. So we need to set the prepare package property here to false so that it doesn’t look for a value in the target property and cause an error.</p>
<p>Next, we put our outputDirectory variable into our output directory property, and our buildConfiguration variable into our configuration property. Again, we could change our JDK version here and as you can see, there’s multiple options we can choose, but we’ll just use the default. And now that we’ve configured our task, we just click add.</p>
<p>Now to the main topic of this demo. The rest was all done to prepare our build process to be able to run our App Center Test Task. We can just click on the task, since it’s at the top of the list on the right here. And as usual, we get our task configuration page. First thing we wanna do is specify the path to our APK file that was created when we built our main Android project. We just need to add our outputDirectory variable, and a slash, and our APK file name. What we could have done previously is create a variable to hold the name of the APK file or the full path. That would have saved us some keystrokes.</p>
<p>We wanna make sure that the checkbox for Prepare Tests is checked, because if we miss this, when the App Center tries to run the UI test, there won’t be any binary files in the output directory. The Artifacts directory has already been set up for us and points to the App Center staging directory. We have no access or control over this directory on App Center. However, we could set up our own Artifact’s directory in either Azure DevOps, or if we were using a self-hosted build agent, we could specify one on the agent machine. I explained build agents in mode depth in my course on implementing and managing Azure build infrastructure here on cloudacademy.com. Be sure to check that out, if you wanna know more about managing your build infrastructure in Azure DevOps.</p>
<p>The next property we need to set is the testing framework we’re using. This is Xamarin.UITest. Now, we set the path to our build directory. In our case, we can use our outputDirectory variable. Now, we could have added our Keystore file and signing credentials here, but I like to keep this separate. It makes the task smaller and easier for us to change later on without potentially impacting our testing task. It’s just a matter of personal preference, you’re free to configure it here without any additional Android signing tasks.</p>
<p>At this point, we come to the part that can make this task in the App Center CLI command challenging to get working properly. This property here is the reason we added the restoreDirectory property to the new command previously. Since Xamarin.Android project’s default NuGet package style has migrated to using NuGet as a PackageReference, it no longer copies the packages into a package folder in your solution. This can make it very difficult to find the cloud-test EXE file consistently, as it will be in a different location for each developer on your team and for each version of the package.</p>
<p>We need to enter the path to our tools directory. That will be the built-in build.sourcesDirectory environment variable, &#x2F;packages&#x2F;Xamarin.UITest&#x2F;3.0.3, which is the version of our Xamarin.UITest NuGet package. And then a &#x2F;tools.</p>
<p>For Xamarin.Android projects, I highly recommend that you add the file to the project as a resource and check it into your code repository so that it’s always in the same location for everyone. This just makes it easier to find when testing your project either in App Center CLI or Azure DevOps. Just remember to update your file, if you change the version of the Xamarin.UITest NuGet package.</p>
<p>Next, we select our Visual Studio App Center service connection, and then the App Center Slug property is the App Center’s way of identifying which application we’re trying to test. It consists of the project owner, in this case our organization, and then a forward slash and our app name in App Center. This might not be the same name as our project. Our devices property value, depending on if we are using a saved device set or a random identifier created by App Center is the identifier. Or if we have an organization, it’s our organization name, a forward slash, and then the name of our device set, which is master. Our test series is also named master. The dSYM directory is for iOS, and we’re not gonna be using it. Our language is set to English United States, and this will set our locale to en_US.</p>
<p>Now we can click add and have a look at our task in YAML. As we can see, all of our settings have been configured. Although the Prepare tests property is set to true by default, I like to add it here to make sure that it’s clear. If it’s set to false, then the Test Task will fail because there’s not any binary files for the App Center to use to run our tests.</p>
<p>Now we can click save, and Azure DevOps will ask us if we wanna update our existing branch or create a new one. I’m gonna create a new one here and add a commit message. I’m not gonna create a pull request for this change, since I’d be the one that has to approve the change request anyway. Now, we will click run and see what happens. The build process takes about 17 or 18 minutes, so I’m gonna speed this up until we get to the end of the App Center Test Task. We can see from the build log, it ran successfully. And we can now go into the App Center and have a look at the test results. We can see that all the tests ran successfully and we have our report in App Center.</p>
<p>In this demo, we integrated Azure DevOps with our App Center testing by adding an App Center Test Task to an Azure DevOps pipeline. This runs our project unit tests against the device set we created in the App Center. Having the ability to use Azure DevOps to run our App Center UI tests certainly makes it much easier to implement a mobile DevOps strategy. It is just a matter of adding a few additional tasks to our CI&#x2F;CD pipeline, and we have a completely automated build process for our mobile applications.</p>
<p>In our next module, we will talk about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/distribution-groups-introduction/">distribution groups</a> and how to get your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile application</a> to your testers and your users. I hope to see you there.</p>
<h1 id="Distribution-Groups"><a href="#Distribution-Groups" class="headerlink" title="Distribution Groups"></a>Distribution Groups</h1><p>Once an application has been built, regardless of how you build your application, App Center can distribute your release to a target audience.</p>
<p>A distribution group is a group of users that are managed together. This gives you the ability to manage access and releases on a group level. This can reduce the management headache of trying to get your application out to each of your users individually. Distribution groups can be public or private, and the App Center can also distribute your application to the various app stores for sale. Distribution groups are private by default.</p>
<p>Private distribution groups contain users that are invited via email, and are given access to releases that are set for that distribution group. Users in private distribution groups will be notified via email whenever a new release is made available to the group. They are required to have an App Center account, and log in to their account to access these releases.</p>
<p>Public distribution groups allow unauthenticated users to access releases from publicly available links. Once a group has been named, it can be set public or private, and members of a public group will receive a notification of a new release just like members of a private distribution group. They are not, however, required to log in to the App Center to download the release, and anyone that has the link to the application can download and install your application. Tread carefully here.</p>
<p>You can create distribution groups for many types of users. Testers, beta testers, pre-release users, pre-order users, the list goes on and on. And distribution groups gives you an easy way to manage these users.</p>
<p>Organizations in App Center are used to group applications and users into a container. This allows the ability to create a shared distribution group, and, if connected to an <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> subscription, allows you to use Active Directory to add and manage users. This can greatly simplify access permissions and release management if your users all need the same access permissions.</p>
<p>For example, it’s highly likely that an organization will write multiple <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile applications</a> that will be tested by the same group of testers. A shared distribution group is a quick and easy solution to this problem. Shared distribution groups are created at the organization level, rather than the application level, and shared groups can be either public or private. Shared distribution groups can access all applications that are part of the organization.</p>
<p>You can add users to a shared distribution group via email, or, if your organization is linked to an Azure subscription, by adding an Active Directory user or group. To add users from Active Directory, you must first link your Azure subscription to your organization. And then, add the Azure Active Directory tenant to the organization in App Center. Once the tenant is connected, you can add Active Directory groups and users to your App Center distribution groups.</p>
<p>Distribution groups are a simple but powerful tool for getting your mobile application out to the people that need it, and provides an easy way to notify your users of new releases and updates to your mobile applications. So let’s go check out the next module that demonstrates how to add <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-distribution-groups/">distribution groups</a> to our mobile DevOps strategy.</p>
<h1 id="DEMO-Distribution-Groups"><a href="#DEMO-Distribution-Groups" class="headerlink" title="DEMO: Distribution Groups"></a>DEMO: Distribution Groups</h1><p>For this Demonstration, we are going to look at how to release our <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile application</a> to our users. First, we will create a public distribution group, then we will create a private distribution group. Then we will configure our master branch to release a build to one of our groups every time new code is committed to our master branch. Users come in many types and Distribution groups allow us to manage and deploy our application to our users.</p>
<p>To help me to explain the concept of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/distribution-groups-introduction/">distribution groups</a>, I am going to break them down into 3 broad types. There are obviously many more types of users but for the purposes of this explanation 3 types will be enough to get the point across. The definition of the 3 types are:</p>
<ul>
<li>Internal Developers: These are users that actively develop mobile applications within the company and are part of the dev teams that contribute directly to the application. Generally, these users would be added to the default collaborators distribution group.</li>
<li>UAT Testers: these testers perform User Acceptance Testing as part of an agile process and provide feedback and bug reporting. They are most likely company employees and have accounts in App Center for the purpose of manually testing the application before releasing an application out into the wild.</li>
<li>Finally, End Users: These are the users that will possibly be purchasing your application from the various App Stores, or downloading it from an Intune company portal.</li>
</ul>
<p>Mobile development generally speaking must go through a more rigorous testing process. This is because App Stores, like Google Play and Apple iTunes have strong testing requirements and there is a cost to releasing a mobile application to an App Store, if the mobile app fails the App Store quality check, the cost of the application is forfeit. Repeated failures can get really costly.</p>
<p>Also with mobile applications, it’s not an accepted practice to report errors directly to a user, being able to recover from errors without user input or knowledge is the accepted standard for mobile applications. So rigorous multi-level testing is required to meet the standards for being released successfully to an App Store.</p>
<p>This is why there is a need to have testing and feedback from multiple groups of users. Mobile application development is a costly endeavor so making every effort to release the highest quality application possible is even more important when creating mobile applications. Having multiple user groups that fill different testing roles is a great way to achieve this goal. Now that we have an idea of some of the reasons why having multiple distribution groups is beneficial, let’s have a look at how we can create and use them.</p>
<p>We’ll start off on the distribution groups page, and since we don’t have any distribution groups yet, there is a button there for us to add a group. App Center creates a new collaborators group whenever a new app is created. This is a good place to add our developers.</p>
<p>I will just click the add group button and this will bring up the configuration page for creating our new group, the first one will be a public group named “Beta” with just one person in it. Next, I will add another group this time we will make it private, and add 2 people to the group, That is all there is to creating distribution groups. If we had an <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> Active Directory Tenant, we would be able to add any users from that tenant in the add users’ textbox.</p>
<p>Now that we have added our distribution groups, we can specify that whenever a specific branch in our code repository is built it will automatically create a release to distribute to one of our groups. So I will just go over to where the builds are and select our master branch and click the edit settings in the top right. I will scroll down to the Distribute option and select one of the groups we created, we can also do this with the different app stores as well. Distributing to Google Play, Apple iTunes, or Microsoft Intune App Stores requires previous setup.</p>
<p>App Center is very easy to use, considering how challenging it can be sometimes to write mobile applications. Distribution groups give us a very simple way to release our application to our testers and users with very little setup needed.</p>
<p>Now that we have seen how to create a distribution group and trigger a release in App Center, let’s go check out how we can create an App Center Distribute Task in our Azure DevOps pipeline. In our previous demo, we created a task that runs our unit tests for our mobile application. Now we want to release our app to our testers.</p>
<p>In App Center, we created a very simple build and release CI&#x2F;CD automation process. We did this by creating a group and configuring our build so that every time new code was committed, If the build was successful for that specific branch it would create a release for the specific distribution group we set up.</p>
<p>In <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a> and YAML there are many more things we can do. We can make releases conditional on build step success or add check gates for approvals that need to happen before we decide to release, just to name a few. Let’s check out how to release a build to one of our distribution groups from Azure DevOps.</p>
<p>We have here our previous YAML page from our demo on testing using Azure DevOps pipeline integration. All I have done is comment out our App Center test task, since that takes about 18 minutes to complete, and for this example distribution, we don’t require a successful UI test task, but if we wanted to provide a success condition for that task it is an option.</p>
<p>So the first thing we do is click on the App Center Distribute Task on the right. This will bring up the usual task configuration page for us to fill out. First, we need to select the service connection we created. Paste in our App Slug, it’s the same as our test task, our binary path to the .apk file is also the same so I will cut and paste that as well.</p>
<p>Build version is for windows applications so we don’t need to do anything with that. We will use the default “Enter Release Notes” for the release notes type option. This allows us to enter a release note manually, but we could also have used a previously created release notes document if wanted to.</p>
<p>Now we come to the decision about what group we want this task to release to, so we will come back to App Center and go to the distribute tab and then groups. I previously deleted our user groups so we would have a clean environment to work with, which is why you do not see any groups from the previous demo.</p>
<p>Since we have no groups we will click the “Add group”, this brings up the configuration page, we simply name our group and add the email of any users we would like to add to our new Tester group. I will add my email address here. This will add me to the group and I will be notified when there is a new release. Now we just click create group, and we now have a new Testers group.</p>
<p>Now to be able to identify our group in Azure DevOps we need the group id. So we need to go back into our group settings by clicking on the wrench up in the top right corner and that will open our group configuration page again, and you will see in light grey an ID number. It’s a bit hard to see. We will copy it to the clipboard and head back to Azure DevOps.</p>
<p>When we are asked for a Distribution Id we just paste the id from the App Center there. Lastly, we change our symbols to Android, and that is all we need to do for this task. Click add and we see it on our YAML Page. We then click save, and then click run, and click run again. The pipeline will then go through all of our YAML tasks except for the commented out UI test task, when it’s done we should have an email letting us know there is a new release available.</p>
<p>We can also do this for the various app stores and the intune company portal. We won’t be able to go too far with deploying to the Google Play store or the Microsoft Intune company portal. However, you can find them under the Stores menu items here in App Center. For The Google Play store, you need to set up your build signing and the Google Play API to enable 3rd party deployments, and for the Intune company portal, your organization has to have the Enterprise Mobility and Security Suite from Microsoft and you also will need an account for Intune. For Apple, you need to set up your developer profile and production certificate. However, that is beyond the scope of this course.</p>
<p>If you need information on how you can do this you can find the information at the following URLs:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/distribution/stores/apple">https://docs.microsoft.com/en-us/appcenter/distribution/stores/apple</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/distribution/stores/googleplay">https://docs.microsoft.com/en-us/appcenter/distribution/stores/googleplay</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/mem/intune/fundamentals/what-is-intune">https://docs.microsoft.com/en-us/mem/intune/fundamentals/what-is-intune</a></p>
<p>So in this demonstration, we’ve learned how to create public and private distribution groups and where we can go to set up our connection to the various app stores. In the next module, we will take a look at <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/analytics-and-diagnostics/">Analytics and Diagnostics</a>.</p>
<h1 id="Analytics-and-Diagnostics"><a href="#Analytics-and-Diagnostics" class="headerlink" title="Analytics and Diagnostics"></a>Analytics and Diagnostics</h1><p>With all software application development, there will inevitably be errors and bugs, and mobile development is no different. However, bug reporting and understanding the application state on a device you don’t own can be much more difficult. Luckily, App Center has a few APIs that you can add to your application that allows you to gather analytical data and perform event and error logging to App Center itself.</p>
<p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">Mobile applications</a> differ in scale and architecture from your typical client-server or web application. These types of applications have central processing servers that you will have complete control over, and can write to event tracking systems and create your own log files. These files can be as large or as small as you’d like, and this gives you a lot of freedom to do whatever you need to do.</p>
<p>The same cannot be said for mobile applications. Mobile apps are more like off-the-shelf software packages installed on computers you don’t own. You can still create log files and do event reporting, but you don’t have ready access to these files or systems.</p>
<p>The limitations and restrictions for mobile applications is far stronger for a few reasons. The respective app stores have rules that must be followed, and so the data that you’re allowed to collect is restricted. Further, the storage space on mobile devices is at a premium so you can’t simply create large log files on these devices.</p>
<p>App Center solves both of these issues for mobile application development. When you distribute your mobile applications through the App Center, they are tracked and monitored. App Center Analytics will give you data on how many current installs are out in the wild. It can also tell the difference between unique installs and re-installs. It gives you statistics for daily usage, length of sessions, device specs, app version information, location, and language data. That’s a lotta great information without any extra work for the developers.</p>
<p>As a developer myself, I’ve seen many challenges in regards to error handling and logging. Everyone seems to have their own way of doing things, and every developer has his own favorite tools for performing these tasks. In my experience, error handling in a consistent manner across multiple development teams is challenging and anything but consistent. The event logging and error handling in App Center gives you a simple and concise set of APIs to accomplish these tasks, while at the same time allowing for a fair amount of flexibility in the data you can track.</p>
<p>In our next module, I’ll show you how to add the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-analytics-and-diagnostics/">App Center analytics and diagnostics</a> to your mobile application, and how to use some of the simple methods to get you started in event logging and error tracking to the log flow in App Center.</p>
<h1 id="DEMO-Analytics-and-Diagnostics"><a href="#DEMO-Analytics-and-Diagnostics" class="headerlink" title="DEMO: Analytics and Diagnostics"></a>DEMO: Analytics and Diagnostics</h1><p>In this demo, on <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/analytics-and-diagnostics/">App Center Analytics and Diagnostics</a>, I will show you the steps you need to take to enable App Center, to track your application and implement basic event logging and error handling using the App Centers APIs.</p>
<p>I’m gonna show you how to set up an Android Xamarin application. The process will differ depending on the operating system and platform you’re using to write your <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">mobile application</a>. You can find the steps to accomplish this task for each of the platforms on the main overview page for the app you wish to create.</p>
<p>I already have the application open and ready in visual studio. So let’s go and take a look. If you’d like to follow along, you can clone the mobile application from a GitHub repository at the following <a target="_blank" rel="noopener" href="https://github.com/kelsosharp/MobileDevOps">URL</a>.</p>
<p>We will be modifying the main activity CS file. This is the file I have open now. The first step we need to take is to add the App Center Analytics and Apps Center Crashes NuGet packages. Both of these are dependent on the App Center NuGet package, and it will be installed as a dependency of either of the two other packages.</p>
<p>So to install the NuGet packages, I’ll right-click on our main DevOps project and select manage NuGet packages. You can also select the tools menu and the manage NuGet packages and then manage NuGet packages for solutions option if you prefer. After the package manager window has loaded, I’ll click the browse and then type in microsoft.appcenter and filter the list of packages down. First I will install the App Center analytics package, and then I’ll install the App Center crashes package. During the install, it will ask you to accept the package license agreement, and we can go ahead and click okay.</p>
<p>Once the packages are installed, we can go back to the main activity class and add the three using statements for App Center, App Center analytics, and Apps Center crashes to the using statement area.</p>
<p>Now that we have a reference to the App Center packages, we will need to start the analytics process thread. We can do this by using the App Center start method. We will need to use the App Center secret that you have on the main overview page of your app, in the App Center, you add this as a string to the first parameter of the start method. The second and third parameters are passing in the system type declaration for the analytics and crash classes.</p>
<p>We can now run this application on a device emulator, and it will show up on the main analytics page in App Center. Obviously there’s not going to be a lot of useful data at this point, but I’m sure that you can imagine what this will look like with hundreds or even thousands of devices using your application.</p>
<p>The next thing we’re gonna do is log in event to the log flow area in App Center. To do that, we just call it track event method on the analytic static object and pass in a string that has the message we want to add to the event log. So I’ll just add the appcenter.track event call with the message letting us know that the main activity class has been executed.</p>
<p>I’m adding this code to the onCreate method of the main activity class. This will execute just before the main screen is loaded on the device. This is a good place to add the start method we added earlier. And as for the rest of the code snippets that we will add today, these can be added virtually anywhere you would add event logging or error handling normally in an application.</p>
<p>We will just quickly check out the Log Flow area in the Analytics section and make sure our event was passed in the App Center. And we can see there that it shows up in our logs.</p>
<p>Now we will add a bit of error handling. App Center diagnostics will report, both handled and unhandled exceptions and provide you with a stack trace of the crash. If you need more information, you can create a dictionary with a key value pair of type string and add additional data to send the App Center.</p>
<p>In order to generate an exception for this demonstration, the crash aesthetic object of the App Center NuGet package has a method called generate test crash. This takes no arguments, but we’ll throw an exception for you.</p>
<p>We’re gonna use this method within a try-catch block to add some additional data that we can send back to App Center using the crashes track error method. The benefit here is that we can use this to test error handling without actually crashing the application on the device. It becomes a handled error and the application carries on like nothing’s wrong. And the user is not aware that there’s even an issue.</p>
<p>It will take a few minutes to show up in the apps in our log flow area, but handled and unhandled exceptions will show up this log under the analytics tab.</p>
<p>Now on the diagnostics page, we can see that we had four crashes and they happen in the onCreate method of the main activity class. When we click on the error in the list, we can see more detailed information, things like the number of reports, percentage of users this issue is affecting, along with devices and operating systems affected. This is awesome information to have when we’re trying to narrow down the exact cause of a bug.</p>
<p>To get even more detailed information on our crashes. We can have a look at the report tab. We can find demographics on the device, and this is also where we can find the custom data that we passed to App Center when we caught our error.</p>
<p>Additionally, if we wanted to, if the property’s dictionary is not sufficient for our needs, when handling errors. For example, we’re using a log file to gather additional information from the device itself and need to send it to the App Center. We can do this as an attachment, which will then be made available for us here.</p>
<p>App Center has provided us with an easily accessible way to get errors and crash data in a very simple and straightforward manner. I’m sure as time goes on, more and more features will be added to App Center to improve our mobile DevOps strategies, and App Center will become an invaluable tool in our DevOps utility belt.</p>
<h1 id="Course-Conclusion"><a href="#Course-Conclusion" class="headerlink" title="Course Conclusion"></a>Course Conclusion</h1><p>In this <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/course-introduction/">course</a>, we’ve taken a deeper look at the Visual Studio App Center as the central means to implementing a mobile DevOps strategy. We were able to create many of the tasks that are needed to create a fully automated CI&#x2F;CD pipeline for our mobile applications. And doing so has helped us to create a complete mobile DevOps strategy.</p>
<p>In the modules on build services, we looked at the various build configuration options, such as build signing and versioning. And in the demo on build services, we configured and signed our build for deployment to our distribution groups and the Google Play Store.</p>
<p>In the modules on UI testing, we talked about and demonstrated how to add a test series and test runs. We were able to use the App Center CLI and <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> DevOps to kick off our test runs, allowing us to test our application on our actual physical devices.</p>
<p>In the module on distribution groups, we were able to set up both public and private groups and invite users to those groups. We created and performed releases to these groups and we were able to automate builds from specific group branches to release our application to these groups.</p>
<p>We were able to use the App Center Distribute Task in the <a target="_blank" rel="noopener" href="https://cloudacademy.com/learning-paths/az-400-exam-prep-microsoft-azure-devops-solutions-1-1368/">Azure DevOps</a> pipeline to distribute our application to one of our distribution groups. This, combined with the App Center test task, resulted in a complete CI&#x2F;CD implementation for our mobile application.</p>
<p>In the module on <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/adding-mobile-devices-to-your-azure-devops-strategy-1047/demo-analytics-and-diagnostics/">analytics and diagnostics</a>, we talked about and implemented some basic logging and error handling, and we were able to send this data to the App Center. We were also able to track crash reports and learn that we can send additional error data to the App Center in the form of a list of key value pairs or file attachments. All of these options are available to give us a better understanding of the usage and issues in our application.</p>
<p>Mobile application development can be challenging and costly, but it doesn’t have to be. The App Center provides us with a simple way to implement a mobile DevOps strategy by giving us simple, effective tools to create a completely automated CI&#x2F;CD process. Not only that, it allows us to integrate with Azure DevOps. By combining these two service offerings, we get a much more powerful and flexible toolbox with which to create and customize our mobile DevOps strategies and automation processes.</p>
<h1 id="1Course-Introduction"><a href="#1Course-Introduction" class="headerlink" title="1Course Introduction"></a>1<strong>Course Introduction</strong></h1><p><a target="_blank" rel="noopener" href="https://cloudacademy.com/course/implementing-and-managing-azure-build-infrastructure/course-introduction/">Course: Implementing and Managing Azure Build Infrastructure</a></p>
<h1 id="2Mobile-Build-Services"><a href="#2Mobile-Build-Services" class="headerlink" title="2Mobile Build Services"></a>2<strong>Mobile Build Services</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/build/software">List of software</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted?view=azure-devops#software">VM and installed software info</a></p>
<h1 id="3DEMO-App-Center-Build-Services"><a href="#3DEMO-App-Center-Build-Services" class="headerlink" title="3DEMO: App Center Build Services"></a>3<strong>DEMO: App Center Build Services</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/kelsosharp/MobileDevOps">Clone mobile application</a></p>
<h1 id="4UI-Testing-in-App-Center"><a href="#4UI-Testing-in-App-Center" class="headerlink" title="4UI Testing in App Center"></a>4<strong>UI Testing in App Center</strong></h1><p><a target="_blank" rel="noopener" href="https://openapi.appcenter.ms/#/test">App Center API</a></p>
<h1 id="5DEMO-App-Center-CLI-UI-Testing"><a href="#5DEMO-App-Center-CLI-UI-Testing" class="headerlink" title="5DEMO: App Center CLI UI Testing"></a>5<strong>DEMO: App Center CLI UI Testing</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/test-cloud/devices">List of devices available</a></p>
<h1 id="6DEMO-App-Center-Azure-DevOps-Integration"><a href="#6DEMO-App-Center-Azure-DevOps-Integration" class="headerlink" title="6DEMO: App Center Azure DevOps Integration"></a>6<strong>DEMO: App Center Azure DevOps Integration</strong></h1><p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/publish/app-signing.html">How to sign your Android builds</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema,parameter-schema">YAML and Azure DevOps schema</a></p>
<h1 id="8DEMO-Distribution-Groups"><a href="#8DEMO-Distribution-Groups" class="headerlink" title="8DEMO: Distribution Groups"></a>8<strong>DEMO: Distribution Groups</strong></h1><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/distribution/stores/apple">Apple setup</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/appcenter/distribution/stores/googleplay">Google Play setup</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/mem/intune/fundamentals/what-is-intune">Microsoft Intune setup</a></p>
<h1 id="10DEMO-Analytics-and-Diagnostics"><a href="#10DEMO-Analytics-and-Diagnostics" class="headerlink" title="10DEMO: Analytics and Diagnostics"></a>10<strong>DEMO: Analytics and Diagnostics</strong></h1><p><a target="_blank" rel="noopener" href="https://github.com/kelsosharp/MobileDevOps">Clone mobile app GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kelsosharp/MobileDevOps">Clone mobile app GitHub</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Azure-Key-Vault-and-Disk-Encryption-6/" rel="prev" title="AZ-400-Azure-Key-Vault-and-Disk-Encryption-6">
      <i class="fa fa-chevron-left"></i> AZ-400-Azure-Key-Vault-and-Disk-Encryption-6
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/18/AZ-400-Managing-Application-Configuration-and-Secrets-in-Azure-8/" rel="next" title="AZ-400-Managing-Application-Configuration-and-Secrets-in-Azure-8">
      AZ-400-Managing-Application-Configuration-and-Secrets-in-Azure-8 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Introduction"><span class="nav-number">1.</span> <span class="nav-text">Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mobile-Build-Services"><span class="nav-number">2.</span> <span class="nav-text">Mobile Build Services</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-App-Center-Build-Services"><span class="nav-number">3.</span> <span class="nav-text">DEMO: App Center Build Services</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UI-Testing-in-App-Center"><span class="nav-number">4.</span> <span class="nav-text">UI Testing in App Center</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-App-Center-CLI-UI-Testing"><span class="nav-number">5.</span> <span class="nav-text">DEMO: App Center CLI UI Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-App-Center-Azure-DevOps-Integration"><span class="nav-number">6.</span> <span class="nav-text">DEMO: App Center Azure DevOps Integration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Distribution-Groups"><span class="nav-number">7.</span> <span class="nav-text">Distribution Groups</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Distribution-Groups"><span class="nav-number">8.</span> <span class="nav-text">DEMO: Distribution Groups</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Analytics-and-Diagnostics"><span class="nav-number">9.</span> <span class="nav-text">Analytics and Diagnostics</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DEMO-Analytics-and-Diagnostics"><span class="nav-number">10.</span> <span class="nav-text">DEMO: Analytics and Diagnostics</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Course-Conclusion"><span class="nav-number">11.</span> <span class="nav-text">Course Conclusion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1Course-Introduction"><span class="nav-number">12.</span> <span class="nav-text">1Course Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2Mobile-Build-Services"><span class="nav-number">13.</span> <span class="nav-text">2Mobile Build Services</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3DEMO-App-Center-Build-Services"><span class="nav-number">14.</span> <span class="nav-text">3DEMO: App Center Build Services</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4UI-Testing-in-App-Center"><span class="nav-number">15.</span> <span class="nav-text">4UI Testing in App Center</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5DEMO-App-Center-CLI-UI-Testing"><span class="nav-number">16.</span> <span class="nav-text">5DEMO: App Center CLI UI Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6DEMO-App-Center-Azure-DevOps-Integration"><span class="nav-number">17.</span> <span class="nav-text">6DEMO: App Center Azure DevOps Integration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8DEMO-Distribution-Groups"><span class="nav-number">18.</span> <span class="nav-text">8DEMO: Distribution Groups</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10DEMO-Analytics-and-Diagnostics"><span class="nav-number">19.</span> <span class="nav-text">10DEMO: Analytics and Diagnostics</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
