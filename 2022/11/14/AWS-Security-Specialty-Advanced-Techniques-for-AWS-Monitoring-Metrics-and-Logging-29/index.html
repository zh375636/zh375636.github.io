<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to CloudAcademy.com’s Advanced AWS Monitoring Metrics and Logging course. This course is intended for DevOps engineers that want to get the most out of monitoring metrics and log">
<meta property="og:type" content="article">
<meta property="og:title" content="AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring,-Metrics-and-Logging-29">
<meta property="og:url" content="https://example.com/2022/11/14/AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring-Metrics-and-Logging-29/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to CloudAcademy.com’s Advanced AWS Monitoring Metrics and Logging course. This course is intended for DevOps engineers that want to get the most out of monitoring metrics and log">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-14T17:52:30.000Z">
<meta property="article:modified_time" content="2022-11-20T02:54:26.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/14/AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring-Metrics-and-Logging-29/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring,-Metrics-and-Logging-29 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring-Metrics-and-Logging-29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring,-Metrics-and-Logging-29
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-14 13:52:30" itemprop="dateCreated datePublished" datetime="2022-11-14T13:52:30-04:00">2022-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-19 22:54:26" itemprop="dateModified" datetime="2022-11-19T22:54:26-04:00">2022-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS-Security-Specialty/" itemprop="url" rel="index"><span itemprop="name">AWS-Security-Specialty</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring-Metrics-and-Logging-29/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AWS-Security-Specialty-Advanced-Techniques-for-AWS-Monitoring-Metrics-and-Logging-29/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to CloudAcademy.com’s Advanced AWS Monitoring Metrics and Logging course. This course is intended for DevOps engineers that want to get the most out of monitoring metrics and logging and, in general, keeping track of the state of their cloud.</p>
<p>So in this lecture, we’ll be going through an introduction of the course, which will include a definition of the three terms that make up the title of the course. We’ll also go over the intent of the course and what you’re trying to learn while watching this video series. We’ll go over the scope of the content, so everything that’ll be covered beyond just the intent of what you should learn, the benefits of advanced systems running for monitoring metrics and logging on AWS, the different lectures in the course that you should expect to see, and then a brief summary of the intent of the course in a final mission statement.</p>
<p>So without further ado, let’s get into it. So first, let’s define the term “monitoring”. When we think of monitoring, we should be thinking of how we can observe and check the progress or quality of something over a period of time, and keep it under a systematic review. Now in Amazon Web Services, this means verification that your cloud works, and I’ve included icons for three of the main services that people should be familiar with for doing this. You may not have used all of them before, but you’ll become more familiar with them over this course as we talk about how we might do these things.</p>
<p>That’s the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/amazon-route53-dns/dns-private-hosted-zones-virtual-private-cloud-1/">Route 53</a> icon in the top-left there. We can use Route 53 health checks, where we ping a certain DNS endpoint and do a holistic check to make sure that we get a 200 error code, or just a general heartbeat or response back.</p>
<p>That’s the CloudWatch icon up there in the top-right, which can include CloudWatch Events, Metrics, and Logs, and as well as Alarms.</p>
<p>Then, we have the ELB icon there. There are ELB health checks for when we’re thinking about doing auto-scaling, and making sure that individual instances behind a load balancer are healthy.</p>
<p>So we should also look at metrics. When we think about defining metrics, we have a standard or a system of measurement. So in AWS, this means quantifying cloud behavior and state. So standard or system of measurement here means that we have a specific thing that we’re measuring whenever we think about a metric. It’s a little bit different than monitoring, where we are more looking for a binary “is it online or not” over a course of time. Whereas, a metric we’re looking to quantify something using CloudWatch, which is that icon there. So quantifying our cloud behavior and state could include things like reading the amount of traffic that comes across EC2 instances or an Elastic Load Balancer, reading the amount of provisioned throughput or consumed throughput for DynamoDB tables. Any number of things that we can put numbers to and are nicely graphed over time, that’s what you should be thinking about for metrics.</p>
<p>So we also use metrics as input for determining CloudWatch Alarms, which is that icon in the bottom-right there, where that red presumably would be a threshold that I cross. That’s one of the reasons that I would be using metrics, is to see whenever I cross certain thresholds and create certain behaviors.</p>
<p>So moving on to logging, this one might surprise people, recording of performance events or day-to-day activities. So in Amazon Web Services, this means a time sequence of system occurrences, which is very generic. It’s not like you might think, where most people coming from a non-cloud background or from a cloud that doesn’t have sophisticated value-added services tools to help us manage our logging, might think of logging as dumping out files that represent things that happened during your application code. Which, that’s a useful abstraction for maybe a single desktop computer, but it’s extremely difficult to handle something like that when thinking of log files as just individual files. Not just logging in general, log events, performance events, or day-to-day activities. It’s very difficult to manage that level of complexity in the cloud, so that’s why you’re watching this course.</p>
<p>So intent of this course is enable actionable understanding of your cloud, which is a very generic statement. But what that means is that we go from thinking about logs as afterthoughts, or things that we might use for debugging whenever things go wrong, and move forward towards this after, where monitoring metrics and logging is a first-class design task that delivers massive business value. So what does that mean? Well, it means that when we implement correctly monitoring metrics and logging, as a DevOps engineer, one of the primary things that you should be praised for is the level of sophistication for your monitoring metrics and logging system. By making it a very easy system to extract value from, answer questions about the operational metrics of a system, and ensure high availability, ensure good software delivery practices. So monitoring metrics and logging is very important, and as we move towards this value-added thinking around monitoring metrics and logging, rather than afterthoughts, we’ll be better DevOps engineers.</p>
<p>So the scope of our content is that we fundamentally rethink the log. So as we eluded to earlier when we defined the log, we need to in this course fundamentally rethink the log away from a set of files, maybe, that you might run on your virtual machine or bare metal if you’re coming from a data center that you actually have.</p>
<p>We have to think about logs and metrics, and how they offer value. So one of the statements that I made on an earlier slide was that we are going to turn these things that are typically afterthoughts into value-added systems. So we have to cover how we can do something like that and extract that value. So we’ll learn the skills to extract the insight from the logs. When I talk about value, typically the type of value that we’re thinking of when we talk about using logs to get values insight, so we have three levels of completeness of information or data. So we have data, which is just that might be individual lines in your log. We have information, which is a slightly higher level of abstraction where I can speak an English sentence and explain what the data means. Then, insight, which is where I take away some critical thing that I didn’t know before, or I’ve learned something new from that kind of information or data. So we want to be able to use logs to extract new insights that we’ve never thought of or seen before, and deliver value that way.</p>
<p>So we want to learn practical methods for handling logs. If we’re going to be messing with all these logs and these metrics, which are really kind of just a subset of logs, then we need practical methods for handling these things and handling complexity. Because as you know in a highly dynamic cloud environment where we’ve got lots of distribution and lots of moving parts, sometimes the challenge can just be managing complexity.</p>
<p>We’ll design some automation around log event streams. So you should know ways, in addition to having human eyes derive insight from logs, the insight that you can receive from logs if they’re structured can also derive automation. So we’ll get into that a little bit later. But there are a number of places where you can read or sift through logs, and depending on what you see, do automation actions. So we’re going to get logging superpowers, effectively.</p>
<p>Monitoring and metrics are also in the title of the course. But I like to think about those as subsets of logging in general, which is the more generic thing where monitoring is a little bit more binary in the context of the cloud, where we’re monitoring for uptime. Metrics are a little bit more oriented towards quantitative goals.</p>
<p>So what are the benefits of some of the advanced systems that we’ll be building? Advanced logging helps manage systems in a number of different ways. Logging techniques should scale the business. We should yield immediately the convenient insights that we were talking about earlier, and we will reduce the ongoing DevOps effort of managing our cloud.</p>
<p>Finally, when we look at the lectures in our course, we have events everywhere handling distribution, try the ELK stack and ChatOps with Slack. So what that gets us is events everywhere. We’ll be talking about how to rethink the log in general, that it’s changing our brain around the paradigm shift that is going from thinking about logs as a file-oriented system into this events-driven system. Handling distribution we’ll get into a little bit around the nature of the systems that we’ll use to manage the complexity around delivering these insights and this additional value from logging systems. Try the ELK stack will be a show-and-tell, where I walk through a very, very common, the most common actually, logging extraction and insight extraction tool on Amazon. The ELK stack is now offered as a service from Amazon, and ChatOps with Slack. So ChatOps eludes to when you present automation with your system. Where if system events occur, rather than emailing you or phone-calling you, since most people spend a lot of their time in chat and chats are effectively an event stream as well, we can insert log notices into our chat system. I’ve picked Slack, which is an enterprise chat system that got really popular in 2014 and 2015, where we can do easy API-driven development to insert insight into our group chats.</p>
<p>So when we think about doing these different lectures, we should be thinking about all of these different graphs and insights that we might be deriving. We will mostly see some of these in the ELK stack, but start thinking about your logs as a tool to derive insight and do analytics, which is what we have all these graphs on here on the side.</p>
<p>So in summary, this course will teach you how to extract value from observing your AWS systems. It’s very generic-speaking, but effectively it means we first rethink the way that we are handling logs in general, and start packaging them and utilizing them in a different way. Then, design appropriate technical systems to handle the new format of the logs that we’re going to deal with in the best way possible, and make them usable and consumable by other systems as best possible, and usable and consumable by both technical and sometimes even nontechnical users. Then, we’ll go over some practical examples for how we can actually utilize these things so you can envision implementing these in your own systems or your own company.</p>
<p>So next up, we’ll be doing <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/events-everywhere/">Events Everywhere</a>, which is the video course that’ll teach us how to rethink how we do log systems.</p>
<h1 id="Events-Everywhere"><a href="#Events-Everywhere" class="headerlink" title="Events Everywhere"></a>Events Everywhere</h1><p>Welcome back to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/introduction-27/">Advanced AWS Monitoring Metrics and Logging</a> on CloudAcademy.com. In this lecture, we’ll be talking about how events are everywhere and how this relates to logging.</p>
<p>First of all, monitoring metrics and logging, they’re all events. We’ll talk about how we can use metrics and how they’re slightly different than normal logs. We can talk about how logging is everything and the value that it holds. We’ll go over event sources and consumers, so different things that are creating events and different things that are reading or seeing these events come across and acting on them, and how streams solve a lot of the problems associated with managing these logs. Finally, after going through all of the logic in the previous slides, we’ll talk about why we’re saying “death to the log file” as we eluded to in the introduction lecture.</p>
<p>So again, events are everywhere. Monitoring metrics and logging, they’re all events. So let that sink in for a moment. Events are, “Hello. Boom. Something happened. Event.” Monitoring is a typically binary, “Oh, holistic check. Is my system online?” This can be a DNS ping or HTTP check or something. Metrics are typically a quantifiable, time-sequenced thing, so metrics of usage, metrics of traffic, metrics of throughput. Logging is a little bit more generic and is the parent category to both of these, in that it can be unstructured or structured. So every health check, metrics collection ping, line of log content is an event, or a thing that happened.</p>
<p>You can imagine that there can be a timestamp associated with all three categories of these things, so we just think about it as recording an event or a thing that happened. Like normal analytics, what happens has value, so there’s a logical jump here. If we think about what most businesses, or at least small businesses or companies that haven’t undergone technology modernization efforts, most businesses think only about analytics from a marketing or even a physical operations perspective perhaps on a factory floor.</p>
<p>These business analysis, business intelligence, business analytics tools, these are a sophisticated ecosystem, but we’re just seeing log analytics catch on. So if we think about events as different things that occur and we have analytics over events in the marketing space, we should also be able to do analytics over the logging space when we have log events.</p>
<p>When we think about metrics, we should think about this kind of graph where they’re entirely quantitative and our metrics are best used for time-series algorithms and reaction. Because metrics are inherently quantified already, they have some sort of number associated with them, the metric that we like to think about, we can make decisions based on what we see.</p>
<p>So here we actually look at a DynamoDB consumed write capacity units throughput table, and this is a metric in the CloudWatch Console. This metric tells me that I just consumed about a quarter of a million requests in five minutes after a period of essentially no requests overtime. So metrics are useful because they let you do things like detect when something like that happens. Where I go from almost no requests coming across my system or making writes to my DynamoDB table, and suddenly one minute there was 0.25 million requests, and the previous 5-minute period there was over 200,000 requests. We want to be able to figure out when these kind of spikes happen, and we do that using metrics in the CloudWatch Metrics Console.</p>
<p>So logging is everything. Logging, the more generic field of things that we’re talking about, where metrics are technically just log events with a well-quantified field to them. They still have timestamps. So business logic is loggable and maybe quantifiable, the quantifiable part being the metrics, and we can think about logs as append-only series of events in a flexible semi-or-unstructured format that can be quantified. That’s a little bit of a doozy of a sentence to think about. But append-only, meaning, if you think about a log file, when you concatenate to the end of the log file you append to each new line that you come out with. Log files are just a file representation of a stream, like we’re looking at here in the bottom-right. So we have an ordering where the top or left, it depends on the orientation of your log, in a file it’d be the top of the file, is the oldest event. The next record that you write to the log will always be guaranteed to be the newest record at the time. It’s also append-only is very important here, when we think about it. We’re not modifying 0 through 11 in that log event right there in the bottom-right. We are creating number 12, and that append-only property is very useful to us, as we’ll see a little bit later here.</p>
<p>They’re also best served with structure. That’s my little joke there. I have a small JSON object that I’ve typed into a text editor. But what this tells us is that a metric is actually one of the more structured log types. It has an associated quantified piece to it. But all logs should be served with structure and consistent fields. So rather than just logging or printing text out to the console whenever you’re trying to do your debugging, it’s more helpful if you return the kind of error or the nature of the error, or any kind of details or parameters that were provided to a method when you log out an error.</p>
<p>When we think about logging, we should be thinking about how to move from free text, or unstructured format, to more structured formats since that’s what computers and people will be able to do analysis over.</p>
<p>Note that I don’t mention the storage medium here, that stream on the bottom-right there. It doesn’t say that it’s stored to disk, that log sequence. It doesn’t say that it’s stored to disk. It doesn’t say that it’s in a database. It doesn’t say that it’s in memory. It doesn’t really matter, because logs can be transported or represented in a number of different ways. So don’t think about files when you think about logs. Think about these sequences of events that may or may not have quantitative properties on them and should be structured if you’re doing things correctly.</p>
<p>Talking about event sources and consumer, first of all, data availability is good. This is an age-old mantra of anybody that’s ever done business intelligence or analytics from a data warehousing or data-like perspective that generally making more data available to more different parties is a good thing. Because we get better insights, better integration, and more actionable insights as we diversify the way that we can consume these things.</p>
<p>Metrics and log events are data. Right? So particularly if we think about from the previous slide, where I had a “Best”: “Served” “With”: “Structure” JSON object, if my logs are in JSON format there are very sophisticated and well-built out tools to help us do analysis over things like JSON objects. Because they’re effectively a serialized representation of objects in memory, once we have our logs into JSON or some representation like that, then we can use them as first-class citizens or primary data sources.</p>
<p>So events are good, because we’re saying if data availability and having more data about our business that’s relevant is clean, if that kind of data availability is good and metrics and log events are data, then we should be looking towards our metrics and log event data as good, or sources of value for the business.</p>
<p>One example where somebody created an actionable system that actually delivers value just using logs, this is a metric. Which in my mind, it’s a subset of the log and that’s how you should think about it as well. Auto Scaling actually uses this method. So if we look at, we have an Auto Scaling group here on the left, we have a group of instances. If all of these instances are publishing metrics, which they are, to Amazon CloudWatch and we have a thresholding algorithm on them, which are our CloudWatch alarms. If you’ve ever done an Auto Scaling threshold alarm, that’s one in the same. Then, we have logic that once we emit to the alarm and say, “Oh, I flagged a specific pattern in the log data, and I’ve come up with some analysis and some actionable thing that I need to do based on what I’ve seen,” then we trigger the Auto Scaling and command something like an auto scaling system to scale up and down. So this is actually effectively how you would accomplish auto-scaling.</p>
<p>Beyond AWS, you know Amazon is very sophisticated and they have a very straightforward infrastructure¬-driven requirement to use a form of log to deliver value, we can also think about delivering value via a normal SaaS company by using log data to make self-managing systems. So let’s trace through the user journey here. In the bottom-left we have a user or an end user, customer. The user can be a human being in the case of a web application, or it could be another software system in the case of more of a systems-oriented or a service-oriented architecture. They interact with your service, which I’ve represented as a collection of EC2 instances here, but it could be any number of complex things or stacks.</p>
<p>We produce business logs from the different components of our service, and we emit them over to CloudWatch Logs. We can pick them up from CloudWatch Logs using Amazon Elasticsearch Service, or ELK, which we’ll get into a little bit later in the course. Based on thresholds coming out of that system, we can create custom alarms, notify an SNS topic, and have different actions be taken based on that SNS topic. We can write the SNS topic into a support database using a Lambda perhaps, or another system watching for this, and have customer support read out of a support database. We can page engineers based on different things that we see come out of the logs. We can also, if we have sophisticated enough logs that provide us with enough information, sometimes perform actions that solve the problem completely autonomously, which would be a healing Lambda automaton. It could also be EC2 instances as well. But we can implement self-healing logic if we have business logic logs that can flag things like increased error rates, or something like that.</p>
<p>So beyond just metrics that you’re thinking about for throughput, we can also do more sophisticated logic like detecting patterns in the actual text or enumerated inputs inside of business logs, and create fairly simply, even though there’s a lot of boxes and arrows here. There’s lots of different value-added services that Amazon provides to us, such that we can string together one of these self-managing SaaS systems without creating our own instances or software simply by stringing together a couple different Amazon Web Services managed services.</p>
<p>So we have a complexity management problem already, just looking at that other slide over there. We think about strings as time-sequenced event buffers. We already talked about streams, and we already talked about events. Events are these different things that pop up in our logs, or they’re the individual things that happen. Streams are entire sequences of these events. Streams also work as buffers, because if we have a stream that is the data intermediary to carry between two systems that might want to share log data, the streams will allow us to do a number of different things. They’ll allow us to natively support log event style, so that one’s clear. If we think about logs as a sequence of events and streams are simply time sequences of events, then this is a natural thing to want to start streaming our logs.</p>
<p>We also get a unified transport to other services from a stream. So if we think about what Kinesis is primarily used for, if you’re familiar with the rest of the Amazon platform, it’s primarily used for moving data in the correct order from one place to another. If we think about firehoses, if you’ve ever heard of that before, data firehoses, those are just streams as well. The firehose typically just means the velocity with which they come through. Then, three and four, they allow different consumption and production rates. If we think about if we have a system that is creating things, events very quickly or in a burst-y matter, and then another system that slowly DQs things in a constant rate, we can use a stream to buffer between those two systems as we have the spiky production and consistent consumption. Or even the other way around, where we might have constant addition to the stream, and then a spiky read off of the stream to do analysis and perhaps a spark, or write to a database.</p>
<p>It also allows us to decouple producer and consumer systems. So rather than having to keep a registry of all of the DNS addresses of all other micro-services in a complex system, we could have our log systems simply write to a stream that never changes location or DNS address. Write to that stream, and not concern itself with the consumers that are picking these things up.</p>
<p>We could also potentially have multiple producers writing to the same stream, and multiple consumers reading off of the same stream. So we can have a many-to-many relationship in which the producer only has to be aware of one thing, where the stream is, and the consumer only has to be aware of one thing. Even if we had 10 producers and 10 consumers all producing to and reading from the same stream, the only thing that any of those services need to be aware of is the stream location, so we have a nice decoupling there.</p>
<p>Streams are great, and we talked about why they’re great. We need to realize that logs aren’t just files that you open and scan when something breaks. They’re a primary data transport mechanism, that is we can put the data that come out of our log streams and do a number of different things on them, even replicate databases. They’re a primary first-class citizen for data, and log events are fundamental design building blocks.</p>
<p>So if we looked at my self-healing system, the primary thing that it was operating over were logs. All of my business logic was centered around the log, and even in Auto Scaling the primary thing that Auto Scaling does is use the design of the log system as the fundamental building block. It just reads out of this log stream, these time-sequenced events of load, and then make decisions for when to scale out. Hopefully, you’ve learned a thing or two about why streams and events are everywhere in a logging problem. Next up, we’ll be talking about how to <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/handling-distribution/">handle distribution</a>, that is how to handle the distributed nature of log producers and log consumers, and in general how to write a distributed system that handles logs in the cloud.</p>
<h1 id="Handling-Distribution"><a href="#Handling-Distribution" class="headerlink" title="Handling Distribution"></a>Handling Distribution</h1><p>Welcome back to Advanced <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/introduction-27/">Amazon Web Services Monitoring Metrics and Logging</a> on CloudAcademy.com. In this lecture, we’ll be talking about how we handle distribution and the distributed nature of stacks that we need to log and monitor.</p>
<p>First, we’ll talk about how we need to stream everything to make this goal of handling distributed event sources work correctly. We need to understand the log group structure. We need to talk about how we perform unification and distribution of our streams and log events into multiple consumers. We need to talk about different kinds of stream syncs that we can use when we’re talking about creating our log streams and how they can be useful to syncing data or transactions into individual syncs. We’ll talk a little bit about how you might perform an archival and backup solution, so how we might achieve logically the long-term auditability requirements that you may have rather than using the logs as an in-flight or real-time log streaming. And then we’ll talk briefly about aggregation with the ELK stack and how that is logically achieved.</p>
<p>So, we’re talking about handling distribution. We are talking about how we want to stream it all. So when we’re talking about streaming in an Amazon Web Services cloud, now we say we need to stream it all and that’s because streams are helpful transport mechanism as we learned in the other lesson. But when we’re thinking about streaming logs specifically in Amazon Web Services, we should be thinking of Kinesis CloudWatch Log Streams and how they are your friend and we’re going to use them copiously as we set up these logging systems.</p>
<p>So first of all, we need to log everything, truly everything to CloudWatch Logs first and use this as a source of truth. So it’s a common temptation to log to disk because it’s easy and convenient and it’s nice and easy or log to standard out even. If we’re logging to standard out, we should be using a CloudWatch Logs daemon to take each of the lines that we’re logging to standard out and pick them up and emit them to CloudWatch Logs which Amazon provides a tool that lets us reroute anything that’s sent to standard out or to disk to CloudWatch Logs which runs as a daemon on Amazon Linux, Ubuntu, or their CentOS distributions. So, rather than just using a plain file, we should be thinking about using a daemon like that and submitting to CloudWatch Logs first. And if we’re using anything like a Lambda or something, we will natively support that CloudWatch Logs.</p>
<p>So all processing should be done stream with CloudWatch. This is an important notion that the top of our log stream funnel should be starting with CloudWatch just because in Amazon we have the ability to do long-term retention if we’re streaming into CloudWatch. But we also have the ability to read off of it like an inflight stream that might be more transient or temporary. So you get the best of both worlds when we’re thinking about using CloudWatch Logs because we can get long-term persistence as well as event ordering and event buffering through the streaming behavior.</p>
<p>So, when we’re thinking about how logs work and we’re CloudWatch and how log model works, this actually works the same model, this diagram that we’re looking at. This is actually how Apache Kafka works and CloudWatch is in some ways similar to Kafka in that it has similar partitioning and such. So let’s take a look.</p>
<p>So we have… CloudWatch as a service encompasses this entire diagram. But these two inner rectangular shapes that we have, we see one log group and another log group on the left and right here. Log groups are the logical grouping of our logs. So, Amazon Lambda already creates log groups based on the Lambda name and names spaces them under the AWS Lambda. You can also create log groups by putting a log group when you’re running an easy two instance if you name the group along the same vein. So for instance, I might decide to use one singular log group for each process that I might be running inside of an auto-scaling group. So if I’m running two processes at a time, two primary processes at a time on each instance in an auto-scaling group, I might use two log groups, two log groups that are used from each system.</p>
<p>So, log groups are great but they’re not the unit that you read from. They’re just the logical unit of abstraction. When we’re thinking about actually pulling data off in those time sequenced recordings like we were talking about in the other lecture, only the log streams which are belonging to these log groups are guaranteed to be in order. So there’s no absolute ordering of events inside of a log group at all. There is absolute ordering inside of a log stream. So, that’s a key distinction because we might have multiple parallel streams being produced at the same time but not have any way to globally order them if we don’t create a system on top of it. So, if you think about CloudWatch Logs and the model that we have, we have there are many CloudWatch has many log groups. Log group has many streams. Stream has many events. And inside of each stream, the events are guaranteed to be in order as you can see here.</p>
<p>So, when we’re thinking about having these multiple logical streams, it’s important to remember that if we’re trying to configure a useful streaming application for logs where there may be systems that need to consume multiple streams or there may be systems that need to consume streams in a different format, than they’re used otherwise, then we have these two different operations that we can perform which are our primary method of working with log streaming system design. So, on the left here, we have unification where we have the capability to unify two streams into a single stream and publish them to a consumer who may be considered, who may be concerned with the correctly global ordered streams, that is stream C, that is the unification or interleaving of A and B. We may be not concerned with the global ordering. We might just be concerned with the mixing two topics together. So those could be API and database logs. This is actually how you might merge two streams within a log group into stream C. So presumably, we could imagine if we stream into Kinesis from two different streams inside of the same log group, then that stream C there might be the Kinesis or the unified log which represents the merged events from all streams inside of a group. And if we have a consumer that is interested in reading all events from that entire group, then consumer A will be happy with stream C.</p>
<p>We also have this ability to do a transformation with a map or a filter or both at the same time, filter map or a map filter. So, if we see we have this stream before and we run through some sort of logical process and emit into a stream after. In Amazon, this is typically achieved by reading out of a Kinesis Stream running a funk door on a Lambda on shards of the events coming out, shards being a frame of multiple events coming out at once as we optimize for network throughput. So for instance we wouldn’t want to, if we’re streaming a million records every hour, we wouldn’t necessarily want to read out of the stream one record at a time. We might want to chunk 10 at a time, that would be a shard.</p>
<p>So these map or filter operations here, we can submit or we can have a Lambda read out of the upstream stream, execute some sort of mapping or filtering logic and put it into a second stream. When we combine these two methods, this unification and this distribution through a map or filter, this transformation, we combine these two and realize that we can chain them together. We can design systems of arbitrary complexity because we can also have multiple consumers per stream, right? So key concepts, merge and alter.</p>
<p>But there’s this third concept where we have stream syncs and we can sync the output of a stream into multiple different places here rather than showing a fanout of any streaming, typically fanout happens where have an end consumer rather than fanning out into two individual streams. So if you see here, potentially, this is an example that we could use where we have an application database that’s receiving application-style reads and writes in a transaction log. Now that transaction log, we can actually use a stream as our transport mechanism. So the transaction log only needs to be aware of the stream location. So, app database only knows where to submit its stream. And then our ElasticSearch, Free-Text search, our Hadoop, Ad-hoc analytics, our Redshift for analysis and business intelligence SQL, our S3 and then subsequently Glacier backup, our replica application database even since the transaction log represents a changed stream that we can use to recreate a replica or anything else, we only need to know where the transaction log and that where is that data that we’re curious about exists. We actually don’t need to know where the application database lives. That way if we have any of the databases go down either upstream or downstream, the only piece that needs to have a consistent address that needs to be addressed is that transaction log.</p>
<p>So log streams are great for replication if we see the app database versus the replica app database. The log is actually the ideal method for replicating any kind of state across two different databases simply because that time ordered sequence of events, if you replay it on the other database, you get an exact copy and you can also use the transaction to recreate the secondary database at any point in time since you can only partially play forward if you want if you restore the database.</p>
<p>So, common question is if we’re not looking at logs as files anymore, that we go and peruse through when we need to do some sort of lookup in the past to see what went wrong, how do we do archival backup and auditability when we’re talking about this brave new world of log events and streaming? Well, rather than just looking up files and doing direct S3, simply look at the S3 objects as another sync. So, again, we can have our database creating a transaction log stream, maybe publishing to Kinesis, and we can have a Lambda reading off of Kinesis and writing an S3 object for each shard. So we have logs that are divided by time and we have many objects over time. We can also then still have the other consumers read from the same transaction log stream. So the archival and auditability actually is no longer a special case at all. It’s a primary case where it’s just another sync. It’s just another reader off of the same stream.</p>
<p>Once we write into the S3 objects, we could set life cycle rules on the S3 bucket object and you can go and look up the documentation in Amazon Web Services if you so choose. But a life cycle rule effectively tells S3 to change the storage class of data after a certain amount of time. Storage class changes can include altering to this AWS Glacier which is storage on magnetic tape which is at the time of this recording of this video it’s seven-tenths of a cent in US dollars in the primary regions, the US East and US West versus three cents for the S3 storage. So it’s four times cheaper to store in Glacier, so we might imagine that after a certain period of time, it would be advantageous for us to simply life cycle rule into Glacier.</p>
<p>But the important piece here is that the S3 object writing is the part that finishes dealing with the streams and then we batch after that. That portion there is not a special case anymore in this archival and backup in auditability when you’re using streams. It’s just another consumer. So, it’s a very clean design and consistent. If you really want files, you should do it this way.</p>
<p>So, if you think about how we do event sources and consumers, we can also realize that we can make the ELK stack another consumer. So the ELK stack stands for Elasticsearch, Logstash, and Kibana. Now Elasticsearch is a free text search database and arbitrary query analysis, noSQL engine. It’s typically used for free text search which lends itself really well to doing kind of lookups or forensic work on your cloud system because you can do a free text search for the error message or a reference code or something and see every time that a reference code or error messages appear in the entire history of your log stream, so E is great in ELK.</p>
<p>L stands for Logstash and it’s our indexing mechanism. It is the way that data is flumed into Elasticsearch typically. Since that part is pretty much abstracted away by CloudWatch Logs and Lambda, we don’t really think about that too much when we’re rolling our own ELK stack solution on AWS but that’s what the L stands for.</p>
<p>K is Kibana. So the E in ELK for that search engine in Elasticsearch service, that’s just an API-driven database that speaks JSON as its wire protocol and it uses HTTP. The K there stands for Kibana. Kibana is a system that uses, it’s just a graphical interface and an indexing system and some prebuilt logic and prebuilt indexes logics on the cluster. So it runs on the Elasticsearch cluster itself and it’s a GUI that lets you do things like create graphs, do log analysis, and general business logic on the index logs inside of the E portion, that Elasticsearch portion. So K, Kibana is what adds the GUI and the credibility value.</p>
<p>So, if we look at this entire flow chart here, it’s the same thing that we’ve been seeing with those white boxes early on in the slides, only this has some exact services named to it. So, the Elasticsearch, yet again, is just another sync. So we have our database or presumably, this would be something like a DynamoDB or even a SQL database if you wanted to implement your own transaction log scraper. In this case, I’ve used the Dynamo logo. DynamoDB can submit its changes to this stream, change system, so there’s DynamoDB Streams is something that is supported now. In effect you are turning on what looks almost exactly like a Kinesis Stream that is populated with all of the events from a change stream off the database. So it’s almost exactly like a transaction log.</p>
<p>You can have a Lambda poll on that transaction log or that change log so we can have a Lambda reading off the change stream. Then you could emit… Then whenever you have these changes occurring, you can have the CloudWatch log streams that are created by Lambda by default, in this case, we can have those logs automatically indexed by CloudWatch. That’s a default thing if we set the role policy correct to allow Lambdas to create the logs. CloudWatch, we can also configure to stream into another Lambda. So we can stream into this Lambda off of our CloudWatch Logs and have the Lambda insert into the Elasticsearch service in the correct way for Kibana to operate efficiently. That is actually a console action that is handled for you.</p>
<p>And then we have a fast, searchable, united graphical logs UI which is excellent for Ops management. So this one of the more common syncs that people think of because it uses logs for the same utility that people are used to thinking about using them for, for debugging. This is just the extremely sophisticated way to debug an entire cloud because you don’t need to submit only the API Lambda logs or the database transaction logs. You don’t need to submit only those things to the Elasticsearch service. We can also submit logs from anywhere else in the cloud and still have them aggregated in a centralized place. So not only do we get unification of the multiple streams inside of log groups, but we can also aggregate across log groups and then create pretty charts and different analytics and metrics based not only on hard numeric metrics that CloudWatch natively support. But also, we can create arbitrary metrics off of a query that might be derived from working over the JSON representation of different logs.</p>
<p>So next we’re going to do a little hands-on demonstration and try the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/elk-stack/">ELK stack</a> out by creating one inside the console.</p>
<h1 id="ELK-Stack"><a href="#ELK-Stack" class="headerlink" title="ELK Stack"></a>ELK Stack</h1><p>Welcome back to CloudAcademy’s course on Advanced <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/introduction-27/">Amazon Web Services Monitoring Metrics and Logging</a>. In this lecture, we’re going to be trying out the ELK stack which was one of our logs stream sinks that we had talked about. It’s a log aggregation service that let’s us aggregate across multiple CloudWatch log streams, any kind of events that we want to index into the system. It integrates nicely with the Amazon Web Services stack with the introduction recently of the AWS Elasticsearch service which runs the E in that service and also the K. And the Lambda ends up being our L for the indexing of the log.</p>
<p>Without further delay, let’s get started. So just a reminder of what we’re trying to build. If we look really quickly at this flow chart that I’m working with here, I’m using a flow chart software that we can take peeks at so we can make these diagrams. But effectively, I’ve already got some of this built out here. We’re going to be simulating a little API, but the main important piece here is that we’ll be emitting events into CloudWatch logs, pulling logs out, feeding them into a Lambda which then subsequently inserts them to this Elasticsearch service that’s actually running the E and the K in our ELK stack. Then we’ll go through this log inspector cycle here where we try out that fast, searchable unified graphical logs UI.</p>
<p>So I need to navigate over to my CloudWatch console first and we need to first see what these log events might look like. I’m actually going to use AWS Lambda to create some logs just because Lambda integrates with CloudWatch logs really nicely. It’s important to note that anything that can submit logs into CloudWatch logs will work for this part. This just happens to be lightweight, easy to test thing during a screen share.</p>
<p>Here we’re looking at some function code inside of a Lambda. It doesn’t really matter. The idea here though is that I’m running a test event where I’ve got some logs coming out of this output. Those might be a little small on your screen, but these logs should be visible now if we go look into CloudWatch logs. So I’m actually going to open these logs up. If we look at the raw log stream here, we can see that we have these function-loaded portions here and we can see that we have some events coming through. That’s all well and good.</p>
<p>Let’s go back to the Lambda console and rather than echoing, I’m now going to configure my test event and run a ping. We should see it come back with Pong here and if I go back to my log streams… …we can see that last execution that I did for the echo and eventually that pong will show up. There’s a little bit of latency there. So I won’t bore us to death waiting for it.</p>
<p>Here we’re navigating inside of the CloudWatch log group. These are interface here. We can navigate into individual streams which we were talking about in our previous lecture. Now in general this is helpful, but it’s not optimal because I might want also to be able to search for events at the log group level instead of just the log stream which as you can see all I can do is search by stream prefix here and I can only search by text once I navigate into this user interface for the individual streams.</p>
<p>Without further ado, let’s set up an ELK stacks. So you’d want to navigate over to the Elasticsearch service somehow if you’re looking in the all AWS Services, it’s alphabetical. So we could just click up here. And once we click on our Elasticsearch services, we’ll navigate to this tab. I’ve already set this up so we can accelerate the pace of this video, but I’ll show you what it takes to set one of these domains up since it takes about 10 minutes usually.</p>
<p>So this is exactly how I set up that other domain. I just hit yes. All of these default values work. I’m just selecting size and the count of the instances that will join that Elasticsearch cluster. I’ll hit next. I would use open access to the domain for this demonstration just so we can easily see what’s going on. I hit next and then I would hit confirm and create. I actually did this step already to accelerate the demonstration here. So we actually have a complete cluster already here.</p>
<p>So if I click on that Kibana 4 user interface, we should see a loading screen like this. So for the first time that you do that load, it will take a while and you’ll see that little loading screen. We need to configure an index pattern. So we have index contains…  we want index contains time event. We’re actually not going to do this until I go and create some more log events that will be submitted into my system. Again, I’m going to run another test with my ping and my pong. May be able to see more events going up here. Not yet. Okay. So even though I didn’t get any events showing up from that one yet, what we can do is move back to the log groups. I actually want CloudAcademyDynamoLambda which I’ll copy from from up here. I can use that identifier to search for it. Then click on the radio button here and stream into Elasticsearch service.</p>
<p>So I only have one cluster left, I can create a new role to allow the Lambda that I’m pushing into to publish into Elasticsearch. So I’m granting it that ability to post into my cluster. So I hit allow. I want to move forward. Realize that my log format will be coming through in the AWS Lambda format. We can see that we have some sample events coming up here. Then after I’ve done all of my configurations, this filter pattern should be familiar if you were watching very carefully here for what my log formats look like on this system, and then I can start streaming.</p>
<p>So what this is doing is it’s setting up this portion here where we have this arrow going into a Lambda and this arrow going into the Elasticsearch service. So we just set that up. We’ll wait just a second to allow that to activate. We’re provided with the link to Kibana 4 but we already have it open. Another best thing that I can do now is to configure test events to actually run these operations and we’re actually going to demonstrate what happens if we have a broken Dynamo configuration here. So I can do something like setting the received event here. I’m actually going to use a slightly different formatting scheme here, and allow my event to be logged in JSON formatting like that. So if I just log my event, then I can save and test. I should see operation ping and message “Hello World!” since I just added the console.log of my JSON and now I can see any invocation that comes into this Lambda in my log output. Now this log output will also show up if look at my log stream over here. So I’ve navigated back to my CloudWatch logs group and I can see that I’ve already got the JSON file or JSON line showing up inside here.</p>
<p>Now when we configured our ELK stack streaming service here when we did that. I’m going to reload so that we can see if those indices start showing up here and what we can do here is go directly to our cluster. We can run a search and see that we started having some events showing up here. So we’ve got some Kibana 4 indices. We’ve got some data showing up in the cluster now at the search engine end point. And if we scroll around here. We can see that my index that it set up is CloudWatchLogs- with the date that it occurs, with the type of the log stream names. Given that, we now know how we need to configure our index setting.</p>
<p>So I’m actually going to set this to cwl for CloudWatch Logs and set it to…use a time stamp field name of @timestamp. So this is the correct configuration for when we’re doing CloudWatch log segregation in Kibana. So once I hit create, I should see all of my metadata start showing up since we already acquired some events from running before, and that’s actually sufficient for us to begin using the discovery module here where I can see I start seeing all of my events that came through. Now, this is not particularly useful until we actually start creating some more logs. So let’s create an error and see what happens.</p>
<p>So I’m going to create an error by…if we can see my default when I switch cases if I select an operation that is unknown then I can get it to throw an error. So let’s do that. Going to set it up for an operation of many question marks, hit save and test, run that a couple times. We can see some very angry execution results with JSON representations of an error as well as the input value itself.</p>
<p>So if we think about this, this could be if somebody fuzzes your API and sends you some input that you don’t understand. Perhaps your API doesn’t support unicode. Rather than an intentional error like I’ve created here, this could easily be a 500 error or a 404 or some other problem that might organically occur where you want your API if this was a stream that’s was being logged to standard out even on an EC2 instance. Then we would also want that to show up on this end.</p>
<p>What happens if I just search? We can see a whole bunch more events because I ran the test a couple more times. We can see my older event that I ran that ping up here and then I sent some more events where I have question marks. We can see the incoming event itself and we can see some error message events. So, say for instance, I want to know how many times there were unrecognized operations. Then I can see that there were three events during which there were unrecognized operations. We can also see the frequency with which they occurred. They occurred three times very frequently there. So this is excellent if you’re trying to find specific values. Now you could also use this if you’re trying to debug specific customers.</p>
<p>So again, this is contrived, but say we also set a customer ID field and set it one through zero, and search for customer ID. So we can see that we have this customer ID string and once I do the search for it after I allowed some time for those events to propagate, we can see that whenever I want my customer ID to show up, we can search for just the customer ID and see these events show up. I can also go back and expand by different properties, see the messages that are coming through etc, etc. So this is what a log aggregation system look like.</p>
<p>Now, we can also do our log analytics. If I want to visualize, for instance, an area chart from a new search, if I want my X-axis to be a histogram or a date histogram on time stamp over an automatic interval and add a sub-aggregation where I could split the area and I want to go by terms inside of the field for say on event or it can do an application. We could see the different frequencies of terms as we look inside of a system. So I could see where different numbers or terms showed up, and I can actually further refine this and say “Okay, I only want to see a histogram of these events.”</p>
<p>So we can do all kinds of things like graphing on different fields and just generally perform magic. You can also add visualizations to different dashboards. You can set up any number of different things that you want based on these sub-aggregations. And of course, we have this excellent capability of doing searches.</p>
<p>There are commercial products that you can use that do the similar behaviors here, but we’re a big fan of open source and being able to do value-added automation on top of our system. So we can see this big, nice log stream here. We have the original streams and sources that it came from, the AWS account associated with it, and we can do free text search. So again, we can search for specific error types if we so please.</p>
<p>So this kind of thing is very helpful for if you’re trying to do a debugging session if a customer’s complaining. Then, we of course want to be able to see what the customer’s talking about by, for instance, searching for the error code that was dumped onto the page if they’re on the phone and you’re trying to do some kind of support with them. You can use this for any number of things. It’s very helpful and it was very easy because all I had to do was create one of these domains, run through, create some sort of events so that they show up in CloudWatch logs, go to the log group, and check that streaming box and send it to Elasticsearch granting the role to the Lambda to allow the post. So that’s it for ELK stack demonstration.</p>
<p>I hope to see you soon on the next lecture in which we’ll be doing a little bit of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/slack-chatops/">chatOps</a> in which we do another trivial solution where I make something pop up in my slack channel whenever a certain event occurs in my Amazon account.</p>
<h1 id="Slack-ChatOps"><a href="#Slack-ChatOps" class="headerlink" title="Slack ChatOps"></a>Slack ChatOps</h1><p>Welcome back to Cloud Academy’s course on Advanced <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/introduction-27/">Amazon Web Services Monitoring Metrics and Logging</a>. Today, we’re going to look at a demo of a ChatOps system, which is a system whereby we post operational messages or alerts into a chat system. I’ll be using Slack today, since I like their API. It’s nice and easy, and I already have a domain that I could use. So without further ado, let’s get started.</p>
<p>So the first thing that we need to realize is that we can reuse from the previous demo the same kind of logic that we were using to degenerate these unhandled errors here. So I’m going to continue using that same Lambda, simply because it’s already pre-integrated with CloudWatch, and I don’t have to do any additional work to get this thing to generate logs and submit them to CloudWatch. I wouldn’t have to install the daemon like I do on an EC2 instance.</p>
<p>So looking at the function, all we need to do is give it an operation value that does not meet any of these cases, and we’ll get this uncaught exception, which is what I did. I gave it this name “Fatal Operation”. So how do we get the logs from this thing to show up in a Slack chat whenever there’s an error or something? Well, it’s relatively simple. I have to create a Lambda function that will post into Slack. So one way that I can do that is by creating one of these Slack integrations. So if I go to my custom integrations, I could configure an incoming Webhook. All you have to do is click Yes, and click Add Configuration. I have this set up to post into AWS, and then I copy my Slack Webhook URL, which I’m not going to show you because then you could post into my account. Then, once we realize that I have an endpoint that I can post into Slack with, I need to create a Lambda function that will actually let me post into Slack. So let’s do “SlackChatOpsDemo2”, then enter some code in that will handle the stream <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/advanced-techniques-for-aws-monitoring-metrics-and-logging/events-everywhere/">events</a> that come out of CloudWatch.</p>
<p>So a couple things going on here, really only three. I receive the event, I un-Base64 the event, and I G-unZip the event. So CloudWatch Logs is going to try to save bandwidth by transporting all the events pre-GZipped and Base64-ed so they compress well. So all I’m doing here is decompressing and then parsing and re-stringifying in a nicer format for me to post into Slack. When I post into Slack, literally all it is is adding some marked down-style block code formatting, joining it with new lines, and then running an HTTPS request against my Slack, Hook, host and path.</p>
<p>So I need to then assign a role to the Lambda, which will allow it to both create new logs and read from log streams. So I’m going to create a new role policy and manually edit this one. There’s no out-of-the-box role for us to use for this kind of ChatOps system. But I can just give Lambda full access to logs for now, allow it to have access to those full sets for the logs, then up my timeout to about five seconds so we don’t have Slack issues, and create the function.</p>
<p>So the next thing I need to do is start streaming that data from a log group which corresponds to my Cloud Academy Dynamo Lambda, which is where I’m generating my error, so my Cloud Academy Dynamo Lambda. Stream that to AWS Lambda. If I can actually find my demonstration Lambda, that Lambda that we just created that does the G-unZipping and Base64 decoding, we want to strip it over there. Since our event generator again is this Cloud Academy Dynamo Lambda, we want to use the AWS Lambda format.</p>
<p>So we should now be streaming from our Dynamo Lambda. We’ll automatically create log lines that go into CloudWatch Logs at the top of the stream. So this is an inserting or publishing function into a stream that is our log stream. Then, use this other Lambda, this Slack ChatOps Demo 2 as my consumer. So I set that subscription up when I went over and checked this box, and started subscribing to that log stream with this other Lambda. So now we should expect to be able to run a test, have the “Fatal Operation” fail, check the actual logs, see that we have some fatal operations, which we’ll then subsequently post into Slack. So you can see that I have Slack showing up here. This is the un-Base64, un-GZipped message.</p>
<p>Again, we went from Lambda, which generates log event lines, sends them into CloudWatch Logs here. We then went to the CloudWatch Logs Group user interface, and went to our subscriptions and added a subscription filter to Lambda. This Lambda was the recipient Lambda, which has these events coming in. These events correspond to our CloudWatch Logs event data. The way that those are formatted and sent to us to save bandwidth are Base64 and GZip, so we had to undo those steps. We had to decode the Base64 and then G-unZip, and then simply publish to Slack via the API endpoint and, voila, we have our ChatOps system. We can see something terrible happened, and we have fatal operations, and now our entire team that’s on our chat system should be able to see a message like this.</p>
<p>So hopefully, you enjoyed seeing the practical way to implement a very simple ChatOps system using totally serverless technologies, as well as CloudWatch log streams, and treating logs as a first-class citizen for insight and automation. ChatOps, which is one of these things, is a very simple way for us to alert people on our team when certain log events that are scary or frequent, or whatever other metric we want to us, publish into Slack and notify the entire team.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/14/AWS-Security-Specialty-Lab-Monitor-Amazon-CloudWatch-Security-Logs-for-failed-SSH-attempts-28/" rel="prev" title="AWS-Security-Specialty-Lab-Monitor-Amazon-CloudWatch-Security-Logs-for-failed-SSH-attempts-28">
      <i class="fa fa-chevron-left"></i> AWS-Security-Specialty-Lab-Monitor-Amazon-CloudWatch-Security-Logs-for-failed-SSH-attempts-28
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/14/AWS-Security-Specialty-How-to-Use-KMS-Key-Encryption-to-Protect-Your-Data-30/" rel="next" title="AWS-Security-Specialty-How-to-Use-KMS-Key-Encryption-to-Protect-Your-Data-30">
      AWS-Security-Specialty-How-to-Use-KMS-Key-Encryption-to-Protect-Your-Data-30 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Events-Everywhere"><span class="nav-number">2.</span> <span class="nav-text">Events Everywhere</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handling-Distribution"><span class="nav-number">3.</span> <span class="nav-text">Handling Distribution</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELK-Stack"><span class="nav-number">4.</span> <span class="nav-text">ELK Stack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Slack-ChatOps"><span class="nav-number">5.</span> <span class="nav-text">Slack ChatOps</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
