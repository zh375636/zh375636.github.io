<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to “Building Containers with Azure DevOps”. My name is Thomas Mitchell and I’ll be taking you through this course.  I’m an Azure Instructor at Cloud Academy and I have over 25 year">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-204-Building-Containers-with-Azure-DevOps-11">
<meta property="og:url" content="https://example.com/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to “Building Containers with Azure DevOps”. My name is Thomas Mitchell and I’ll be taking you through this course.  I’m an Azure Instructor at Cloud Academy and I have over 25 year">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-14T15:07:58.000Z">
<meta property="article:modified_time" content="2022-11-15T03:32:16.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-204-Building-Containers-with-Azure-DevOps-11 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-204-Building-Containers-with-Azure-DevOps-11
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-14 11:07:58 / Modified: 23:32:16" itemprop="dateCreated datePublished" datetime="2022-11-14T11:07:58-04:00">2022-11-14</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/14/AZ-204-Building-Containers-with-Azure-DevOps-11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to “Building Containers with Azure DevOps”. My name is Thomas Mitchell and I’ll be taking you through this course. </p>
<p>I’m an Azure Instructor at Cloud Academy and I have over 25 years of IT experience, several of those with cloud technologies. If you have any questions, feel free to connect with me on LinkedIn, or send an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This course is intended for DevOps professionals who wish to learn how to design and implement, through the use of containers, strategies for developing application code and infrastructure that allow for continuous integration, testing, delivery, monitoring, and feedback.</p>
<p>To get the most from this course, you should have a basic understanding of the <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Azure</a> platform and of container concepts.</p>
<p>We’ll kick off by talking about ways to create deployable images. You’ll learn about <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/the-power-of-docker-containers/">docker containers</a> and their role in development. You’ll also learn about microservices and where they fit in.</p>
<p>After discussing microservices, we’ll dive into the different Azure container-related services. We’ll talk about Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, and Azure Service Fabric. We’ll also tough on Azure App Service.</p>
<p>Once we finish up with the different container-related services, we’ll look at a typical Dockerfile.</p>
<p>Later on, in this course, we’ll look at Docker multi-stage builds. You’ll learn what multi-stage builds are, and things to consider when working with multi-stage builds.</p>
<p>We’ll round things out with a hands-on demonstration that shows you how to create an Azure Container Registry,</p>
<p>By the time you complete this course, you’ll have a better understanding of containers and how they are used in Azure DevOps.</p>
<p>We’d love to get your feedback on this course, so please give it a rating when you’re finished. If you’re ready to learn how to build containers with Azure DevOps, let’s get started.</p>
<h1 id="The-Power-of-Docker-Containers"><a href="#The-Power-of-Docker-Containers" class="headerlink" title="The Power of Docker Containers"></a>The Power of Docker Containers</h1><p>Hello and welcome to “The Power of Docker Containers”. Let’s talk a little bit about what Docker containers bring to the table as far as the development process goes.</p>
<p>As a software containerization platform, Docker offers developers a common toolset and packaging model. It also provides a deployment mechanism for containerized apps. This results in simplified management, regardless of the host, as well as a seamless <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">DevOps</a> experience.</p>
<p>Docker images can be created and deployed identically across virtually any environment in seconds. The Docker ecosystem is huge. This ecosystem includes hundreds of thousands of apps that are packaged in Docker containers. DockerHub, which is the Docker-maintained public containerized application registry, publishes almost 200,000 applications in the public community repository. </p>
<p>The notion that you can deploy a SQL Server Linux instance in seconds, using a Docker image, is a testament to the power of containers. It is this power that <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/microservices-and-containers/">containerization</a> brings to the DevOps sphere.</p>
<h1 id="Microservices-and-Containers"><a href="#Microservices-and-Containers" class="headerlink" title="Microservices and Containers"></a>Microservices and Containers</h1><p>Hi there. Welcome to Microservices and Containers. Although containers have been most commonly used to simplify <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">DevOps</a> through simplified developer-to-test-to-production flows, there are other uses for them. Microservices, for example, is a quickly-growing use-case for containers. </p>
<p>The term “Microservices” refers to an application development strategy where each part of an application is actually deployed as a completely self-contained component (or microservice). The microservices that comprise an application can then be individually scaled and updated. </p>
<p>The easiest way to explain the concept of microservices is to use an example scenario.</p>
<p>Let’s imagine for a second that your organization is the author of a large, monolithic tax application. As part of the development of the next revision of the software, your organization wants to migrate it to a collection of microservices. </p>
<p>Now, the current app might include a piece of code that does some specific tax calculation in certain circumstances – and this code may exist in several spots within the app. Whenever new tax laws are approved or changed, changes are needed in the calculation of taxes. This means that the same changes need to be made anywhere this tax calculation is performed within the app.</p>
<p>By moving to a collection of microservices, you could allow the application to create a notification that a tax calculation needs to be made in response to some scenario. Microservices involved in that calculation can be subscribed to those notifications – and then those individual microservices can do what they need to do to perform the tax calculations. You’d likely have one specific microservice that does the actual calculation.</p>
<p>Whenever a new tax law is enacted that affects tax calculations, you would only need to update the microservice(s) responsible for the calculations. You wouldn’t need to make changes throughout the app code base.</p>
<p>While you might operate a development or testing environment on a single server or by using a single instance of each microservice, production is typically a different story. In such an environment, you are likely going to want to be able to scale things out. You’ll probably want to scale out to multiple instances across a cluster of servers, rather than running things on one server. You’ll want the ability to scale in as well. You may also want different teams within your development department to be able to independently work on, and update, different microservices that each team is responsible for.</p>
<p>This is where microservices can really shine. By leveraging the benefits of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/the-power-of-docker-containers/">Docker containers</a> when working with more complex microservice-based applications, organizations can become more agile, because those microservices can be quickly scaled out and in to meet the loads on the application. While doing so, however, the isolation of resources and namespaces offered by containers ensures that one microservice instance does not interfere with any other instances. This makes it easier to design a solid microservice architecture, which, in turn, allows organizations to deal with the management, deployment, orchestration, and patching needs of <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/container-related-services-in-azure/">container-based services</a> – while limiting the risks to availability.</p>
<h1 id="Container-Related-Services-in-Azure"><a href="#Container-Related-Services-in-Azure" class="headerlink" title="Container-Related Services in Azure"></a>Container-Related Services in Azure</h1><p>Hi there. Welcome to “Container-Related Services in Azure”. In this lecture, we’ll take a quick 30,000 foot view of each of the container-related services that are available in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a>. We’ll look at Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, Azure Service Fabric, and Azure App Service.</p>
<p>Let’s start with Azure Container Instances.</p>
<p>When you run workloads in Azure Container Instances, you can focus on app development and deployment instead of the deployment and management of the underlying infrastructure that’s necessary to run those apps.</p>
<p>While Azure Container Instances are easy to deploy, the main advantage of using them is the security that the hypervisor isolation that they provide for each container group. With this type of isolation available, you can be sure that your organization’s containers aren’t sharing their OS kernel with other containers.</p>
<p>You can read more about Azure Container Instances by visiting the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-instances/">https://azure.microsoft.com/en-us/services/container-instances/</a></p>
<p>The Azure Kubernetes Service started out as Azure Container Services, or ACS. It originally supported Docker Swarm and Mesos&#x2F;Mesosphere DC&#x2F;OS for orchestration management. However, when Kubernetes support was added, it became so popular that Microsoft eventually renamed the Azure Container Service to the Azure Kubernetes Service, or AKS.</p>
<p>At this point, Kubernetes is really the standard for container orchestration. Using the Azure Kubernetes Service, you can not only deploy and manage Kubernetes, but you can also scale and run your applications in a secure environment.</p>
<p>To learn more about the Azure Kubernetes Service, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/kubernetes-service/">https://azure.microsoft.com/en-us/services/kubernetes-service/</a></p>
<p>The Azure Container Registry is another container-centric service offering available in Azure. It allows you to store and manage your container images in a central registry, which is integrated with several other Azure services, including the App Service, Batch, and Service Fabric, among others. </p>
<p>Azure Container Registry supports many types of container deployments, including DC&#x2F;OS, Docker Swarm, and Kubernetes. Because of the broad support that Azure Container Registry offers, you can manage the configuration of your applications without being locked into the configuration of the target hosting environment. </p>
<p>To read more about the Azure Container Registry, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-registry/">https://azure.microsoft.com/en-us/services/container-registry/</a></p>
<p>Azure Service Fabric is a distributed systems platform that allows you to build and operate always-on, scalable, distributed apps. The service makes it easier to package, deploy, and manage scalable and reliable <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/microservices-and-containers/">microservices and containers</a>. It can also host and orchestrate containers.</p>
<p>By leveraging Azure Service Fabric, you can avoid infrastructure problems and focus solely on the deployment of mission-critical workloads that are not only reliable, but also scalable. </p>
<p>For more details on the Azure Service Fabric, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/service-fabric/">https://azure.microsoft.com/en-us/services/service-fabric/</a></p>
<p>Azure Web Apps is an Azure offering that provides you with a managed service for both Windows-based and Linux-based web applications. This service allows you to deploy and run containerized apps for both platforms and it also offers auto-scaling and load balancing options. You can even integrate with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">Azure DevOps</a>.</p>
<p>To read more about the Azure App Service, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/app-service/">https://azure.microsoft.com/en-us/services/app-service/</a></p>
<h1 id="Anatomy-of-a-Dockerfile"><a href="#Anatomy-of-a-Dockerfile" class="headerlink" title="Anatomy of a Dockerfile"></a>Anatomy of a Dockerfile</h1><p>Hi there. Welcome to “Anatomy of a Dockerfile”. In this lecture, we’re going to look at a basic Dockerfile, line by line.</p>
<p>Dockerfiles are used by docker build to assemble images. They are essentially text files that contain the commands that are necessary to build an image. On your screen is an example of a very basic Dockerfile. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu </span><br><span class="line">LABEL maintainer=&quot;tmitchell@cloudacademy.com&quot; </span><br><span class="line">ADD appsetup / </span><br><span class="line">RUN /bin/bash -c &#x27;source $HOME/.bashrc; echo $HOME&#x27; </span><br><span class="line">CMD [&quot;echo&quot;, &quot;Hi everybody!&quot;] </span><br></pre></td></tr></table></figure>

<p>Generally speaking, every image is based off another existing image. In this sample Dockerfile here, line one refers to the parent image that this new image will be based on. The Ubuntu image referred to in line one would be retrieved from either a local cache or from DockerHub.</p>
<p>I should point out here that an image that doesn’t have a parent is called a base image. If that were the case here, what we could do with this Dockerfile is completely omit the FROM line altogether. We could also replace it with FROM scratch, instead. However, since we’re using the ubuntu base image, we are referencing it in the file.</p>
<p>The second line in this sample Dockerfile uses the LABEL command to set the email address of the person who maintains the file.</p>
<p>The third line in our example uses the ADD command to add a file, called “appsetup” into the root folder of the image being created.</p>
<p>The fourth line is a RUN command that runs when the image is being created by docker build. This part of the Dockerfile is typically used to configure things within the image. </p>
<p>The last line in our sample file calls a command that we want to execute once the new container is created from the image.</p>
<p>Of course, every Dockerfile will be different – and they can be as simple or as complex as they need to be. Simpler, however, is always better than complex, when possible.</p>
<p>For more information, visit the Dockerfile reference URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<h1 id="Multi-Stage-Builds"><a href="#Multi-Stage-Builds" class="headerlink" title="Multi-Stage Builds"></a>Multi-Stage Builds</h1><p>Hi there. Welcome to “Multi-Stage Builds”. In this lecture, we’re going to take a look at what multi-stage builds are and what they bring to the table.</p>
<p>So, Multi-stage builds are a new feature that makes life easier when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/anatomy-of-a-dockerfile/">Dockerfiles</a>. They are extremely helpful when trying to optimize Dockerfiles while ensuring that they are still easy to read.</p>
<p>Prior to the introduction of multi-stage builds, what you would typically have is one Dockerfile to use for development. This Dockerfile would contain everything that you need to build the application that you wished to deploy. You’d also have a second, slimmed-down Dockerfile that you would use for production. This second file would contain just the application and only the resources needed to run it. This “builder pattern” of maintaining two Dockerfiles, obviously, isn’t ideal.</p>
<p>The code that you see on your screen is a good example of what the typical “builder pattern” consists of. Notice we have 3 different files. We have DockerFile.build, the Dockerfile, and build.sh.</p>
<p>Dockerfile.build:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v golang.org/x/net/html \</span><br><span class="line"> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line">Dockerfile:</span><br><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br><span class="line">build.sh:</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo Building alexellis2/href-counter:build</span><br><span class="line">docker build --build-arg https_proxy=$https_proxy --build-arg http_proxy=$http_proxy \ </span><br><span class="line">  -t alexellis2/href-counter:build . -f Dockerfile.build</span><br><span class="line"> </span><br><span class="line">docker create --name extract alexellis2/href-counter:build </span><br><span class="line">docker cp extract:/go/src/github.com/alexellis/href-counter/app ./app </span><br><span class="line">docker rm -f extract</span><br><span class="line">echo Building alexellis2/href-counter:latest</span><br><span class="line">docker build --no-cache -t alexellis2/href-counter:latest .</span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure>

<p>If you look at this example, you’ll see that it artificially compresses two different RUN commands together. This is done to avoid creating an additional layer in the image. As is the case with any sort of coding, the more code you have, the more error-prone it becomes – and the more difficult it becomes to maintain.</p>
<p>When the build.sh script is run, it first has to build the first image. Then, it needs to create a container from it, so that it can copy the artifact out, before building the second image. In this scenario, you are left with 2 images – both of which take up room on your system. You are also left with the app artifact on your local disk as well.</p>
<p>Enter Multi-stage builds, which greatly simplify things.</p>
<p>Prior to multi-stage builds, keeping image sizes down was a challenge. This is because every instruction included within a Dockerfile adds a layer to the image. Not only that, but you also need to remember to clean up unneeded artifacts before moving on to the next layer. </p>
<p>Until multi-stage builds became available, authoring an efficient Dockerfile meant using shell tricks and other logic to keep the layers as small as possible. You also had to use the same tricks to ensure that each layer has only the artifacts that it needs from the previous layer and nothing else.</p>
<p>On the screen is an example of a multi-stage file.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br></pre></td></tr></table></figure>

<p>When you leverage multi-stage builds, you can use multiple FROM statements within the Dockerfile. Each of the FROM statements begins a new stage. The stages, themselves, are numbered in order, starting with stage 0. What you would typically do, though, to make the Dockerfile easier to maintain, is use the AS clause to name, or alias, each stage.</p>
<p>Notice the aliasing that’s been added to the file on your screen:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 AS builder</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html </span><br><span class="line">COPY app.go  .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest </span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;] </span><br></pre></td></tr></table></figure>

<p>This example on your screen names the stage and uses the name in the COPY instruction. By referencing the name in the copy instruction, even if the instructions in this Dockerfile are re-ordered later on for some reason, the COPY won’t break.</p>
<p>I should also mention that when you build an image, you don’t have to build the entire Dockerfile, including every stage. Instead, you can specify a single target build stage. The command that you see on your screen, when using our example Dockerfile, stops at the stage named builder:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t alexellis2/href-counter:latest</span><br></pre></td></tr></table></figure>

<p>The –target option, in this command, tells docker build to create an image up to the target of builder, which is a named stage in our example file. </p>
<p>In the next lesson, we’ll take a look at some best practices that you can follow when working with <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/best-practices-for-multi-stage-builds/">multi-stage builds</a>.</p>
<h1 id="Best-Practices-for-Multi-Stage-Builds"><a href="#Best-Practices-for-Multi-Stage-Builds" class="headerlink" title="Best Practices for Multi-Stage Builds"></a>Best Practices for Multi-Stage Builds</h1><p>Hi there. Welcome to Best Practices for <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/multi-stage-builds/">Multi-Stage Builds</a>. In this lecture, we’re going to review some of the best practices that you should be following when working with multi-stage builds. We’re going to talk about adopting container modularity, avoiding unnecessary packages, choosing an appropriate base, and avoiding the inclusion of application data.</p>
<p>When working with builds, you really want to avoid overly complex container images that couple together several applications. Instead, what you should be doing is using multiple containers, with each one intended for a single purpose. For example, you might want to put a website in one container but relegate the database for the website to another container.</p>
<p>While there are always going to be exceptions to this rule, splitting up the components of an application into separate containers makes it more likely that you will be able to minimize work effort by being able to reuse containers. Adopting container modularity will also often make it easier to scale an application. Using our website example from earlier, container modularity would allow you to add replicas of the website container while leaving the database container alone. </p>
<p>An easy way to minimize image sizes is to avoid including unnecessary packages in your images. For example, instead of including packages that you think you MIGHT need, leave them out until you are sure you need them. Once you are sure you need them, you can include them.</p>
<p>Choosing an appropriate base image, or parent image, allows you to optimize the contents of your Dockerfile. By starting with an image that only contains the packages that you need, you can keep your Dockerfiles in check. </p>
<p>Although it’s possible to store your application data right inside the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-create-an-azure-container-registry/">container</a>, doing so increases the size of your image. This runs counter to the idea of optimizing things. Instead of storing app data in your containers, you should consider using docker volume support. By doing so, you can maintain isolation of the application itself, and its data. </p>
<p>For more Dockerfile best practices, visit the URL that you see on your screen:</p>
<p><a target="_blank" rel="noopener" href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/">https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/</a></p>
<h1 id="Demo-Create-an-Azure-Container-Registry"><a href="#Demo-Create-an-Azure-Container-Registry" class="headerlink" title="Demo: Create an Azure Container Registry"></a>Demo: Create an Azure Container Registry</h1><p>Hi there and welcome back. In this demonstration, we’re going to do a couple of different things. First, we’re going to deploy a Container Registry in Microsoft Azure using the Azure portal. Once we’ve got that deployed, we’re going to log in to that registry, using the Azure CLI from our local workstation. Once we’ve logged into our registry, what we’re going to do is use the <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-add-docker-support-to-an-existing-application/">Docker</a> terminal which is also installed on our local workstation. And we’re going to first, pull down a basic hello world image from the Docker Hub.</p>
<p>Once we have the Hello World image pulled down from Docker Hub, we’ll take that image and we’ll push it to our Container Registry in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a>. Once we have it pushed to our Container Registry in Azure, we’ll go back to the Azure portal, and we’ll take a look and confirm that our hello world image has in fact been pushed into our Container Registry. So let’s get started here.</p>
<p>On the screen, you can see I’m logged into my Azure Portal here, I’m at my homepage. I am logged in as the admin here. To deploy a Container Registry, we’re simply going to create a resource. And we’ll search the marketplace for Container Registry. And we can see Container Registry here and we’ll create it. We need to give our registry a unique name. And we’ve called it my9878 and it appends, what Azure will do here is append this azurecr.io domain name to your registry name.</p>
<p>So the registry name needs to be unique across Azure. We’ll deploy into our lab subscription and into my resource group. We can leave the rest of this stuff here at its default. We’ll go ahead and click Create. The deployment here shouldn’t take long, usually a couple minutes at most. We can see it’s been deployed. So we’ll go to our resource here. And if we go into repositories within our registry, we can see we have no repositories here.</p>
<h1 id="Demo-Add-Docker-Support-to-an-Existing-Application"><a href="#Demo-Add-Docker-Support-to-an-Existing-Application" class="headerlink" title="Demo: Add Docker Support to an Existing Application"></a>Demo: Add Docker Support to an Existing Application</h1><p>So now that our my9878 <a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/demo-create-an-azure-container-registry/">container registry</a> has been deployed. Let’s log into it using the Azure CLI from my workstation. So let me bounce down here. I actually have my PowerShell running and my Docker terminal here. So let’s open up PowerShell here. And from PowerShell what I’m going to do is run the az acr login command. And when I do this, I need to specify the name of my repository.</p>
<p>Now oddly enough, I don’t need to nor should I include the azurecr.io domain name when I specify the name for my repository here. So we bounced back out to overview. See the full login server here, my9878.azurecr.io Instead, I just use the name that I gave my repository. So we’ll go ahead hit enter here and we can see that our login has succeeded. Now what we’re going to do into this exercise is push the basic hello world image up to my container registry. That being said, I have to obtain that hello world image first and I’m going to obtain that from Docker Hub.</p>
<p>Now to do that, I’m going to switch over to my Docker terminal here. Now from Docker terminal, what I’m going to do is run a Docker pull hello world command and what this will do is pull the latest hello world image from Docker.io So it’s coming from Docker Hub. Now before we push this image into our container registry. We need to first tag it with the fully qualified domain name of our ACR login server.</p>
<p>If we bounce out to our Azure portal, we can see the FQDN for our login server is my9878.azurecr.io So that’s what we’re going to use here. So let’s bounce back into our terminal here. And we’re going to use the Docker tag command to perform this tagging. Along with the tag command, we need to specify the image. After specifying the name of the image we want to tag, we need to specify the ACR login server. And with that we need to specify the name of our image and the versioning for it.</p>
<p>So we’ll go ahead and tag it. And then what we’ll do now is perform the push using the Docker push command. And essentially we’re going to specify the name we just called in the Docker tag command. And we can see it prepares and then pushes and tells us the image has been pushed. To confirm that our image has been pushed, we can go into our portal and then take a look at our repositories. And we can see hello world is now listed as a repository.</p>
<p>At this point, we can now try to run the image from our container registry. And to do that we’ll bounce back down into our Docker terminal. And from here we’ll use the Docker run command. So we’ll go Docker run and again, we’ll specify the image from our registry. And if we look closely here we can see we get a message from Docker telling me that our installation appears to be working correctly.</p>
<p>So with that, we’ve deployed a container registry in <a target="_blank" rel="noopener" href="https://cloudacademy.com/library/azure/">Microsoft Azure</a> using the portal. We used Azure CLI within Azure PowerShell from our local workstation to log in to our registry. And then we used the Docker terminal to pull down an image from Docker Hub. We tagged it and then we pushed that image up into our own registry. Once we confirmed that the push was successful, we were also able to successfully run the image from our registry. So with that let’s call it a wrap.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Congratulations! You’ve come to the end of “<a target="_blank" rel="noopener" href="https://cloudacademy.com/course/building-containers-with-azure-devops-978/introduction/">Building Containers with Azure DevOps</a>“. Let’s review what you’ve learned!</p>
<p>We kicked things off by talking about ways to create deployable images. You learned about docker containers and their role in development. You also learned about microservices and where they fit in.</p>
<p>After discussing microservices, we looked at the different Azure container-related services. We talked about Azure Container Instances, the Azure Kubernetes Service, the Azure Container Registry, and Azure Service Fabric. We also touched on Azure App Service.</p>
<p>After finishing up with the different container-related services, you learned what a typical Dockerfile looks like.</p>
<p>Later on, you learned about Docker multi-stage builds. You learned what multi-stage builds are, and things to consider when working with multi-stage builds.</p>
<p>We wrapped up with a hands-on demonstration that showed you how to create an Azure Container Registry.</p>
<p>At this point, you should have a better understanding of containers and how they are used in Azure DevOps.</p>
<p>I should point out, before you go, that, in addition to completing courses like this one, you should always keep up with the latest features and services by reading Microsoft’s published documentation as well.</p>
<p>As always, thanks for watching, and happy learning!</p>
<h2 id="4Container-Related-Services-in-Azure"><a href="#4Container-Related-Services-in-Azure" class="headerlink" title="4Container-Related Services in Azure"></a>4<strong>Container-Related Services in Azure</strong></h2><p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-instances/">Azure Container Instances</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/kubernetes-service/">Azure Kubernetes Service</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/container-registry/">Azure Container Registry</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/service-fabric/">Azure Service Fabric</a></p>
<p><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/app-service/">Azure App Service</a></p>
<h2 id="5Anatomy-of-a-Dockerfile"><a href="#5Anatomy-of-a-Dockerfile" class="headerlink" title="5Anatomy of a Dockerfile"></a>5<strong>Anatomy of a Dockerfile</strong></h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a></p>
<h2 id="7Best-Practices-for-Multi-Stage-Builds"><a href="#7Best-Practices-for-Multi-Stage-Builds" class="headerlink" title="7Best Practices for Multi-Stage Builds"></a>7<strong>Best Practices for Multi-Stage Builds</strong></h2><p><a target="_blank" rel="noopener" href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/">Dockerfile best practices</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/14/AZ-204-Running-a-Container-on-Azure-App-Service-10/" rel="prev" title="AZ-204-Running-a-Container-on-Azure-App-Service-10">
      <i class="fa fa-chevron-left"></i> AZ-204-Running-a-Container-on-Azure-App-Service-10
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/14/AZ-204-Getting-Started-with-Azure-Container-Instances-12/" rel="next" title="AZ-204-Getting-Started-with-Azure-Container-Instances-12">
      AZ-204-Getting-Started-with-Azure-Container-Instances-12 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Power-of-Docker-Containers"><span class="nav-number">2.</span> <span class="nav-text">The Power of Docker Containers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Microservices-and-Containers"><span class="nav-number">3.</span> <span class="nav-text">Microservices and Containers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Container-Related-Services-in-Azure"><span class="nav-number">4.</span> <span class="nav-text">Container-Related Services in Azure</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Anatomy-of-a-Dockerfile"><span class="nav-number">5.</span> <span class="nav-text">Anatomy of a Dockerfile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-Stage-Builds"><span class="nav-number">6.</span> <span class="nav-text">Multi-Stage Builds</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Best-Practices-for-Multi-Stage-Builds"><span class="nav-number">7.</span> <span class="nav-text">Best Practices for Multi-Stage Builds</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Demo-Create-an-Azure-Container-Registry"><span class="nav-number">8.</span> <span class="nav-text">Demo: Create an Azure Container Registry</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Demo-Add-Docker-Support-to-an-Existing-Application"><span class="nav-number">9.</span> <span class="nav-text">Demo: Add Docker Support to an Existing Application</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">10.</span> <span class="nav-text">Conclusion</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4Container-Related-Services-in-Azure"><span class="nav-number">10.1.</span> <span class="nav-text">4Container-Related Services in Azure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5Anatomy-of-a-Dockerfile"><span class="nav-number">10.2.</span> <span class="nav-text">5Anatomy of a Dockerfile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7Best-Practices-for-Multi-Stage-Builds"><span class="nav-number">10.3.</span> <span class="nav-text">7Best Practices for Multi-Stage Builds</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2653</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
