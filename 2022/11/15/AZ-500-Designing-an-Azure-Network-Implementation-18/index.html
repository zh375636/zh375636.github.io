<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IntroductionWelcome to “Designing an Azure Network Implementation”. My name’s Guy Hummel and I’ll be helping you with the network aspects of architecting an Azure solution. I’m the Azure Content Lea">
<meta property="og:type" content="article">
<meta property="og:title" content="AZ-500-Designing-an-Azure-Network-Implementation-18">
<meta property="og:url" content="https://example.com/2022/11/15/AZ-500-Designing-an-Azure-Network-Implementation-18/index.html">
<meta property="og:site_name" content="Hang&#39;s Blog">
<meta property="og:description" content="IntroductionWelcome to “Designing an Azure Network Implementation”. My name’s Guy Hummel and I’ll be helping you with the network aspects of architecting an Azure solution. I’m the Azure Content Lea">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-15T14:11:47.000Z">
<meta property="article:modified_time" content="2022-11-20T23:13:46.000Z">
<meta property="article:author" content="Hang Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://example.com/2022/11/15/AZ-500-Designing-an-Azure-Network-Implementation-18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>AZ-500-Designing-an-Azure-Network-Implementation-18 | Hang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://example.com/2022/11/15/AZ-500-Designing-an-Azure-Network-Implementation-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/123456.gif">
      <meta itemprop="name" content="Hang Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AZ-500-Designing-an-Azure-Network-Implementation-18
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-15 10:11:47" itemprop="dateCreated datePublished" datetime="2022-11-15T10:11:47-04:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-20 19:13:46" itemprop="dateModified" datetime="2022-11-20T19:13:46-04:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AZ-500/" itemprop="url" rel="index"><span itemprop="name">AZ-500</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/11/15/AZ-500-Designing-an-Azure-Network-Implementation-18/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/15/AZ-500-Designing-an-Azure-Network-Implementation-18/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Welcome to “Designing an Azure Network Implementation”. My name’s Guy Hummel and I’ll be helping you with the network aspects of architecting an Azure solution. I’m the Azure Content Lead at Cloud Academy and I have over 10 years of experience with cloud technologies. If you have any questions, feel free to connect with me on LinkedIn and send me a message, or send an email to <a href="mailto:support@cloudacademy.com">support@cloudacademy.com</a>.</p>
<p>This course is intended for people who want to become Azure cloud architects.</p>
<p>To get the most from this course, you should have a general knowledge of networking.</p>
<p>We’ll start with an overview of virtual networks, which are the fundamental building blocks of Azure networking. Then I’ll go over the different options for load balancing traffic to applications. Next, you’ll see how to connect Azure virtual networks to external networks, such as in your own datacenter. After that, I’ll explain how to secure your Azure networks. Finally, I’ll show you how to design connectivity for hybrid applications that access on-premises data.</p>
<p>By the end of this course, you should be able to design Azure virtual networks; design external connectivity for Azure virtual networks; design network security strategies for Azure; and design connectivity for hybrid Azure applications.</p>
<p>We’d love to get your feedback on this course, so please give it a rating when you’re finished.</p>
<p>Now, if you’re ready to learn how to get the most out of Azure’s network services, then let’s get started.</p>
<h1 id="Azure-Virtual-Networks"><a href="#Azure-Virtual-Networks" class="headerlink" title="Azure Virtual Networks"></a>Azure Virtual Networks</h1><p>As soon as you deploy more than one virtual machine in Azure, you’ll probably have to get them to communicate with each other. You can do that easily by putting them in the same Azure virtual network (or vnet). You can put lots of other Azure services in vnets, too, such as Service Fabric, Kubernetes Service, and HDInsight. You can also create multiple vnets and they will all be isolated from each other.</p>
<p>When you create a virtual network, you specify what IP address space to use. You also need to create at least one subnet that uses a portion of the vnet’s IP address space. Then an Azure DHCP server will assign addresses from that subnet’s IP address range to the network interfaces on the VMs.</p>
<p>If you need name resolution so the VMs in a virtual network can communicate with each other more easily, then the easiest solution is to use Azure-provided name resolution, which doesn’t require any configuration. If you need additional capabilities, such as name resolution for your on-premises servers, then you can provision your own DNS server in the vnet. You can still let Azure take care of the name resolution for your VMs by having your DNS server forward those types of queries to Azure.</p>
<p>If you want to use custom domain names or if you need name resolution between virtual networks, then one option is to use the Private Zones feature of Azure DNS. It’s specifically designed for these scenarios.</p>
<p>By default, all resources in a virtual network can send outbound requests to the internet. If you need any of your resources to accept <em>inbound</em> connections from the internet, then you can assign public IP addresses to them. Bear in mind that there’s an hourly charge for reserving public IP addresses, whether you’re using them or not.</p>
<p>Not every type of Azure service can reside in a virtual network, particularly storage and databases. You can get a secure connection between those services and your vnets, though, by using a virtual network service endpoint. This lets you extend the address space in your vnet to the other service and it ensures that the traffic between them stays on the Azure backbone network. Service endpoints are configured on specific subnets. The services supported by service endpoints are Azure Storage, SQL Database, Cosmos DB, and SQL Data Warehouse.</p>
<p>And that’s it for virtual network design.</p>
<h1 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h1><p>Scaling an application horizontally by adding more VMs is a great solution, but how do you distribute requests to all of those VMs? You have two options: Azure Load Balancer and Azure Application Gateway.</p>
<p>Azure Load Balancer is the right choice for the most common scenarios. It acts as a frontend that distributes incoming traffic to a pool of backend VMs. It supports TCP and UDP applications. By default, it distributes requests equally to the VMs. If the application layer served by these VMs is stateless, then this distribution method will work well. If it’s stateful, though, then you’ll need to use source IP affinity mode. In this mode, all requests from the same IP address will always go to the same VM. You should avoid designing this sort of solution, though, because if a VM goes down, then all of its clients will be down.</p>
<p>If you have a stateless application layer and a VM goes down, then a health probe will detect that the instance is no longer available and it will remove it from the pool. Since no client sessions are tied to that specific instance, all of their requests will go to healthy instances.</p>
<p>A health probe is typically an HTTP request to an instance. By default, the load balancer sends a probe every 15 seconds, but you can change the timing if you want. If your VMs are hosting something other than a web application, then you can configure the health probe to try to establish a TCP session on a specific port.</p>
<p>If you’re using the load balancer for an internet-facing application, then you need to assign a public IP address to it. In this scenario, it’s called a public load balancer. All of the VMs behind it still use private IP addresses, though, and all incoming traffic from the internet must go through the load balancer.</p>
<p>When a VM initiates an <em>outbound</em> connection, then the load balancer performs network address translation (or NAT). In other words, it translates the VM’s private IP address to the public IP address on the load balancer plus a port that it maps to that VM. Because it has this capability, the load balancer can be useful even in situations where you don’t need load balancing. If you need a NAT gateway on Azure, then you can just deploy a public load balancer that only manages outbound connections.</p>
<p>If you have an internal application that shouldn’t be exposed to the internet, then don’t assign a public IP address to the load balancer. Instead, it will use a private IP address. In this configuration, it’s known as an internal load balancer.</p>
<p>You can also use both types of load balancers for the same application. For example, you could use a public load balancer for the web tier and a private load balancer for the business logic tier.</p>
<p>The other way to provide load balancing is to use Azure Application Gateway. Unlike Azure Load Balancer, which operates at layer 4 of the network stack, Application Gateway operates at layer 7. This gives you more flexibility in how you can route requests. Instead of just routing based on IP addresses and ports, it can route based on the URL. For example, if the URL of the request begins with the path to your videos folder, then you could tell the application gateway to route the request to your pool of video servers.</p>
<p>You can do lots of other handy things with it too. A few examples are redirecting all HTTP requests to HTTPS, serving traffic to multiple websites, and supporting websockets.</p>
<p>One especially useful feature is SSL or TLS termination. Because encrypting and decrypting traffic is computationally expensive, you can offload that task to the application gateway so the web servers don’t have to do it. However, if your security requirements won’t allow any unencrypted traffic, then you shouldn’t do this, because the traffic between the gateway and the backend web servers would be unencrypted.</p>
<p>Speaking of security, one of the biggest reasons for using an application gateway is the built-in web application firewall. It protects your applications from common exploits, such as SQL injection and cross-site scripting attacks.</p>
<p>Both of Azure’s load balancing options work within a single region. If you want to provide load balancing for VMs or web apps that are distributed across multiple regions, then you’ll need to use Azure Traffic Manager. This service redirects traffic at the DNS level. It <em>doesn’t</em> act as a gateway—it simply tells the client which address it should connect to.</p>
<p>For example, suppose you have an application that’s deployed in 3 regions: East US, West Europe, and Southeast Asia. To minimize the network latency for every user, you could configure Traffic Manager to check where each request is coming from and direct it to the closest region. This is called performance routing. If one of the regions goes down, then Traffic Manager can redirect requests to the next nearest region. This is called priority routing.</p>
<p>There are also two other routing methods available. With weighted routing, it will distribute requests either evenly among the endpoints or according to weights, such as 50% to endpoint 1, 30% to endpoint 2, and 20% to endpoint 3. Geographic routing is similar to performance routing because it looks at the client’s location. The difference is that you can specify exactly which region you want a client to connect to based on their location. For example, if your European customers require that their data stays in Europe, then you could always route them to a European region.</p>
<p>In most cases, you’ll want to use Traffic Manager in conjunction with one of the other two load balancing solutions. You could even use all three of them together. For example, within each region, you could have an application gateway for SSL offloading and an Azure load balancer to distribute requests to the VMs.</p>
<p>Traffic Manager will also work with non-Azure endpoints, such as applications that are on-premises or in another public cloud.</p>
<p>And that’s it for load balancing.</p>
<h1 id="External-Connectivity"><a href="#External-Connectivity" class="headerlink" title="External Connectivity"></a>External Connectivity</h1><p>When most organizations migrate to the cloud, they continue to have a significant amount of infrastructure on-premises and they need to connect those local resources with what they’ve deployed in the cloud. Microsoft provides several ways to do this.</p>
<p>The first decision to make is whether you’ll connect them over the internet. You might not want to do this if you’re concerned about the reliability, performance, or security of this method. If any or all of those concerns are deal-breakers for your organization, then you should choose ExpressRoute.</p>
<p>There are four ways to connect to Azure using ExpressRoute. If your infrastructure is colocated in a datacenter that has a cloud exchange, then you can get an Azure cross-connection through the colocation provider. If you’re not in that sort of facility, but you use a WAN provider, then they can make the Azure cloud look like one of your branch offices. The third option is to use a point-to-point ethernet provider.</p>
<p>All three of these methods use a service provider to connect your infrastructure to Azure. Alternatively, if your infrastructure is located in what Microsoft calls an ExpressRoute location, then you can use ExpressRoute Direct. With this method, you connect to Azure directly without going through a service provider. One advantage of ExpressRoute Direct is that it can support connections up to 100 gigabits per second, which is 10 times as much as you can get through a service provider.</p>
<p>Regardless of which of these methods you use, you’ll have a redundant layer 3 connection that doesn’t go over the internet. Routing is handled using BGP.</p>
<p>If you’re okay with using encrypted connections over the internet instead of taking on the expense of a direct connection, then you can put an Azure VPN Gateway in a virtual network. Once you’ve set that up, there are two ways to to create an encrypted connection to it.</p>
<p>For a site-to-site connection, you install a VPN device with a public IP address at your on-premises location. Then you deploy a VPN gateway in your Azure virtual network. It must be in a gateway subnet that doesn’t have any VMs in it. You also have to make sure that the IP address space of the virtual network doesn’t overlap with the address space of your on-premises network. When both sides are ready, you can set up an IPsec tunnel between the two networks.</p>
<p>If you want to connect multiple sites to the same virtual network, you can set up a VPN device at each location and connect them all to the same VPN gateway. You can only have one VPN gateway per virtual network. This is known as a multi-site configuration. All connections to the same VPN gateway share its available bandwidth.</p>
<p>The second way to connect is called point-to-site. With this method, you connect individual computers to the VPN gateway in your virtual network. You don’t have to use a VPN device, so this is suitable for remote workers and telecommuters. It uses the Secure Socket Tunneling Protocol (or SSTP) on Windows devices and IKEv2 VPN on Macs.</p>
<p>Point-to-site connections use certificate-based authentication. To set this up, first you need either a root certificate from a certificate authority or a self-signed root certificate that you create yourself. Next, you generate client certificates from the root certificate. Then you need to install a client certificate on each client device that will be using a point-to-site connection.</p>
<p>You can connect to the same VPN gateway with both site-to-site and point-to-site methods as long as you can use the same configuration for both. The main issue is what type of routing you configure the VPN gateway to use. Site-to-site connections can use either route-based or policy-based routing. For most scenarios, route-based is the best option, because it’s dynamic, requires less maintenance, and can tolerate failures in the network path. Policy-based routing is static, so you have to maintain all of the routes manually. You’d only want to choose this option is you require strict control of your routing.</p>
<p>Multi-site and point-to-site configurations have to use route-based routing, so they can’t share a VPN gateway with a site-to-site configuration that uses policy-based routing, because a VPN gateway can only be configured to support one type of routing.</p>
<p>Even when you’re using ExpressRoute to connect to your Azure virtual networks, there’s still a reason to use a VPN gateway. You can set up a site-to-site connection as a failover in case your ExpressRoute connection goes down. Traffic would only go through the VPN tunnel if the ExpressRoute connection is not available.</p>
<p>You can also use VPN gateways to connect two virtual networks, but it’s much easier to use virtual network peering, which is a newer feature. To do it, go into one of the virtual networks in the portal, select Peerings from the menu, and click Add. Give it a name. I’ll use the name of the first virtual network dash and the name of the second virtual network. To complete the connection, you also need to create a peering in the other direction in the second virtual network. Then choose the subscription where the second virtual network resides, and finally, choose the second VNet.</p>
<p>Okay, it’s done. The peering from vnet1 to vnet2 is showing a status of “Connected”. Let’s check the second peering as well. It’s connected, too. Once the status of both peerings is “Connected”, instances in the two VNets will be able to communicate with each other as if they were in the same VNet.</p>
<p>You can even do this with virtual networks that are in different regions, which is known as global vnet peering. Traffic between them still goes through the Microsoft backbone network rather than the internet, so the connection is private and has high bandwidth and low latency.</p>
<p>When you create a virtual network, Azure automatically creates a route table for each of the subnets. It then adds system default routes to each table. For example, it creates routes so all of the instances within the virtual network can connect to each other. It also creates a catch-all route that sends traffic to the internet if no other route is applicable. If you don’t want traffic to go to the internet, then you need to override it with a custom route, also known as a user-defined route.</p>
<p>Another example of when you’d use a custom route is if you set up a virtual appliance, such as a firewall, and you need to route traffic through it. In this case, in addition to adding a custom route to the table, you’d also need to enable IP forwarding on the network interface that’s attached to the virtual appliance. Otherwise, Azure would prevent it from forwarding traffic.</p>
<p>So far, I’ve been talking about connectivity for VM instances, but it’s also possible to get the same networking benefits with containers. When you create an Azure Kubernetes Service cluster, you can select the advanced networking option and specify a virtual network and subnet to put the cluster in. Then the nodes in the cluster will use the Azure Container Networking Interface plugin to connect to the virtual network. With this setup, Kubernetes pods can communicate with the rest of your network, including your on-premises network through ExpressRoute or a VPN gateway.</p>
<p>And that’s it for external connectivity.</p>
<h1 id="Security-Strategies"><a href="#Security-Strategies" class="headerlink" title="Security Strategies"></a>Security Strategies</h1><p>When you put an application on the web, you can be sure that hackers and bots will probe it for weaknesses soon afterward. If they find weaknesses, then they’ll likely compromise it in either an obvious way, or even worse, in a way that you don’t notice. So before you deploy any web applications, you need to architect a security solution.</p>
<p>The first step is for your application developers to design secure code. That’s a good start, but it’s difficult to ensure that every application can withstand attacks. So you’ll need to put some type of centralized protection in front of all of your applications.</p>
<p>Azure provides a lot of great network security features to help with this, such as DDoS protection, virtual network isolation, and network security groups (which we’ll talk about more in a minute), but you should also add a layer that’s designed to combat a broad array of threats to web apps.</p>
<p>One good option is the Web Application Firewall that comes with the Azure Application Gateway. It’s based on the well-known Open Web Application Security Project (or OWASP) core rule sets. It protects against attacks like:</p>
<ul>
<li>SQL injection</li>
<li>Cross-site scripting</li>
<li>HTTP request smuggling</li>
<li>Remote file inclusion, and</li>
<li>HTTP protocol violations and anomalies</li>
</ul>
<p>It also detects common misconfigurations in web servers like Apache or IIS.</p>
<p>You can run it in either detection or prevention mode. In detection mode, it simply logs all security alerts. In prevention mode, it actually blocks the attacks that it detects. To monitor the firewall’s activities in either mode, you can look in Azure Monitor, Azure Security Center, and Log Analytics, because they’re all integrated with it.</p>
<p>Although Microsoft’s Web Application Firewall is very capable, you may still want to use a different solution, either because your organization has standardized on a third-party security product or because you need a firewall with additional features. Fortunately, a number of vendors, such as Barracuda and Palo Alto Networks, provide pre-built virtual machines that you can get from the Azure Marketplace. These are known as network virtual appliances.</p>
<p>Ideally, these appliances should be put in a demilitarized zone (or DMZ). This is a perimeter network that keeps unwanted traffic, including attacks, from getting through to your backend network. In this example, the perimeter network and the backend network are two subnets within the same virtual network.</p>
<p>To control the flow of traffic between these two subnets, you can use an NSG (which stands for network security group). An NSG contains security rules that allow or deny traffic to resources in a subnet of a virtual network. They’re similar to firewall rules. You can also apply NSGs to the network interfaces of specific VMs (if they were deployed using Resource Manager) or to all of the traffic to and from specific VMs (if they were deployed using the classic model), but it’s usually better to apply them to an entire subnet.</p>
<p>Here’s an example NSG. It has inbound and outbound rules. The most important are the inbound rules. The first inbound rule allows DNS traffic over port 53 from anything inside the virtual network to the DNS server, which has this address.</p>
<p>Notice that I didn’t have to specify an address range for the source. That’s because Microsoft lets you use service tags instead. This greatly simplifies your rules and makes them easier to read and understand. For example, the VirtualNetwork tag includes the virtual network address space, all connected on-premises address spaces, and all peered virtual networks or virtual networks connected through a VPN gateway. If you had to specify all of those address ranges yourself, the rule would be pretty complicated and it would be easy to make a mistake when creating the rule. Another advantage is that the addresses in a service tag are automatically updated when something changes, so you don’t need to update your rules. In case you’re wondering, you can’t create your own service tags. You can only use the predefined ones.</p>
<p>The second rule allows RDP traffic over port 3389 from the internet to this virtual network so you can remotely administer the VMs. Notice that “Internet” is also a service tag again. The third rule allows traffic to the firewall, which has this address. The next one allows traffic between the web server and the app servers. The destination is a list of both addresses.</p>
<p>After all of these allow rules, we add deny rules. The first one denies all traffic from the internet to this virtual network. Since it has a lower priority than this allow rule, it will only be applied for traffic that doesn’t match the allow rule. Finally, we deny all traffic between the frontend and backend subnets that wasn’t explicitly allowed above. These three rules at the bottom are added by default. You can’t change or delete them, but you can override them with the rules above, which is what we’ve done. To activate this NSG, you’d need to associate it with both the frontend and backend subnets.</p>
<p>By default, the outbound rules allow all outgoing internet traffic. This could be dangerous as your VMs might accidentally leak sensitive information to the internet. You can add a security layer by using forced tunneling.</p>
<p>With this configuration, all internet-bound traffic has to go through your on-premises network before going out to the internet. This gives you the opportunity to run this traffic through an inspection and auditing system that’s installed on-premises.</p>
<p>The way to do this is pretty straightforward. You create a user-defined default route that points to the VPN gateway in your virtual network. Then, on the VPN gateway, you set the default site to the on-premises location where you want to redirect the traffic. If you’re using ExpressRoute rather than a site-to-site VPN, then instead you advertise a default route via the BGP peering sessions.</p>
<p>Since forced tunneling can significantly slow down internet-bound traffic, you usually shouldn’t use it on frontend web servers. It’s more suitable for backend servers.</p>
<p>And that’s it for security strategies.</p>
<h1 id="Connectivity-for-Hybrid-Applications"><a href="#Connectivity-for-Hybrid-Applications" class="headerlink" title="Connectivity for Hybrid Applications"></a>Connectivity for Hybrid Applications</h1><p>In an earlier lesson, you learned how to make external connections from Azure, especially using ExpressRoute or a VPN. Those solutions are great, but if you only need external connectivity for a single application, then they’re probably overkill, because you need to modify your network to use them. Fortunately, there are much simpler, more focused solutions that you can use instead.</p>
<p>Azure provides many services to help you build hybrid applications that combine Azure and on-premises resources. Which one you use depends on what you’re trying to do. Azure WCF Relay lets you expose Windows Communication Foundation services in on-premises applications to Azure. Azure Relay Hybrid Connections is a newer service that does the same thing for WebSockets and HTTP rather than WCF. You can also use Hybrid Connections from within Azure App Service. The Azure Data Management Gateway, now known as the Self-hosted Integration Runtime, lets you copy data between Azure and on-premises data stores. Finally, the Azure On-Premises Data Gateway connects on-premises data sources with Azure Analysis Services.</p>
<p>I have to admit that I get the Data Management Gateway and the On-Premises Data Gateway confused sometimes, because their names sound very similar, even though they’re totally different. Maybe that’s why Microsoft renamed Data Management Gateway to Self-hosted Integration Runtime. Of course, the new name doesn’t really help you remember what it does either. Oh well, after you’ve worked with them for a while, you’ll remember which one is which.</p>
<p>Azure Relay service allows you to expose on-premises applications to Azure without having to open a port on your firewall. The way this works is the server and the client communicate through an Azure Service Bus namespace. The on-premises application communicates with Service Bus over HTTP or HTTPS. Since these ports are already open on most firewalls, no changes are needed. Of course, both the server and the client need to include code that connects to Azure Relay.</p>
<p>Originally, Azure Relay was called Service Bus Relay and it only worked with Windows Communication Foundation services. Microsoft renamed it WCF Relay, because they created an alternative feature that doesn’t use WCF. It’s called Hybrid Connections and it works with WebSockets and HTTP. WCF Relay and Hybrid Connections exist as side-by-side alternatives in the Azure Relay service.</p>
<p>Microsoft considers WCF Relay to be a legacy service, though. If you have existing WCF-based applications, then WCF Relay is the way to go, but if you’re developing new applications, you should write them with WebSockets or HTTP instead and use Hybrid Connections. The biggest advantage of using WebSockets or HTTP is that they’re open standards, so you can use them in any language on any platform that supports them.</p>
<p>Azure App Service has a Hybrid Connections feature as well, but it works slightly differently. Suppose you have an Azure app that needs to access an on-premises database. You’d have to install a Hybrid Connection Manager (or HCM) in the network where the database resides. It runs on Windows Server 2012 and higher. Both sides would still connect to Service Bus, but the on-premises side would connect through the HCM to get to Service Bus. This would set up a TCP tunnel between the app and the database. The connection would be over HTTPS. Authentication and authorization would be done using a shared access signature.</p>
<p>By the way, if you already have a VPN connection between an Azure virtual network and an on-premises location, then App Service can use it through its VNet Integration feature. OK, on to the Self-hosted Integration Runtime (formerly known as the Data Management Gateway). This is an on-premises client that works with Azure Data Factory, so let’s go over how Data Factory works before diving into the Integration Runtime client.</p>
<p>Data Factory is used to move and transform data. For example, suppose that every night you want to copy records from SQL Database to Data Lake Store, then run a Spark job on an HDInsight cluster to process that data, and finally, store the processed data in SQL Data Warehouse. You could automate this process by creating a Data Factory pipeline that consists of three activities, one for each step.</p>
<p>Before creating the pipeline and activities, you’d need to define the data sources and sinks. First, you’d create a linked service for each data source. A linked service contains the connection information Data Factory will use to access the data. For example, the linked service for the input data would give the connection string for the SQL Database instance. Then you’d create a dataset that tells Data Factory which data to access. In this case, it would be the name of the table. You’d also need to create linked services and datasets for Data Lake Store and SQL Data Warehouse.</p>
<p>Now you could create a pipeline with 3 activities in it, one to copy the data from SQL Database to Data Lake Store, one to spin up an HDInsight cluster and run a Spark job, and one to copy the output data to SQL Data Warehouse. Once the pipeline is ready, you could run it manually, but it would be much easier to schedule it to run every night automatically, which you could do by setting a schedule trigger.</p>
<p>OK, so that’s how Data Factory normally works, but how do you get it to work with external data? That’s where the Self-hosted Integration Runtime comes in. You install it in your on-premises environment, register it with Azure, and connect it to your SQL Server instance. Then, when you create the linked service for the data source, you give it the connection details for the SQL Server instance, but you tell it to connect using the integration runtime.</p>
<p>Data Factory supports two other integration runtimes as well. The Azure Integration Runtime is the default, so you don’t normally need to explicitly create it. The Azure-SSIS Integration Runtime lets you run SQL Server Integration Services packages on Azure. An SSIS package is actually kind of like a Data Factory pipeline. It contains a series of tasks to transform data. If you already have SSIS packages that you’ve been running locally, then this is a great way to lift and shift them to Azure.</p>
<p>When you create an SSIS Integration Runtime, you are provisioning a cluster that can run SSIS packages. Once it’s provisioned, you can even use SQL Server Data Tools or SQL Server Management Studio to deploy packages to it. However, the SSIS integration runtime incurs charges while it’s running, so to save money, you can use Data Factory to start it, execute an SSIS package, and stop it. This is similar to how Data Factory spins up an HDInsight cluster to process data. If your SSIS packages need to access on-premises data, then you have to connect the integration runtime to a virtual network that’s connected to your on-premises environment.</p>
<p>Alright, now we’ll move on to the Azure On-Premises Data Gateway. This is something you install onsite that will let Azure Analysis Services retrieve on-premises data. First, you install it as a Windows service. Then you register it with the Gateway Cloud Service. Next, you create a gateway resource in Azure. Finally, you connect your Azure Analysis Services servers to your gateway resource.</p>
<p>Once you have it set up, your data models can access your on-premises data sources through the gateway resource, which goes through Azure Service Bus to reach the On-Premises Data Gateway, which connects to your data sources.</p>
<p>As you’ve seen, there are usually better ways to connect specific on-premises resources to Azure than using a VPN or ExpressRoute. Another example of this is with domain services. Most Azure customers already have a locally-installed Active Directory Domain, so if you have a direct connection to Azure, then it might seem like a good idea to just connect your Azure VMs to your on-premises domain servers. Although that would work, it could potentially be unreliable or slow, especially over a VPN.</p>
<p>A better solution is to use Azure Active Directory Domain Services. I won’t go into the details of synchronizing it with your on-premises domain, because that’s covered in our Active Directory course. I do want to point out a couple of things to watch out for when you’re joining an Azure VM to a domain, though. First, the VM needs to be in a virtual network that’s connected to the one where your managed domain resides. Otherwise, it won’t be able to join. Second, the user whose credentials you specify for joining the VM to the domain has to be a member of the Azure AD domain controller administrators group or it won’t work.</p>
<p>And that’s it for hybrid application connectivity.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>I hope you enjoyed learning about Azure’s network services. Let’s do a quick review of what you learned.</p>
<p>An Azure virtual network has an IP address space and at least one subnet. IP addresses are assigned by an Azure DHCP server. VMs in a virtual network can communicate with each other using Azure-provided name resolution. You can provision your own DNS server in the vnet to resolve other addresses. Use Azure DNS Private Zones if you need custom domain names or name resolution between virtual networks. To accept inbound connections from the internet, assign public IP addresses to resources in a vnet. A virtual network service endpoint lets you extend the address space in your vnet to services that can’t reside in a vnet, such as Azure Storage and Azure SQL Database.</p>
<p>Azure Load Balancer acts as a frontend that distributes incoming traffic to a pool of backend VMs. It supports TCP and UDP applications. By default, the load balancer sends a probe to each backend VM every 15 seconds. If a health probe fails, then the VM is removed from the pool. A public load balancer has a public IP address for internet-facing applications. When a VM initiates an outbound connection, the load balancer performs network address translation. An internal load balancer doesn’t have a public IP address.</p>
<p>The other way to provide load balancing is to use Azure Application Gateway, which operates at layer 7 of the network stack. It can route based on the URL, redirect all HTTP requests to HTTPS, serve traffic to multiple websites, support WebSockets, and handle SSL offloading.</p>
<p>To provide load balancing across multiple regions, use Azure Traffic Manager, which redirects traffic at the DNS level. Performance routing directs a request to the closest region. Priority routing redirects requests to the next best region if there’s an outage. Weighted routing distributes requests either evenly among the endpoints or according to weights. Geographic routing directs a request to a specific region based on the client’s location.</p>
<p>ExpressRoute provides a redundant layer 3 connection between your on-premises location and Azure. You can connect using a colocation provider, a WAN provider, or a point-to-point ethernet provider. Routing is handled using BGP.</p>
<p>To connect over the internet instead, deploy an Azure VPN Gateway in a virtual network. In a site-to-site configuration, you create an IPsec tunnel to the gateway through an on-premises VPN device. In a multi-site configuration, there’s a VPN device at each remote location, but still only one VPN Gateway in the Azure virtual network. Point-to-site connections use certificate-based authentication instead of a VPN device. This configuration is intended for individual computers or devices.</p>
<p>Multi-site and point-to-site configurations have to use route-based routing, which is dynamic. Site-to-site connections can use either route-based or policy-based routing, which is static. Policy-based routing requires more maintenance, so it should only be used when necessary. Also, a VPN gateway can only be configured to support one type of routing, so a site-to-site configuration that uses policy-based routing can’t share a VPN gateway with multi-site or point-to-site configurations. If you have an ExpressRoute connection, you can set up a site-to-site connection as a failover in case your primary connection goes down.</p>
<p>Virtual network peering allows instances in two virtual networks to communicate with each over the Microsoft backbone network, even if they’re in different regions.</p>
<p>Each subnet in a virtual network has a route table with system default routes in it. You can override these routes with custom routes, also known as user-defined routes.</p>
<p>If you put an Azure Kubernetes Service cluster in a subnet of a virtual network, then the nodes in the cluster can use the Azure Container Networking Interface plugin to communicate with the rest of the network.</p>
<p>The Web Application Firewall that comes with the Azure Application Gateway protects against attacks, such as SQL injection and cross-site scripting. You can run it in either detection or prevention mode. Alternatively, you could use a network virtual appliance from a third-party vendor. These appliances should be put in a demilitarized zone that keeps unwanted traffic from getting through to your backend network.</p>
<p>A network security group contains rules that allow or deny traffic to resources in a subnet of a virtual network. You can also apply NSGs to the network interfaces of specific VMs if they were deployed using Resource Manager.</p>
<p>Service tags simplify your rules. For example, the VirtualNetwork tag includes the virtual network address space, all connected on-premises address spaces, and all peered virtual networks or virtual networks connected through a VPN gateway.</p>
<p>By default, the outbound rules allow all outgoing internet traffic. To force all internet-bound traffic to go through an inspection and auditing system first, use forced tunneling to your on-premises network.</p>
<p>Azure WCF Relay lets you expose Windows Communication Foundation (or WCF) services in on-premises applications to Azure without having to open a port on your firewall. Azure Relay Hybrid Connections is a newer service that does the same thing for WebSockets and HTTP rather than WCF. You can also use Hybrid Connections from within Azure App Service, but you have to install a Hybrid Connection Manager in the network where the database resides. The Azure Data Management Gateway, now known as the Self-hosted Integration Runtime, lets Azure Data Factory copy data between Azure and on-premises data stores. The Azure On-Premises Data Gateway connects on-premises data sources with Azure Analysis Services.</p>
<p>To copy on-premises data using Data Factory, first install the Self-hosted Integration Runtime on-premises, register it with Azure, and connect it to your local data source. Next, create a linked service that accesses the data source via the integration runtime. Also create a linked service for the Azure data sink. Then create datasets for the data source and data sink. Finally, create a pipeline and a copy activity.</p>
<p>An Azure-SSIS Integration Runtime is an Azure cluster that lets you run SQL Server Integration Services packages.</p>
<p>To join a VM to a domain, make sure it’s in a virtual network that’s connected to the one where your Azure Active Directory managed domain resides.</p>
<p>Now you know how to design Azure virtual networks; design external connectivity for Azure virtual networks; design network security strategies for Azure; and design connectivity for hybrid Azure applications.</p>
<p>To learn more about Azure’s network services, you can read Microsoft’s documentation. Also watch for new Microsoft Azure courses on Cloud Academy, because we’re always publishing new courses. Please give this course a rating, and if you have any questions or comments, please let us know. Thanks and keep on learning!</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/15/AZ-500-Configuring-Azure-Application-and-Data-Security-17/" rel="prev" title="AZ-500-Configuring-Azure-Application-and-Data-Security-17">
      <i class="fa fa-chevron-left"></i> AZ-500-Configuring-Azure-Application-and-Data-Security-17
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/15/AZ-500-Lab-Securing-Azure-Storage-Account-using-Private-Endpoints-19/" rel="next" title="AZ-500-Lab-Securing-Azure-Storage-Account-using-Private-Endpoints-19">
      AZ-500-Lab-Securing-Azure-Storage-Account-using-Private-Endpoints-19 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Azure-Virtual-Networks"><span class="nav-number">2.</span> <span class="nav-text">Azure Virtual Networks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Load-Balancing"><span class="nav-number">3.</span> <span class="nav-text">Load Balancing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#External-Connectivity"><span class="nav-number">4.</span> <span class="nav-text">External Connectivity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Security-Strategies"><span class="nav-number">5.</span> <span class="nav-text">Security Strategies</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Connectivity-for-Hybrid-Applications"><span class="nav-number">6.</span> <span class="nav-text">Connectivity for Hybrid Applications</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hang Zhang"
      src="/images/123456.gif">
  <p class="site-author-name" itemprop="name">Hang Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2736</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zh375636" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zh375636" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hang.zhang.network@gmail.com" title="E-Mail → mailto:hang.zhang.network@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hang Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



// 在最后添加
<script src="/js/code-unfold.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '40GUvOAaitQh1SZe7ua9cvss-MdYXbMMI',
      appKey     : 'iUO2yON0j55WMdu59zx12dCG',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
